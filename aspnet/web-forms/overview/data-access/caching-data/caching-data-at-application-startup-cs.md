---
uid: web-forms/overview/data-access/caching-data/caching-data-at-application-startup-cs
title: 缓存数据在应用程序启动 (C#) |Microsoft Docs
author: rick-anderson
description: 在任何 Web 应用程序中的某些数据将频繁使用，将不常使用的某些数据。 我们可以改进我们的 ASP.NET 应用程序 b 的性能...
ms.author: aspnetcontent
ms.date: 05/30/2007
ms.assetid: 22ca8efa-7cd1-45a7-b9ce-ce6eb3b3ff95
msc.legacyurl: /web-forms/overview/data-access/caching-data/caching-data-at-application-startup-cs
msc.type: authoredcontent
ms.openlocfilehash: fdc24f215238a0c44e40a3fcc087230565efa52b
ms.sourcegitcommit: b28cd0313af316c051c2ff8549865bff67f2fbb4
ms.translationtype: MT
ms.contentlocale: zh-CN
ms.lasthandoff: 07/05/2018
ms.locfileid: "37829763"
---
<a name="caching-data-at-application-startup-c"></a><span data-ttu-id="d9299-104">缓存数据在应用程序启动 (C#)</span><span class="sxs-lookup"><span data-stu-id="d9299-104">Caching Data at Application Startup (C#)</span></span>
====================
<span data-ttu-id="d9299-105">通过[Scott Mitchell](https://twitter.com/ScottOnWriting)</span><span class="sxs-lookup"><span data-stu-id="d9299-105">by [Scott Mitchell](https://twitter.com/ScottOnWriting)</span></span>

[<span data-ttu-id="d9299-106">下载 PDF</span><span class="sxs-lookup"><span data-stu-id="d9299-106">Download PDF</span></span>](caching-data-at-application-startup-cs/_static/datatutorial60cs1.pdf)

> <span data-ttu-id="d9299-107">在任何 Web 应用程序中的某些数据将频繁使用，将不常使用的某些数据。</span><span class="sxs-lookup"><span data-stu-id="d9299-107">In any Web application some data will be frequently used and some data will be infrequently used.</span></span> <span data-ttu-id="d9299-108">我们可以通过预先加载常用数据，称为的技术改进我们的 ASP.NET 应用程序的性能。</span><span class="sxs-lookup"><span data-stu-id="d9299-108">We can improve the performance of our ASP.NET application by loading in advance the frequently-used data, a technique known as.</span></span> <span data-ttu-id="d9299-109">本教程演示了主动加载，这是将数据加载到应用程序启动时缓存的一种方法。</span><span class="sxs-lookup"><span data-stu-id="d9299-109">This tutorial demonstrates one approach to proactive loading, which is to load data into the cache at application startup.</span></span>


## <a name="introduction"></a><span data-ttu-id="d9299-110">介绍</span><span class="sxs-lookup"><span data-stu-id="d9299-110">Introduction</span></span>

<span data-ttu-id="d9299-111">两个以前的教程介绍了在演示文稿和缓存层中缓存数据。</span><span class="sxs-lookup"><span data-stu-id="d9299-111">The two previous tutorials looked at caching data in the Presentation and Caching Layers.</span></span> <span data-ttu-id="d9299-112">在中[使用 ObjectDataSource 缓存数据](caching-data-with-the-objectdatasource-cs.md)，我们了解了使用缓存在表示层中缓存数据的功能的 ObjectDataSource s。</span><span class="sxs-lookup"><span data-stu-id="d9299-112">In [Caching Data with the ObjectDataSource](caching-data-with-the-objectdatasource-cs.md), we looked at using the ObjectDataSource s caching features to cache data in the Presentation Layer.</span></span> <span data-ttu-id="d9299-113">[缓存体系结构中的数据](caching-data-in-the-architecture-cs.md)检查在缓存中新的、 独立缓存层。</span><span class="sxs-lookup"><span data-stu-id="d9299-113">[Caching Data in the Architecture](caching-data-in-the-architecture-cs.md) examined caching in a new, separate Caching Layer.</span></span> <span data-ttu-id="d9299-114">这两个使用这些教程*反应加载*中使用的数据缓存。</span><span class="sxs-lookup"><span data-stu-id="d9299-114">Both of these tutorials used *reactive loading* in working with the data cache.</span></span> <span data-ttu-id="d9299-115">与被动加载，每次请求数据时，系统首先检查它在缓存。</span><span class="sxs-lookup"><span data-stu-id="d9299-115">With reactive loading, each time the data is requested, the system first checks if it s in the cache.</span></span> <span data-ttu-id="d9299-116">否则，它获取原始源，例如，数据库中的数据，然后将其存储在缓存中。</span><span class="sxs-lookup"><span data-stu-id="d9299-116">If not, it grabs the data from the originating source, such as the database, and then stores it in the cache.</span></span> <span data-ttu-id="d9299-117">响应式加载的主要优点是实现其易用性。</span><span class="sxs-lookup"><span data-stu-id="d9299-117">The main advantage to reactive loading is its ease of implementation.</span></span> <span data-ttu-id="d9299-118">在请求之间，其缺点之一是其性能不稳定。</span><span class="sxs-lookup"><span data-stu-id="d9299-118">One of its disadvantages is its uneven performance across requests.</span></span> <span data-ttu-id="d9299-119">假设使用前面教程中的缓存层来显示产品信息的页面。</span><span class="sxs-lookup"><span data-stu-id="d9299-119">Imagine a page that uses the Caching Layer from the preceding tutorial to display product information.</span></span> <span data-ttu-id="d9299-120">当此页是第一次访问或缓存的数据已退出由于内存约束或具有已达到指定的到期后第一次访问过时，则必须从数据库检索的数据。</span><span class="sxs-lookup"><span data-stu-id="d9299-120">When this page is visited for the first time, or visited for the first time after the cached data has been evicted due to memory constraints or the specified expiry having been reached, the data must be retrieved from the database.</span></span> <span data-ttu-id="d9299-121">因此，这些用户请求将执行时间超过可以提供的用户请求的缓存。</span><span class="sxs-lookup"><span data-stu-id="d9299-121">Therefore, these users requests will take longer than users requests that can be served by the cache.</span></span>

<span data-ttu-id="d9299-122">*主动加载*提供替代缓存管理策略性能平滑处理在请求之间通过加载之前缓存的数据需要。</span><span class="sxs-lookup"><span data-stu-id="d9299-122">*Proactive loading* provides an alternative cache management strategy that smoothes out the performance across requests by loading the cached data before it s needed.</span></span> <span data-ttu-id="d9299-123">通常情况下，主动加载使用某些进程，可定期检查或已对基础数据的更新时收到通知。</span><span class="sxs-lookup"><span data-stu-id="d9299-123">Typically, proactive loading uses some process that either periodically checks or is notified when there has been an update to the underlying data.</span></span> <span data-ttu-id="d9299-124">然后，此过程更新缓存，以使其保持最新。</span><span class="sxs-lookup"><span data-stu-id="d9299-124">This process then updates the cache to keep it fresh.</span></span> <span data-ttu-id="d9299-125">主动加载是特别有用，如果基础数据来自速度缓慢的数据库连接、 Web 服务或某些其他尤其缓慢的数据源。</span><span class="sxs-lookup"><span data-stu-id="d9299-125">Proactive loading is especially useful if the underlying data comes from a slow database connection, a Web service, or some other particularly sluggish data source.</span></span> <span data-ttu-id="d9299-126">但与主动加载这种方法是更难以实现，因为它需要创建、 管理和部署过程以检查更改并更新缓存。</span><span class="sxs-lookup"><span data-stu-id="d9299-126">But this approach to proactive loading is more difficult to implement, as it requires creating, managing, and deploying a process to check for changes and update the cache.</span></span>

<span data-ttu-id="d9299-127">另一种形式主动加载和我们将在本教程中探讨的类型将数据加载到应用程序启动时缓存。</span><span class="sxs-lookup"><span data-stu-id="d9299-127">Another flavor of proactive loading, and the type we'll be exploring in this tutorial, is loading data into the cache at application startup.</span></span> <span data-ttu-id="d9299-128">这种方法是用于缓存静态数据，如数据库查找表中记录特别有用。</span><span class="sxs-lookup"><span data-stu-id="d9299-128">This approach is especially useful for caching static data, such as the records in database lookup tables.</span></span>

> [!NOTE]
> <span data-ttu-id="d9299-129">有关主动和被动加载的优点、 缺点和实现的建议列表之间的差异的深入信息，请参阅[管理缓存的内容](https://msdn.microsoft.com/library/ms978503.aspx)一部分[缓存的.NET Framework 应用程序的体系结构指南](https://msdn.microsoft.com/library/ms978498.aspx)。</span><span class="sxs-lookup"><span data-stu-id="d9299-129">For a more in-depth look at the differences between proactive and reactive loading, as well as lists of pros, cons, and implementation recommendations, refer to the [Managing the Contents of a Cache](https://msdn.microsoft.com/library/ms978503.aspx) section of the [Caching Architecture Guide for .NET Framework Applications](https://msdn.microsoft.com/library/ms978498.aspx).</span></span>


## <a name="step-1-determining-what-data-to-cache-at-application-startup"></a><span data-ttu-id="d9299-130">步骤 1： 确定哪些应用程序启动时缓存的数据</span><span class="sxs-lookup"><span data-stu-id="d9299-130">Step 1: Determining What Data to Cache at Application Startup</span></span>

<span data-ttu-id="d9299-131">使用被动加载缓存示例中，我们探讨在以前的两个教程工作良好的数据可能会定期更改，而不使用 exorbitantly 长生成。</span><span class="sxs-lookup"><span data-stu-id="d9299-131">The caching examples using reactive loading that we examined in the previous two tutorials work well with data that may periodically change and does not take exorbitantly long to generate.</span></span> <span data-ttu-id="d9299-132">但是，如果缓存的数据永远不会更改，过期日期由反应加载多余。</span><span class="sxs-lookup"><span data-stu-id="d9299-132">But if the cached data never changes, the expiry used by reactive loading is superfluous.</span></span> <span data-ttu-id="d9299-133">同样，如果要缓存的数据采用非常长的时间才能生成，则检索这些用户的请求查找必须经受基础数据时耗时较长等待缓存为空。</span><span class="sxs-lookup"><span data-stu-id="d9299-133">Likewise, if the data being cached takes an exceedingly long time to generate, then those users whose requests find the cache empty will have to endure a lengthy wait while the underlying data is retrieved.</span></span> <span data-ttu-id="d9299-134">请考虑缓存静态数据和所用的特别长时间来在应用程序启动时生成的数据。</span><span class="sxs-lookup"><span data-stu-id="d9299-134">Consider caching static data and data that takes an exceptionally long time to generate at application startup.</span></span>

<span data-ttu-id="d9299-135">当数据库都有很多动态时，频繁地更改值，但大多数还有大量的静态数据。</span><span class="sxs-lookup"><span data-stu-id="d9299-135">While databases have many dynamic, frequently-changing values, most also have a fair amount of static data.</span></span> <span data-ttu-id="d9299-136">例如，几乎所有数据模型都具有包含特定值从一组固定的选项的一个或多个列。</span><span class="sxs-lookup"><span data-stu-id="d9299-136">For example, virtually all data models have one or more columns that contain a particular value from a fixed set of choices.</span></span> <span data-ttu-id="d9299-137">一个`Patients`数据库表可能具有`PrimaryLanguage`列，其组的值可能是英语、 西班牙语、 法语、 俄语、 日语和等等。</span><span class="sxs-lookup"><span data-stu-id="d9299-137">A `Patients` database table might have a `PrimaryLanguage` column, whose set of values could be English, Spanish, French, Russian, Japanese, and so on.</span></span> <span data-ttu-id="d9299-138">通常，使用实现这些类型的列*查找表*。</span><span class="sxs-lookup"><span data-stu-id="d9299-138">Oftentimes, these types of columns are implemented using *lookup tables*.</span></span> <span data-ttu-id="d9299-139">而不是存储英语或法语中的字符串`Patients`表中，第二个表将创建一个常见的是，带有两个列中的唯一标识符和字符串说明-与每个可能值的记录。</span><span class="sxs-lookup"><span data-stu-id="d9299-139">Rather than storing the string English or French in the `Patients` table, a second table is created that has, commonly, two columns - a unique identifier and a string description - with a record for each possible value.</span></span> <span data-ttu-id="d9299-140">`PrimaryLanguage`中的列`Patients`表查找表中存储的相应的唯一标识符。</span><span class="sxs-lookup"><span data-stu-id="d9299-140">The `PrimaryLanguage` column in the `Patients` table stores the corresponding unique identifier in the lookup table.</span></span> <span data-ttu-id="d9299-141">在图 1 中，患者 John Doe s 主要语言是英语，而 Ed Johnson s 是俄语。</span><span class="sxs-lookup"><span data-stu-id="d9299-141">In Figure 1, patient John Doe s primary language is English, while Ed Johnson s is Russian.</span></span>


![语言表是通过患者表使用查找表](caching-data-at-application-startup-cs/_static/image1.png)

<span data-ttu-id="d9299-143">**图 1**:`Languages`表是通过使用查找表`Patients`表</span><span class="sxs-lookup"><span data-stu-id="d9299-143">**Figure 1**: The `Languages` Table is a Lookup Table Used by the `Patients` Table</span></span>


<span data-ttu-id="d9299-144">编辑或创建新的患者的用户界面将包括允许语言中的记录所填充的下拉列表`Languages`表。</span><span class="sxs-lookup"><span data-stu-id="d9299-144">The user interface for editing or creating a new patient would include a drop-down list of allowable languages populated by the records in the `Languages` table.</span></span> <span data-ttu-id="d9299-145">不使用缓存功能，此接口是每次访问系统必须查询`Languages`表。</span><span class="sxs-lookup"><span data-stu-id="d9299-145">Without caching, each time this interface is visited the system must query the `Languages` table.</span></span> <span data-ttu-id="d9299-146">如果这是浪费和不必要由于查找表值极少更改过。</span><span class="sxs-lookup"><span data-stu-id="d9299-146">This is wasteful and unnecessary since lookup table values change very infrequently, if ever.</span></span>

<span data-ttu-id="d9299-147">我们无法缓存`Languages`数据使用相同的响应式加载方法，检查在前面的教程。</span><span class="sxs-lookup"><span data-stu-id="d9299-147">We could cache the `Languages` data using the same reactive loading techniques examined in the previous tutorials.</span></span> <span data-ttu-id="d9299-148">响应式加载，但是，使用静态查找表数据，不需要基于时间的到期。</span><span class="sxs-lookup"><span data-stu-id="d9299-148">Reactive loading, however, uses a time-based expiry, which is not needed for static lookup table data.</span></span> <span data-ttu-id="d9299-149">虽然缓存使用响应式加载会比无缓存更好，最好的方法是主动的查找表数据加载到应用程序启动时缓存。</span><span class="sxs-lookup"><span data-stu-id="d9299-149">While caching using reactive loading would be better than no caching at all, the best approach would be to proactively load the lookup table data into the cache at application startup.</span></span>

<span data-ttu-id="d9299-150">在本教程将探讨如何缓存查找表数据和其他静态信息。</span><span class="sxs-lookup"><span data-stu-id="d9299-150">In this tutorial we will look at how to cache lookup table data and other static information.</span></span>

## <a name="step-2-examining-the-different-ways-to-cache-data"></a><span data-ttu-id="d9299-151">第 2 步： 检查缓存数据的不同方式</span><span class="sxs-lookup"><span data-stu-id="d9299-151">Step 2: Examining the Different Ways to Cache Data</span></span>

<span data-ttu-id="d9299-152">可以使用多种方法的 ASP.NET 应用程序中以编程方式缓存信息。</span><span class="sxs-lookup"><span data-stu-id="d9299-152">Information can be programmatically cached in an ASP.NET application using a variety of approaches.</span></span> <span data-ttu-id="d9299-153">我们 ve 已经看到了如何在前面的教程中使用的数据缓存。</span><span class="sxs-lookup"><span data-stu-id="d9299-153">We ve already seen how to use the data cache in previous tutorials.</span></span> <span data-ttu-id="d9299-154">或者，可以以编程方式缓存对象使用*静态成员*或*应用程序状态*。</span><span class="sxs-lookup"><span data-stu-id="d9299-154">Alternatively, objects can be programmatically cached using *static members* or *application state*.</span></span>

<span data-ttu-id="d9299-155">在使用一个类，通常类必须首先实例化之前可以访问其成员。</span><span class="sxs-lookup"><span data-stu-id="d9299-155">When working with a class, typically the class must first be instantiated before its members can be accessed.</span></span> <span data-ttu-id="d9299-156">例如，为了调用一种方法从我们的业务逻辑层中的类之一，我们必须首先创建类的实例：</span><span class="sxs-lookup"><span data-stu-id="d9299-156">For example, in order to invoke a method from one of the classes in our Business Logic Layer, we must first create an instance of the class:</span></span>


[!code-csharp[Main](caching-data-at-application-startup-cs/samples/sample1.cs)]

<span data-ttu-id="d9299-157">我们可以调用之前*SomeMethod*或使用*SomeProperty*，我们必须先创建的类实例`new`关键字。</span><span class="sxs-lookup"><span data-stu-id="d9299-157">Before we can invoke *SomeMethod* or work with *SomeProperty*, we must first create an instance of the class using the `new` keyword.</span></span> <span data-ttu-id="d9299-158">*SomeMethod*并*SomeProperty*与特定实例相关联。</span><span class="sxs-lookup"><span data-stu-id="d9299-158">*SomeMethod* and *SomeProperty* are associated with a particular instance.</span></span> <span data-ttu-id="d9299-159">这些成员的生存期取决于其关联的对象的生存期。</span><span class="sxs-lookup"><span data-stu-id="d9299-159">The lifetime of these members is tied to the lifetime of their associated object.</span></span> <span data-ttu-id="d9299-160">*静态成员*，但是，将变量、 属性和方法之间共享*所有*类的实例，因此，具有长达类的生存期。</span><span class="sxs-lookup"><span data-stu-id="d9299-160">*Static members*, on the other hand, are variables, properties, and methods that are shared among *all* instances of the class and, consequently, have a lifetime as long as the class.</span></span> <span data-ttu-id="d9299-161">静态成员表示由关键字`static`。</span><span class="sxs-lookup"><span data-stu-id="d9299-161">Static members are denoted by the keyword `static`.</span></span>

<span data-ttu-id="d9299-162">除了静态成员，可以使用应用程序状态缓存数据。</span><span class="sxs-lookup"><span data-stu-id="d9299-162">In addition to static members, data can be cached using application state.</span></span> <span data-ttu-id="d9299-163">每个 ASP.NET 应用程序维护名称/值集合的所有用户和应用程序的页面之间共享该 s。</span><span class="sxs-lookup"><span data-stu-id="d9299-163">Each ASP.NET application maintains a name/value collection that s shared across all users and pages of the application.</span></span> <span data-ttu-id="d9299-164">可以使用访问此集合[`HttpContext`类](https://msdn.microsoft.com/library/system.web.httpcontext.aspx)s [ `Application`属性](https://msdn.microsoft.com/library/system.web.httpcontext.application.aspx)，并从一种 ASP.NET 页的代码隐藏类如下所示：</span><span class="sxs-lookup"><span data-stu-id="d9299-164">This collection can be accessed using the [`HttpContext` class](https://msdn.microsoft.com/library/system.web.httpcontext.aspx) s [`Application` property](https://msdn.microsoft.com/library/system.web.httpcontext.application.aspx), and used from an ASP.NET page s code-behind class like so:</span></span>


[!code-csharp[Main](caching-data-at-application-startup-cs/samples/sample2.cs)]

<span data-ttu-id="d9299-165">数据缓存的缓存数据，提供的基于时间和依赖关系的满、 缓存项优先级等机制提供了多更丰富的 API。</span><span class="sxs-lookup"><span data-stu-id="d9299-165">The data cache provides a much richer API for caching data, providing mechanisms for time- and dependency-based expiries, cache item priorities, and so forth.</span></span> <span data-ttu-id="d9299-166">使用静态成员和应用程序状态，此类功能必须由页面开发人员手动添加。</span><span class="sxs-lookup"><span data-stu-id="d9299-166">With static members and application state, such features must be manually added by the page developer.</span></span> <span data-ttu-id="d9299-167">当应用程序的生存期内缓存在应用程序启动的数据，但是，数据缓存的优点是毫无意义了。</span><span class="sxs-lookup"><span data-stu-id="d9299-167">When caching data at application startup for the lifetime of the application, however, the data cache s advantages are moot.</span></span> <span data-ttu-id="d9299-168">在本教程中我们将介绍用于缓存静态数据使用所有这三种技术的代码。</span><span class="sxs-lookup"><span data-stu-id="d9299-168">In this tutorial we'll look at code that uses all three techniques for caching static data.</span></span>

## <a name="step-3-caching-thesupplierstable-data"></a><span data-ttu-id="d9299-169">步骤 3： 缓存`Suppliers`表数据</span><span class="sxs-lookup"><span data-stu-id="d9299-169">Step 3: Caching the`Suppliers`Table Data</span></span>

<span data-ttu-id="d9299-170">Northwind 数据库表我们已实施方法与日期不包括任何传统的查找表。</span><span class="sxs-lookup"><span data-stu-id="d9299-170">The Northwind database tables we ve implemented to date do not include any traditional lookup tables.</span></span> <span data-ttu-id="d9299-171">实现四个 DataTables DAL 中其值为非静态的所有模型表。</span><span class="sxs-lookup"><span data-stu-id="d9299-171">The four DataTables implemented in our DAL all model tables whose values are non-static.</span></span> <span data-ttu-id="d9299-172">而不是花费时间来将一个新的 DataTable 添加到 DAL 的新类并向 BLL，方法为本教程只是让 s 伪装的`Suppliers`表的数据是静态的。</span><span class="sxs-lookup"><span data-stu-id="d9299-172">Rather than spending the time to add a new DataTable to the DAL and then a new class and methods to the BLL, for this tutorial let s just pretend that the `Suppliers` table s data is static.</span></span> <span data-ttu-id="d9299-173">因此，我们无法缓存此数据在应用程序启动。</span><span class="sxs-lookup"><span data-stu-id="d9299-173">Therefore, we could cache this data at application startup.</span></span>

<span data-ttu-id="d9299-174">若要开始，创建一个名为的新类`StaticCache.cs`在`CL`文件夹。</span><span class="sxs-lookup"><span data-stu-id="d9299-174">To start, create a new class named `StaticCache.cs` in the `CL` folder.</span></span>


![CL 文件夹中创建 StaticCache.cs 类](caching-data-at-application-startup-cs/_static/image2.png)

<span data-ttu-id="d9299-176">**图 2**： 创建`StaticCache.cs`类中`CL`文件夹</span><span class="sxs-lookup"><span data-stu-id="d9299-176">**Figure 2**: Create the `StaticCache.cs` Class in the `CL` Folder</span></span>


<span data-ttu-id="d9299-177">我们需要添加一个方法，在启动时将数据加载到合适的缓存存储区，以及从此缓存中返回数据的方法。</span><span class="sxs-lookup"><span data-stu-id="d9299-177">We need to add a method that loads the data at startup into the appropriate cache store, as well as methods that return data from this cache.</span></span>


[!code-csharp[Main](caching-data-at-application-startup-cs/samples/sample3.cs)]

<span data-ttu-id="d9299-178">上面的代码中使用静态成员变量`suppliers`，以保留的结果`SuppliersBLL`类 s`GetSuppliers()`方法，从调用`LoadStaticCache()`方法。</span><span class="sxs-lookup"><span data-stu-id="d9299-178">The above code uses a static member variable, `suppliers`, to hold the results from the `SuppliersBLL` class s `GetSuppliers()` method, which is called from the `LoadStaticCache()` method.</span></span> <span data-ttu-id="d9299-179">`LoadStaticCache()`方法应该在应用程序的启动期间被调用。</span><span class="sxs-lookup"><span data-stu-id="d9299-179">The `LoadStaticCache()` method is meant to be called during the application s start.</span></span> <span data-ttu-id="d9299-180">此数据加载在应用程序启动后，可以调用需要与供应商数据协同工作的任何页面`StaticCache`类的`GetSuppliers()`方法。</span><span class="sxs-lookup"><span data-stu-id="d9299-180">Once this data has been loaded at application startup, any page that needs to work with supplier data can call the `StaticCache` class s `GetSuppliers()` method.</span></span> <span data-ttu-id="d9299-181">因此，对数据库的调用以获取供应商只出现一次启动应用程序时。</span><span class="sxs-lookup"><span data-stu-id="d9299-181">Therefore, the call to the database to get the suppliers only happens once, at application start.</span></span>

<span data-ttu-id="d9299-182">而不是作为缓存存储区中使用的静态成员变量，我们也可以或者使用应用程序状态或数据缓存。</span><span class="sxs-lookup"><span data-stu-id="d9299-182">Rather than using a static member variable as the cache store, we could have alternatively used application state or the data cache.</span></span> <span data-ttu-id="d9299-183">下面的代码显示了进行重组以使用应用程序状态的类：</span><span class="sxs-lookup"><span data-stu-id="d9299-183">The following code shows the class retooled to use application state:</span></span>


[!code-csharp[Main](caching-data-at-application-startup-cs/samples/sample4.cs)]

<span data-ttu-id="d9299-184">在中`LoadStaticCache()`，供应商信息存储到程序变量*密钥*。</span><span class="sxs-lookup"><span data-stu-id="d9299-184">In `LoadStaticCache()`, the supplier information is stored to the application variable *key*.</span></span> <span data-ttu-id="d9299-185">它返回为相应的类型 (`Northwind.SuppliersDataTable`) 从`GetSuppliers()`。</span><span class="sxs-lookup"><span data-stu-id="d9299-185">It s returned as the appropriate type (`Northwind.SuppliersDataTable`) from `GetSuppliers()`.</span></span> <span data-ttu-id="d9299-186">虽然可以使用的 ASP.NET 页的代码隐藏类中访问应用程序状态`Application["key"]`，在我们必须使用的体系结构`HttpContext.Current.Application["key"]`以获取当前`HttpContext`。</span><span class="sxs-lookup"><span data-stu-id="d9299-186">While application state can be accessed in the code-behind classes of ASP.NET pages using `Application["key"]`, in the architecture we must use `HttpContext.Current.Application["key"]` in order to get the current `HttpContext`.</span></span>

<span data-ttu-id="d9299-187">同样，数据缓存可以用作缓存存储区中，如以下代码所示：</span><span class="sxs-lookup"><span data-stu-id="d9299-187">Likewise, the data cache can be used as a cache store, as the following code shows:</span></span>


[!code-csharp[Main](caching-data-at-application-startup-cs/samples/sample5.cs)]

<span data-ttu-id="d9299-188">若要将项添加到其任何基于时间的到期时间的数据缓存，请使用`System.Web.Caching.Cache.NoAbsoluteExpiration`和`System.Web.Caching.Cache.NoSlidingExpiration`作为输入参数的值。</span><span class="sxs-lookup"><span data-stu-id="d9299-188">To add an item to the data cache with no time-based expiry, use the `System.Web.Caching.Cache.NoAbsoluteExpiration` and `System.Web.Caching.Cache.NoSlidingExpiration` values as input parameters.</span></span> <span data-ttu-id="d9299-189">这一特定的数据缓存的重载`Insert`已选择的方法，以便我们可以指定*优先级*的缓存项。</span><span class="sxs-lookup"><span data-stu-id="d9299-189">This particular overload of the data cache s `Insert` method was selected so that we could specify the *priority* of the cache item.</span></span> <span data-ttu-id="d9299-190">优先级用于确定哪些项目清理从缓存中，当可用内存不足。</span><span class="sxs-lookup"><span data-stu-id="d9299-190">The priority is used to determine what items to scavenge from the cache when available memory runs low.</span></span> <span data-ttu-id="d9299-191">此处，我们使用优先级`NotRemovable`，这可确保此缓存项赢得 t 被清理。</span><span class="sxs-lookup"><span data-stu-id="d9299-191">Here we use the priority `NotRemovable`, which ensures that this cache item won t be scavenged.</span></span>

> [!NOTE]
> <span data-ttu-id="d9299-192">此教程的下载实现`StaticCache`类使用静态成员变量方法。</span><span class="sxs-lookup"><span data-stu-id="d9299-192">This tutorial s download implements the `StaticCache` class using the static member variable approach.</span></span> <span data-ttu-id="d9299-193">应用程序状态和数据缓存技术的代码位于类文件中的注释。</span><span class="sxs-lookup"><span data-stu-id="d9299-193">The code for the application state and data cache techniques is available in the comments in the class file.</span></span>


## <a name="step-4-executing-code-at-application-startup"></a><span data-ttu-id="d9299-194">步骤 4： 执行代码在应用程序启动</span><span class="sxs-lookup"><span data-stu-id="d9299-194">Step 4: Executing Code at Application Startup</span></span>

<span data-ttu-id="d9299-195">若要执行代码的 web 应用程序首次启动时，我们需要创建一个名为的特殊文件`Global.asax`。</span><span class="sxs-lookup"><span data-stu-id="d9299-195">To execute code when a web application first starts, we need to create a special file named `Global.asax`.</span></span> <span data-ttu-id="d9299-196">此文件可以包含的应用程序-，会话的事件处理程序和请求级事件，它是此处我们可以在其中添加每次应用程序启动时执行的代码。</span><span class="sxs-lookup"><span data-stu-id="d9299-196">This file can contain event handlers for application-, session-, and request-level events, and it is here where we can add code that will be executed whenever the application starts.</span></span>

<span data-ttu-id="d9299-197">添加`Global.asax`网站项目名称，在 Visual Studio 的解决方案资源管理器中右键单击并选择添加新项在 web 应用程序的根目录下的文件。</span><span class="sxs-lookup"><span data-stu-id="d9299-197">Add the `Global.asax` file to your web application s root directory by right-clicking on the website project name in Visual Studio s Solution Explorer and choosing Add New Item.</span></span> <span data-ttu-id="d9299-198">从添加新项对话框中，选择应用程序的全局类项类型，然后单击添加按钮。</span><span class="sxs-lookup"><span data-stu-id="d9299-198">From the Add New Item dialog box, select the Global Application Class item type and then click the Add button.</span></span>

> [!NOTE]
> <span data-ttu-id="d9299-199">如果已有`Global.asax`文件在项目中，不会在添加新项对话框中列出项类型在全局应用程序类。</span><span class="sxs-lookup"><span data-stu-id="d9299-199">If you already have a `Global.asax` file in your project, the Global Application Class item type will not be listed in the Add New Item dialog box.</span></span>


<span data-ttu-id="d9299-200">[![Global.asax 文件添加到 Web 应用程序的根目录](caching-data-at-application-startup-cs/_static/image4.png)](caching-data-at-application-startup-cs/_static/image3.png)</span><span class="sxs-lookup"><span data-stu-id="d9299-200">[![Add the Global.asax File to Your Web Application s Root Directory](caching-data-at-application-startup-cs/_static/image4.png)](caching-data-at-application-startup-cs/_static/image3.png)</span></span>

<span data-ttu-id="d9299-201">**图 3**： 添加`Global.asax`为 s 的 Web 应用程序根目录的文件 ([单击以查看实际尺寸的图像](caching-data-at-application-startup-cs/_static/image5.png))</span><span class="sxs-lookup"><span data-stu-id="d9299-201">**Figure 3**: Add the `Global.asax` File to Your Web Application s Root Directory ([Click to view full-size image](caching-data-at-application-startup-cs/_static/image5.png))</span></span>


<span data-ttu-id="d9299-202">默认值`Global.asax`文件模板包括在服务器端中的五种方法`<script>`标记：</span><span class="sxs-lookup"><span data-stu-id="d9299-202">The default `Global.asax` file template includes five methods within a server-side `<script>` tag:</span></span>

- <span data-ttu-id="d9299-203">**`Application_Start`** 执行 web 应用程序首次启动时</span><span class="sxs-lookup"><span data-stu-id="d9299-203">**`Application_Start`** executes when the web application first starts</span></span>
- <span data-ttu-id="d9299-204">**`Application_End`** 当应用程序关闭时运行</span><span class="sxs-lookup"><span data-stu-id="d9299-204">**`Application_End`** runs when the application is shutting down</span></span>
- <span data-ttu-id="d9299-205">**`Application_Error`** 每当未处理的异常到达应用程序执行</span><span class="sxs-lookup"><span data-stu-id="d9299-205">**`Application_Error`** executes whenever an unhandled exception reaches the application</span></span>
- <span data-ttu-id="d9299-206">**`Session_Start`** 执行时创建一个新会话</span><span class="sxs-lookup"><span data-stu-id="d9299-206">**`Session_Start`** executes when a new session is created</span></span>
- <span data-ttu-id="d9299-207">**`Session_End`** 在运行时的会话已过期或已放弃</span><span class="sxs-lookup"><span data-stu-id="d9299-207">**`Session_End`** runs when a session is expired or abandoned</span></span>

<span data-ttu-id="d9299-208">`Application_Start` S 应用程序生命周期内仅一次调用事件处理程序。</span><span class="sxs-lookup"><span data-stu-id="d9299-208">The `Application_Start` event handler is called only once during an application s life cycle.</span></span> <span data-ttu-id="d9299-209">在应用程序启动第一次 ASP.NET 资源请求从应用程序，并继续运行，直到重新启动该应用程序时，其可能会通过修改的内容`/Bin`文件夹中，修改`Global.asax`，修改在内容`App_Code`文件夹，或修改`Web.config`文件，其他原因。</span><span class="sxs-lookup"><span data-stu-id="d9299-209">The application starts the first time an ASP.NET resource is requested from the application and continues to run until the application is restarted, which can happen by modifying the contents of the `/Bin` folder, modifying `Global.asax`, modifying the contents in the `App_Code` folder, or modifying the `Web.config` file, among other causes.</span></span> <span data-ttu-id="d9299-210">请参阅[ASP.NET 应用程序生命周期概述](https://msdn.microsoft.com/library/ms178473.aspx)有关应用程序生命周期的更多详细讨论。</span><span class="sxs-lookup"><span data-stu-id="d9299-210">Refer to [ASP.NET Application Life Cycle Overview](https://msdn.microsoft.com/library/ms178473.aspx) for a more detailed discussion on the application life cycle.</span></span>

<span data-ttu-id="d9299-211">这些教程中我们只需将代码添加到`Application_Start`方法，因此，可随时删除。</span><span class="sxs-lookup"><span data-stu-id="d9299-211">For these tutorials we only need to add code to the `Application_Start` method, so feel free to remove the others.</span></span> <span data-ttu-id="d9299-212">在中`Application_Start`，只需调用`StaticCache`类的`LoadStaticCache()`方法，它将加载并缓存供应商信息：</span><span class="sxs-lookup"><span data-stu-id="d9299-212">In `Application_Start`, simply call the `StaticCache` class s `LoadStaticCache()` method, which will load and cache the supplier information:</span></span>


[!code-aspx[Main](caching-data-at-application-startup-cs/samples/sample6.aspx)]

<span data-ttu-id="d9299-213">该 s 都在这里就简单 ！</span><span class="sxs-lookup"><span data-stu-id="d9299-213">That s all there is to it!</span></span> <span data-ttu-id="d9299-214">在应用程序启动时，`LoadStaticCache()`方法将获取从 BLL，供应商信息，并将其存储在静态成员变量 (或任何缓存存储您最终会在中使用`StaticCache`类)。</span><span class="sxs-lookup"><span data-stu-id="d9299-214">At application startup, the `LoadStaticCache()` method will grab the supplier information from the BLL, and store it in a static member variable (or whatever cache store you ended up using in the `StaticCache` class).</span></span> <span data-ttu-id="d9299-215">若要验证此行为中, 设置断点`Application_Start`方法并运行应用程序。</span><span class="sxs-lookup"><span data-stu-id="d9299-215">To verify this behavior, set a breakpoint in the `Application_Start` method and run your application.</span></span> <span data-ttu-id="d9299-216">请注意应用程序启动时命中断点。</span><span class="sxs-lookup"><span data-stu-id="d9299-216">Note that the breakpoint is hit upon the application starting.</span></span> <span data-ttu-id="d9299-217">后续请求中，但是，不会导致`Application_Start`要执行的方法。</span><span class="sxs-lookup"><span data-stu-id="d9299-217">Subsequent requests, however, do not cause the `Application_Start` method to execute.</span></span>


<span data-ttu-id="d9299-218">[![使用验证 Application_Start 事件处理程序正在执行的断点](caching-data-at-application-startup-cs/_static/image7.png)](caching-data-at-application-startup-cs/_static/image6.png)</span><span class="sxs-lookup"><span data-stu-id="d9299-218">[![Use a Breakpoint to Verify that the Application_Start Event Handler is Being Executed](caching-data-at-application-startup-cs/_static/image7.png)](caching-data-at-application-startup-cs/_static/image6.png)</span></span>

<span data-ttu-id="d9299-219">**图 4**： 使用验证断点的`Application_Start`事件处理程序是正在执行 ([单击以查看实际尺寸的图像](caching-data-at-application-startup-cs/_static/image8.png))</span><span class="sxs-lookup"><span data-stu-id="d9299-219">**Figure 4**: Use a Breakpoint to Verify that the `Application_Start` Event Handler is Being Executed ([Click to view full-size image](caching-data-at-application-startup-cs/_static/image8.png))</span></span>


> [!NOTE]
> <span data-ttu-id="d9299-220">如果未达到`Application_Start`断点在首次开始调试时，这是因为你的应用程序已启动。</span><span class="sxs-lookup"><span data-stu-id="d9299-220">If you do not hit the `Application_Start` breakpoint when you first start debugging, it is because your application has already started.</span></span> <span data-ttu-id="d9299-221">强制应用程序通过修改重启你`Global.asax`或`Web.config`文件，然后重试。</span><span class="sxs-lookup"><span data-stu-id="d9299-221">Force the application to restart by modifying your `Global.asax` or `Web.config` files and then try again.</span></span> <span data-ttu-id="d9299-222">您可以只需添加 （或删除） 末尾的这些文件，以便快速重新启动该应用程序的一个空白行。</span><span class="sxs-lookup"><span data-stu-id="d9299-222">You can simply add (or remove) a blank line at the end of one of these files to quickly restart the application.</span></span>


## <a name="step-5-displaying-the-cached-data"></a><span data-ttu-id="d9299-223">步骤 5： 显示缓存的数据</span><span class="sxs-lookup"><span data-stu-id="d9299-223">Step 5: Displaying the Cached Data</span></span>

<span data-ttu-id="d9299-224">此时`StaticCache`类具有可通过访问的应用程序启动时缓存的供应商数据的版本及其`GetSuppliers()`方法。</span><span class="sxs-lookup"><span data-stu-id="d9299-224">At this point the `StaticCache` class has a version of the supplier data cached at application startup that can be accessed through its `GetSuppliers()` method.</span></span> <span data-ttu-id="d9299-225">若要使用此来自表示层的数据，我们可以使用对象数据源，或以编程方式调用`StaticCache`类的`GetSuppliers()`从一种 ASP.NET 页的代码隐藏类的方法。</span><span class="sxs-lookup"><span data-stu-id="d9299-225">To work with this data from the Presentation Layer, we can use an ObjectDataSource or programmatically invoke the `StaticCache` class s `GetSuppliers()` method from an ASP.NET page s code-behind class.</span></span> <span data-ttu-id="d9299-226">让我们来看看使用 ObjectDataSource 和 GridView 控件来显示缓存供应商信息。</span><span class="sxs-lookup"><span data-stu-id="d9299-226">Let s look at using the ObjectDataSource and GridView controls to display the cached supplier information.</span></span>

<span data-ttu-id="d9299-227">首先打开`AtApplicationStartup.aspx`页中`Caching`文件夹。</span><span class="sxs-lookup"><span data-stu-id="d9299-227">Start by opening the `AtApplicationStartup.aspx` page in the `Caching` folder.</span></span> <span data-ttu-id="d9299-228">将 GridView 从工具箱拖到设计器中，设置其`ID`属性设置为`Suppliers`。</span><span class="sxs-lookup"><span data-stu-id="d9299-228">Drag a GridView from the Toolbox onto the designer, setting its `ID` property to `Suppliers`.</span></span> <span data-ttu-id="d9299-229">接下来，从 GridView s 智能标记选择创建名为新 ObjectDataSource `SuppliersCachedDataSource`。</span><span class="sxs-lookup"><span data-stu-id="d9299-229">Next, from the GridView s smart tag choose to create a new ObjectDataSource named `SuppliersCachedDataSource`.</span></span> <span data-ttu-id="d9299-230">配置要使用 ObjectDataSource`StaticCache`类的`GetSuppliers()`方法。</span><span class="sxs-lookup"><span data-stu-id="d9299-230">Configure the ObjectDataSource to use the `StaticCache` class s `GetSuppliers()` method.</span></span>


<span data-ttu-id="d9299-231">[![配置对象数据源以使用 StaticCache 类](caching-data-at-application-startup-cs/_static/image10.png)](caching-data-at-application-startup-cs/_static/image9.png)</span><span class="sxs-lookup"><span data-stu-id="d9299-231">[![Configure the ObjectDataSource to use the StaticCache Class](caching-data-at-application-startup-cs/_static/image10.png)](caching-data-at-application-startup-cs/_static/image9.png)</span></span>

<span data-ttu-id="d9299-232">**图 5**： 配置要使用 ObjectDataSource`StaticCache`类 ([单击以查看实际尺寸的图像](caching-data-at-application-startup-cs/_static/image11.png))</span><span class="sxs-lookup"><span data-stu-id="d9299-232">**Figure 5**: Configure the ObjectDataSource to use the `StaticCache` Class ([Click to view full-size image](caching-data-at-application-startup-cs/_static/image11.png))</span></span>


<span data-ttu-id="d9299-233">[![使用 GetSuppliers() 方法来检索缓存的供应商数据](caching-data-at-application-startup-cs/_static/image13.png)](caching-data-at-application-startup-cs/_static/image12.png)</span><span class="sxs-lookup"><span data-stu-id="d9299-233">[![Use the GetSuppliers() Method to Retrieve the Cached Supplier Data](caching-data-at-application-startup-cs/_static/image13.png)](caching-data-at-application-startup-cs/_static/image12.png)</span></span>

<span data-ttu-id="d9299-234">**图 6**： 使用`GetSuppliers()`方法来检索缓存供应商数据 ([单击以查看实际尺寸的图像](caching-data-at-application-startup-cs/_static/image14.png))</span><span class="sxs-lookup"><span data-stu-id="d9299-234">**Figure 6**: Use the `GetSuppliers()` Method to Retrieve the Cached Supplier Data ([Click to view full-size image](caching-data-at-application-startup-cs/_static/image14.png))</span></span>


<span data-ttu-id="d9299-235">完成向导后，Visual Studio 将自动添加 BoundFields 中的数据字段的每个`SuppliersDataTable`。</span><span class="sxs-lookup"><span data-stu-id="d9299-235">After completing the wizard, Visual Studio will automatically add BoundFields for each of the data fields in `SuppliersDataTable`.</span></span> <span data-ttu-id="d9299-236">在 GridView 和 ObjectDataSource s 声明性标记应类似于下面所示：</span><span class="sxs-lookup"><span data-stu-id="d9299-236">Your GridView and ObjectDataSource s declarative markup should look similar to the following:</span></span>


[!code-aspx[Main](caching-data-at-application-startup-cs/samples/sample7.aspx)]

<span data-ttu-id="d9299-237">图 7 显示时的浏览器查看的页。</span><span class="sxs-lookup"><span data-stu-id="d9299-237">Figure 7 shows the page when viewed through a browser.</span></span> <span data-ttu-id="d9299-238">输出是相同我们必须读取从 BLL 的数据`SuppliersBLL`类，但是使用`StaticCache`类返回作为缓存在应用程序启动时的供应商数据。</span><span class="sxs-lookup"><span data-stu-id="d9299-238">The output is the same had we pulled the data from the BLL s `SuppliersBLL` class, but using the `StaticCache` class returns the supplier data as cached at application startup.</span></span> <span data-ttu-id="d9299-239">可以在中设置断点`StaticCache`类的`GetSuppliers()`方法以验证此行为。</span><span class="sxs-lookup"><span data-stu-id="d9299-239">You can set breakpoints in the `StaticCache` class s `GetSuppliers()` method to verify this behavior.</span></span>


<span data-ttu-id="d9299-240">[![在 GridView 中显示缓存供应商数据](caching-data-at-application-startup-cs/_static/image16.png)](caching-data-at-application-startup-cs/_static/image15.png)</span><span class="sxs-lookup"><span data-stu-id="d9299-240">[![The Cached Supplier Data is Displayed in a GridView](caching-data-at-application-startup-cs/_static/image16.png)](caching-data-at-application-startup-cs/_static/image15.png)</span></span>

<span data-ttu-id="d9299-241">**图 7**： 在 GridView 中显示缓存供应商数据 ([单击以查看实际尺寸的图像](caching-data-at-application-startup-cs/_static/image17.png))</span><span class="sxs-lookup"><span data-stu-id="d9299-241">**Figure 7**: The Cached Supplier Data is Displayed in a GridView ([Click to view full-size image](caching-data-at-application-startup-cs/_static/image17.png))</span></span>


## <a name="summary"></a><span data-ttu-id="d9299-242">总结</span><span class="sxs-lookup"><span data-stu-id="d9299-242">Summary</span></span>

<span data-ttu-id="d9299-243">大多数每个数据模型包含大量的静态数据，通常在查找表的形式来实现。</span><span class="sxs-lookup"><span data-stu-id="d9299-243">Most every data model contains a fair amount of static data, usually implemented in the form of lookup tables.</span></span> <span data-ttu-id="d9299-244">此信息是静态的因为这里的无需不断地访问数据库每次需要显示此信息。</span><span class="sxs-lookup"><span data-stu-id="d9299-244">Since this information is static, there s no reason to continually access the database each time this information needs to be displayed.</span></span> <span data-ttu-id="d9299-245">此外，由于其静态特性，缓存数据时那里 s 到期时间不需要。</span><span class="sxs-lookup"><span data-stu-id="d9299-245">Furthermore, due to its static nature, when caching the data there s no need for an expiry.</span></span> <span data-ttu-id="d9299-246">在本教程中我们已了解如何执行此类数据并将其缓存中的数据缓存，应用程序状态，并通过静态成员变量。</span><span class="sxs-lookup"><span data-stu-id="d9299-246">In this tutorial we saw how to take such data and cache it in the data cache, application state, and through a static member variable.</span></span> <span data-ttu-id="d9299-247">此信息缓存在应用程序启动，并保留在整个应用程序 s 生存期内缓存。</span><span class="sxs-lookup"><span data-stu-id="d9299-247">This information is cached at application startup and remains in the cache throughout the application s lifetime.</span></span>

<span data-ttu-id="d9299-248">在本教程和过去的两个，我们已介绍了应用程序 s 生命周期的持续时间的缓存数据，以及使用基于时间的满。</span><span class="sxs-lookup"><span data-stu-id="d9299-248">In this tutorial and the past two, we ve looked at caching data for the duration of the application s lifetime as well as using time-based expiries.</span></span> <span data-ttu-id="d9299-249">当缓存数据库数据，不过，基于时间的过期可能不太理想。</span><span class="sxs-lookup"><span data-stu-id="d9299-249">When caching database data, though, a time-based expiry may be less than ideal.</span></span> <span data-ttu-id="d9299-250">而不是定期刷新的缓存，则会将仅修改基础数据库数据时逐出缓存的项最佳选择。</span><span class="sxs-lookup"><span data-stu-id="d9299-250">Rather than periodically flushing the cache, it would be optimal to only evict the cached item when the underlying database data is modified.</span></span> <span data-ttu-id="d9299-251">可以通过 SQL 缓存依赖关系，其中我们将介绍我们下一教程中使用这种理想状况。</span><span class="sxs-lookup"><span data-stu-id="d9299-251">This ideal is possible through the use of SQL cache dependencies, which we'll examine in our next tutorial.</span></span>

<span data-ttu-id="d9299-252">快乐编程 ！</span><span class="sxs-lookup"><span data-stu-id="d9299-252">Happy Programming!</span></span>

## <a name="about-the-author"></a><span data-ttu-id="d9299-253">关于作者</span><span class="sxs-lookup"><span data-stu-id="d9299-253">About the Author</span></span>

<span data-ttu-id="d9299-254">[Scott Mitchell](http://www.4guysfromrolla.com/ScottMitchell.shtml)的七个部 asp/ASP.NET 书籍并创办了作者[4GuysFromRolla.com](http://www.4guysfromrolla.com)，自 1998 年以来一直致力于 Microsoft Web 技术。</span><span class="sxs-lookup"><span data-stu-id="d9299-254">[Scott Mitchell](http://www.4guysfromrolla.com/ScottMitchell.shtml), author of seven ASP/ASP.NET books and founder of [4GuysFromRolla.com](http://www.4guysfromrolla.com), has been working with Microsoft Web technologies since 1998.</span></span> <span data-ttu-id="d9299-255">Scott 是独立的顾问、 培训师和编写器。</span><span class="sxs-lookup"><span data-stu-id="d9299-255">Scott works as an independent consultant, trainer, and writer.</span></span> <span data-ttu-id="d9299-256">他最新著作是[ *Sams Teach 自己 ASP.NET 2.0 24 小时内*](https://www.amazon.com/exec/obidos/ASIN/0672327384/4guysfromrollaco)。</span><span class="sxs-lookup"><span data-stu-id="d9299-256">His latest book is [*Sams Teach Yourself ASP.NET 2.0 in 24 Hours*](https://www.amazon.com/exec/obidos/ASIN/0672327384/4guysfromrollaco).</span></span> <span data-ttu-id="d9299-257">他可以到达[ mitchell@4GuysFromRolla.com。](mailto:mitchell@4GuysFromRolla.com)</span><span class="sxs-lookup"><span data-stu-id="d9299-257">He can be reached at [mitchell@4GuysFromRolla.com.](mailto:mitchell@4GuysFromRolla.com)</span></span> <span data-ttu-id="d9299-258">或通过他的博客，其中，请参阅[ http://ScottOnWriting.NET ](http://ScottOnWriting.NET)。</span><span class="sxs-lookup"><span data-stu-id="d9299-258">or via his blog, which can be found at [http://ScottOnWriting.NET](http://ScottOnWriting.NET).</span></span>

## <a name="special-thanks-to"></a><span data-ttu-id="d9299-259">特别感谢</span><span class="sxs-lookup"><span data-stu-id="d9299-259">Special Thanks To</span></span>

<span data-ttu-id="d9299-260">很多有用的审阅者已评审本系列教程。</span><span class="sxs-lookup"><span data-stu-id="d9299-260">This tutorial series was reviewed by many helpful reviewers.</span></span> <span data-ttu-id="d9299-261">本教程中的潜在顾客审阅者是 Teresa Murphy 和 Zack Jones。</span><span class="sxs-lookup"><span data-stu-id="d9299-261">Lead reviewers for this tutorial were Teresa Murphy and Zack Jones.</span></span> <span data-ttu-id="d9299-262">是否有兴趣查看我即将推出的 MSDN 文章？</span><span class="sxs-lookup"><span data-stu-id="d9299-262">Interested in reviewing my upcoming MSDN articles?</span></span> <span data-ttu-id="d9299-263">如果是这样，给我在行[ mitchell@4GuysFromRolla.com。](mailto:mitchell@4GuysFromRolla.com)</span><span class="sxs-lookup"><span data-stu-id="d9299-263">If so, drop me a line at [mitchell@4GuysFromRolla.com.](mailto:mitchell@4GuysFromRolla.com)</span></span>

> [!div class="step-by-step"]
> <span data-ttu-id="d9299-264">[上一页](caching-data-in-the-architecture-cs.md)
> [下一页](using-sql-cache-dependencies-cs.md)</span><span class="sxs-lookup"><span data-stu-id="d9299-264">[Previous](caching-data-in-the-architecture-cs.md)
[Next](using-sql-cache-dependencies-cs.md)</span></span>
