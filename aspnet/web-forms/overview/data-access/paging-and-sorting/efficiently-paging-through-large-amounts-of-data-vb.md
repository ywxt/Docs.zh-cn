---
uid: web-forms/overview/data-access/paging-and-sorting/efficiently-paging-through-large-amounts-of-data-vb
title: 通过大量的数据 (VB) 有效分页 |Microsoft Docs
author: rick-anderson
description: 使用大量的数据，作为其基础数据源控件 retriev 时，数据呈现控件的默认分页选项是不合适...
ms.author: riande
ms.date: 08/15/2006
ms.assetid: 3e20e64a-8808-4b49-88d6-014e2629d56f
msc.legacyurl: /web-forms/overview/data-access/paging-and-sorting/efficiently-paging-through-large-amounts-of-data-vb
msc.type: authoredcontent
ms.openlocfilehash: 5870b9ac2af7d9df927edd8230334dee4885c6a1
ms.sourcegitcommit: 45ac74e400f9f2b7dbded66297730f6f14a4eb25
ms.translationtype: MT
ms.contentlocale: zh-CN
ms.lasthandoff: 08/16/2018
ms.locfileid: "41833130"
---
<a name="efficiently-paging-through-large-amounts-of-data-vb"></a><span data-ttu-id="95430-103">有效分页通过大量数据 (VB)</span><span class="sxs-lookup"><span data-stu-id="95430-103">Efficiently Paging Through Large Amounts of Data (VB)</span></span>
====================
<span data-ttu-id="95430-104">通过[Scott Mitchell](https://twitter.com/ScottOnWriting)</span><span class="sxs-lookup"><span data-stu-id="95430-104">by [Scott Mitchell](https://twitter.com/ScottOnWriting)</span></span>

<span data-ttu-id="95430-105">[下载示例应用程序](http://download.microsoft.com/download/9/c/1/9c1d03ee-29ba-4d58-aa1a-f201dcc822ea/ASPNET_Data_Tutorial_25_VB.exe)或[下载 PDF](efficiently-paging-through-large-amounts-of-data-vb/_static/datatutorial25vb1.pdf)</span><span class="sxs-lookup"><span data-stu-id="95430-105">[Download Sample App](http://download.microsoft.com/download/9/c/1/9c1d03ee-29ba-4d58-aa1a-f201dcc822ea/ASPNET_Data_Tutorial_25_VB.exe) or [Download PDF](efficiently-paging-through-large-amounts-of-data-vb/_static/datatutorial25vb1.pdf)</span></span>

> <span data-ttu-id="95430-106">默认分页选项的数据呈现控件是不合适时使用的大量数据，当其基础数据源控件中检索所有记录，即使显示数据的子集。</span><span class="sxs-lookup"><span data-stu-id="95430-106">The default paging option of a data presentation control is unsuitable when working with large amounts of data, as its underlying data source control retrieves all records, even though only a subset of data is displayed.</span></span> <span data-ttu-id="95430-107">在这种情况下，我们必须将与自定义分页。</span><span class="sxs-lookup"><span data-stu-id="95430-107">In such circumstances, we must turn to custom paging.</span></span>


## <a name="introduction"></a><span data-ttu-id="95430-108">介绍</span><span class="sxs-lookup"><span data-stu-id="95430-108">Introduction</span></span>

<span data-ttu-id="95430-109">如我们在前面的教程中所述，可以通过两种方式之一中实现分页：</span><span class="sxs-lookup"><span data-stu-id="95430-109">As we discussed in the preceding tutorial, paging can be implemented in one of two ways:</span></span>

- <span data-ttu-id="95430-110">**默认的分页**可以通过只需选中启用分页选项中的数据 Web 控件 s 智能标记; 但是，只要查看的数据页，ObjectDataSource 检索*所有*的记录，即使但在页中显示它们的子集</span><span class="sxs-lookup"><span data-stu-id="95430-110">**Default Paging** can be implemented by simply checking the Enable Paging option in the data Web control s smart tag; however, whenever viewing a page of data, the ObjectDataSource retrieves *all* of the records, even though only a subset of them are displayed in the page</span></span>
- <span data-ttu-id="95430-111">**自定义分页**提高了默认通过从需要为所请求的用户数据的特定页显示的数据库中检索仅这些记录分页但是，自定义分页涉及更多工作才能实现比默认的分页</span><span class="sxs-lookup"><span data-stu-id="95430-111">**Custom Paging** improves the performance of default paging by retrieving only those records from the database that need to be displayed for the particular page of data requested by the user; however, custom paging involves a bit more effort to implement than default paging</span></span>

<span data-ttu-id="95430-112">由于实现只需检查一个复选框，并重新容易完成 ！</span><span class="sxs-lookup"><span data-stu-id="95430-112">Due to the ease of implementation just check a checkbox and you re done!</span></span> <span data-ttu-id="95430-113">默认分页是一个不错的选择。</span><span class="sxs-lookup"><span data-stu-id="95430-113">default paging is an attractive option.</span></span> <span data-ttu-id="95430-114">其 na ve 方法中检索所有记录，但它并不可信的选择时非常与许多并发用户进行分页的数据或站点足够大的量。</span><span class="sxs-lookup"><span data-stu-id="95430-114">Its na�ve approach in retrieving all of the records, though, makes it an implausible choice when paging through sufficiently large amounts of data or for sites with many concurrent users.</span></span> <span data-ttu-id="95430-115">在这种情况下，我们必须将自定义分页才能提供响应的系统。</span><span class="sxs-lookup"><span data-stu-id="95430-115">In such circumstances, we must turn to custom paging in order to provide a responsive system.</span></span>

<span data-ttu-id="95430-116">自定义分页的挑战能够编写返回精确的所需的特定数据页的记录集的查询。</span><span class="sxs-lookup"><span data-stu-id="95430-116">The challenge of custom paging is being able to write a query that returns the precise set of records needed for a particular page of data.</span></span> <span data-ttu-id="95430-117">幸运的是，Microsoft SQL Server 2005 提供了一个新的关键字为排名结果，这使我们能够编写可以高效地检索记录的正确子集的查询。</span><span class="sxs-lookup"><span data-stu-id="95430-117">Fortunately, Microsoft SQL Server 2005 provides a new keyword for ranking results, which enables us to write a query that can efficiently retrieve the proper subset of records.</span></span> <span data-ttu-id="95430-118">在本教程中我们将了解如何使用此新的 SQL Server 2005 关键字 GridView 控件中实现自定义分页。</span><span class="sxs-lookup"><span data-stu-id="95430-118">In this tutorial we'll see how to use this new SQL Server 2005 keyword to implement custom paging in a GridView control.</span></span> <span data-ttu-id="95430-119">自定义分页的用户界面是相同的默认分页，单步执行从一个页面到下一步使用自定义分页可以比默认的分页是几个数量级。</span><span class="sxs-lookup"><span data-stu-id="95430-119">While the user interface for custom paging is identical to that for default paging, stepping from one page to the next using custom paging can be several orders of magnitude faster than default paging.</span></span>

> [!NOTE]
> <span data-ttu-id="95430-120">由自定义分页表现出的确切的性能提升取决于正在通过用寻呼发送的记录和数据库服务器施加的负载的总数。</span><span class="sxs-lookup"><span data-stu-id="95430-120">The exact performance gain exhibited by custom paging depends on the total number of records being paged through and the load being placed on the database server.</span></span> <span data-ttu-id="95430-121">在本教程末尾我们将介绍某些展示通过自定义分页而获得的性能优势的粗略度量值。</span><span class="sxs-lookup"><span data-stu-id="95430-121">At the end of this tutorial we'll look at some rough metrics that showcase the benefits in performance obtained through custom paging.</span></span>


## <a name="step-1-understanding-the-custom-paging-process"></a><span data-ttu-id="95430-122">步骤 1： 了解自定义分页过程</span><span class="sxs-lookup"><span data-stu-id="95430-122">Step 1: Understanding the Custom Paging Process</span></span>

<span data-ttu-id="95430-123">时分页浏览数据，在页面中显示的精确记录，取决于所请求的数据的页和每页显示的记录数。</span><span class="sxs-lookup"><span data-stu-id="95430-123">When paging through data, the precise records displayed in a page depend upon the page of data being requested and the number of records displayed per page.</span></span> <span data-ttu-id="95430-124">例如，假设我们想要通过 81 产品页上显示每页 10 种产品。</span><span class="sxs-lookup"><span data-stu-id="95430-124">For example, imagine that we wanted to page through the 81 products, displaying 10 products per page.</span></span> <span data-ttu-id="95430-125">查看第一个页面时，我们 d 希望产品 1 到 10;查看第二页时 d 我们感兴趣的产品 11 到 20，依次类推。</span><span class="sxs-lookup"><span data-stu-id="95430-125">When viewing the first page, we d want products 1 through 10; when viewing the second page we d be interested in products 11 through 20, and so on.</span></span>

<span data-ttu-id="95430-126">有三个变量指示需要检索的记录和分页界面的呈现方式的：</span><span class="sxs-lookup"><span data-stu-id="95430-126">There are three variables that dictate what records need to be retrieved and how the paging interface should be rendered:</span></span>

- <span data-ttu-id="95430-127">**起始行索引**要显示的数据页中的第一行的索引，通过乘以记录每页显示的页索引并添加一个计算该索引可以。</span><span class="sxs-lookup"><span data-stu-id="95430-127">**Start Row Index** the index of the first row in the page of data to display; this index can be calculated by multiplying the page index by the records to display per page and adding one.</span></span> <span data-ttu-id="95430-128">例如，当分页浏览记录 10 次，第一页 （页索引为 0），开始的行索引为 0 \* 10 + 1 或 1; 第二页 （页索引为 1），开始的行索引为 1 \* 10 + 1或 11。</span><span class="sxs-lookup"><span data-stu-id="95430-128">For example, when paging through records 10 at a time, for the first page (whose page index is 0), the Start Row Index is 0 \* 10 + 1, or 1; for the second page (whose page index is 1), the Start Row Index is 1 \* 10 + 1, or 11.</span></span>
- <span data-ttu-id="95430-129">**最大行数**的最大可显示每页的记录数。</span><span class="sxs-lookup"><span data-stu-id="95430-129">**Maximum Rows** the maximum number of records to display per page.</span></span> <span data-ttu-id="95430-130">此变量称为最大行数，因为过去页有可能是更少的页大小比返回的记录。</span><span class="sxs-lookup"><span data-stu-id="95430-130">This variable is referred to as maximum rows since for the last page there may be fewer records returned than the page size.</span></span> <span data-ttu-id="95430-131">例如，通过每个页面的 81 产品 10 记录分页，当第九个和最后一页将具有只是一条记录。</span><span class="sxs-lookup"><span data-stu-id="95430-131">For example, when paging through the 81 products 10 records per page, the ninth and final page will have just one record.</span></span> <span data-ttu-id="95430-132">但是，任何页上，将不显示比最大行数的值的更多记录。</span><span class="sxs-lookup"><span data-stu-id="95430-132">No page, though, will show more records than the Maximum Rows value.</span></span>
- <span data-ttu-id="95430-133">**总记录计数**正在通过用寻呼发送的记录总数。</span><span class="sxs-lookup"><span data-stu-id="95430-133">**Total Record Count** the total number of records being paged through.</span></span> <span data-ttu-id="95430-134">确定要检索的某一给定页的记录所需的该变量并不是 t，尽管它 does 规定的分页界面。</span><span class="sxs-lookup"><span data-stu-id="95430-134">While this variable isn t needed to determine what records to retrieve for a given page, it does dictate the paging interface.</span></span> <span data-ttu-id="95430-135">例如，如果有 81 正在通过换种产品，分页界面知道在分页用户界面中显示九个页码。</span><span class="sxs-lookup"><span data-stu-id="95430-135">For example, if there are 81 products being paged through, the paging interface knows to display nine page numbers in the paging UI.</span></span>

<span data-ttu-id="95430-136">使用默认分页开始的行索引将计算为产品的页索引和页大小加 1，而最大行数是只是页面大小。</span><span class="sxs-lookup"><span data-stu-id="95430-136">With default paging, the Start Row Index is computed as the product of the page index and the page size plus one, whereas the Maximum Rows is simply the page size.</span></span> <span data-ttu-id="95430-137">由于默认的分页检索所有从记录是已知数据库呈现任何数据页中，每个行的索引时，从而使移动到一个简单的任务的开始行索引行。</span><span class="sxs-lookup"><span data-stu-id="95430-137">Since default paging retrieves all of the records from the database when rendering any page of data, the index for each row is known, thereby making moving to Start Row Index row a trivial task.</span></span> <span data-ttu-id="95430-138">此外，总记录计数是易于使用，因为它 s 只需在 DataTable （或任何对象用于存储数据库结果） 中的记录数。</span><span class="sxs-lookup"><span data-stu-id="95430-138">Moreover, the Total Record Count is readily available, as it s simply the number of records in the DataTable (or whatever object is being used to hold the database results).</span></span>

<span data-ttu-id="95430-139">给定的起始行索引和最大行数的变量，自定义分页实现必须仅返回后的起始处开始的行索引和最多记录的最大行数的记录的精确的子集。</span><span class="sxs-lookup"><span data-stu-id="95430-139">Given the Start Row Index and Maximum Rows variables, a custom paging implementation must only return the precise subset of records starting at the Start Row Index and up to Maximum Rows number of records after that.</span></span> <span data-ttu-id="95430-140">自定义分页提供了两个质询：</span><span class="sxs-lookup"><span data-stu-id="95430-140">Custom paging provides two challenges:</span></span>

- <span data-ttu-id="95430-141">我们必须能够有效地将行索引，以便我们可以开始返回指定的开始行索引处的记录通过正在分页的全部数据中的每一行与相关联</span><span class="sxs-lookup"><span data-stu-id="95430-141">We must be able to efficiently associate a row index with each row in the entire data being paged through so that we can start returning records at the specified Start Row Index</span></span>
- <span data-ttu-id="95430-142">我们需要提供正在通过用寻呼发送的记录总数</span><span class="sxs-lookup"><span data-stu-id="95430-142">We need to provide the total number of records being paged through</span></span>

<span data-ttu-id="95430-143">在接下来两个步骤中，我们将检查这些两个质询响应所需的 SQL 脚本。</span><span class="sxs-lookup"><span data-stu-id="95430-143">In the next two steps we'll examine the SQL script needed to respond to these two challenges.</span></span> <span data-ttu-id="95430-144">除了 SQL 脚本，我们还需要在 DAL 和 BLL 中实现方法。</span><span class="sxs-lookup"><span data-stu-id="95430-144">In addition to the SQL script, we'll also need to implement methods in the DAL and BLL.</span></span>

## <a name="step-2-returning-the-total-number-of-records-being-paged-through"></a><span data-ttu-id="95430-145">步骤 2： 返回正在通过用寻呼发送的记录总数</span><span class="sxs-lookup"><span data-stu-id="95430-145">Step 2: Returning the Total Number of Records Being Paged Through</span></span>

<span data-ttu-id="95430-146">我们说明如何检索精确子集的记录所显示的页面之前，让 s 首先看一下如何返回正在通过用寻呼发送的记录总数。</span><span class="sxs-lookup"><span data-stu-id="95430-146">Before we examine how to retrieve the precise subset of records for the page being displayed, let s first look at how to return the total number of records being paged through.</span></span> <span data-ttu-id="95430-147">为了正确配置的分页用户界面时需要此信息。</span><span class="sxs-lookup"><span data-stu-id="95430-147">This information is needed in order to properly configure the paging user interface.</span></span> <span data-ttu-id="95430-148">可以通过使用获取特定的 SQL 查询返回的记录总数[`COUNT`聚合函数](https://msdn.microsoft.com/library/ms175997.aspx)。</span><span class="sxs-lookup"><span data-stu-id="95430-148">The total number of records returned by a particular SQL query can be obtained by using the [`COUNT` aggregate function](https://msdn.microsoft.com/library/ms175997.aspx).</span></span> <span data-ttu-id="95430-149">例如，若要确定中的记录总数`Products`表中，我们可以使用以下查询：</span><span class="sxs-lookup"><span data-stu-id="95430-149">For example, to determine the total number of records in the `Products` table, we can use the following query:</span></span>


[!code-sql[Main](efficiently-paging-through-large-amounts-of-data-vb/samples/sample1.sql)]

<span data-ttu-id="95430-150">让我们来添加方法以返回此信息我们 DAL。</span><span class="sxs-lookup"><span data-stu-id="95430-150">Let s add a method to our DAL that returns this information.</span></span> <span data-ttu-id="95430-151">具体而言，我们将创建一个名为 DAL 方法`TotalNumberOfProducts()`，可执行`SELECT`如上所示的语句。</span><span class="sxs-lookup"><span data-stu-id="95430-151">In particular, we'll create a DAL method called `TotalNumberOfProducts()` that executes the `SELECT` statement shown above.</span></span>

<span data-ttu-id="95430-152">首先打开`Northwind.xsd`中的类型化数据集文件`App_Code/DAL`文件夹。</span><span class="sxs-lookup"><span data-stu-id="95430-152">Start by opening the `Northwind.xsd` Typed DataSet file in the `App_Code/DAL` folder.</span></span> <span data-ttu-id="95430-153">接下来，右键单击`ProductsTableAdapter`在设计器中，然后选择添加查询。</span><span class="sxs-lookup"><span data-stu-id="95430-153">Next, right-click on the `ProductsTableAdapter` in the Designer and choose Add Query.</span></span> <span data-ttu-id="95430-154">正如我们已看到在上一教程中，这将使我们能够将新方法添加到 DAL，调用时，将执行特定 SQL 语句或存储的过程。</span><span class="sxs-lookup"><span data-stu-id="95430-154">As we ve seen in previous tutorials, this will allow us to add a new method to the DAL that, when invoked, will execute a particular SQL statement or stored procedure.</span></span> <span data-ttu-id="95430-155">与我们在前面的教程的 TableAdapter 方法，在此选择使用临时 SQL 语句。</span><span class="sxs-lookup"><span data-stu-id="95430-155">As with our TableAdapter methods in previous tutorials, for this one opt to use an ad-hoc SQL statement.</span></span>


![使用临时 SQL 语句](efficiently-paging-through-large-amounts-of-data-vb/_static/image1.png)

<span data-ttu-id="95430-157">**图 1**： 使用临时 SQL 语句</span><span class="sxs-lookup"><span data-stu-id="95430-157">**Figure 1**: Use an Ad-Hoc SQL Statement</span></span>


<span data-ttu-id="95430-158">在下一个屏幕中，我们可以指定哪些类型的查询来创建。</span><span class="sxs-lookup"><span data-stu-id="95430-158">On the next screen we can specify what type of query to create.</span></span> <span data-ttu-id="95430-159">由于此查询将返回单个标量值中的记录总数`Products`表选择`SELECT`表示返回单个值选项。</span><span class="sxs-lookup"><span data-stu-id="95430-159">Since this query will return a single, scalar value the total number of records in the `Products` table choose the `SELECT` which returns a singe value option.</span></span>


![配置要使用返回单个值的 SELECT 语句的查询](efficiently-paging-through-large-amounts-of-data-vb/_static/image2.png)

<span data-ttu-id="95430-161">**图 2**： 配置要使用返回单个值的 SELECT 语句的查询</span><span class="sxs-lookup"><span data-stu-id="95430-161">**Figure 2**: Configure the Query to Use a SELECT Statement that Returns a Single Value</span></span>


<span data-ttu-id="95430-162">指示要使用的查询类型之后, 我们接下来必须指定的查询。</span><span class="sxs-lookup"><span data-stu-id="95430-162">After indicating the type of query to use, we must next specify the query.</span></span>


![使用从产品查询选择 COUNT(\*)](efficiently-paging-through-large-amounts-of-data-vb/_static/image3.png)

<span data-ttu-id="95430-164">**图 3**： 使用选择的计数 (\*) FROM 产品查询</span><span class="sxs-lookup"><span data-stu-id="95430-164">**Figure 3**: Use the SELECT COUNT(\*) FROM Products Query</span></span>


<span data-ttu-id="95430-165">最后，指定该方法的名称。</span><span class="sxs-lookup"><span data-stu-id="95430-165">Finally, specify the name for the method.</span></span> <span data-ttu-id="95430-166">使用前面提到，可让 s `TotalNumberOfProducts`。</span><span class="sxs-lookup"><span data-stu-id="95430-166">As aforementioned, let s use `TotalNumberOfProducts`.</span></span>


![命名为 DAL 方法 TotalNumberOfProducts](efficiently-paging-through-large-amounts-of-data-vb/_static/image4.png)

<span data-ttu-id="95430-168">**图 4**： 命名为 DAL 方法 TotalNumberOfProducts</span><span class="sxs-lookup"><span data-stu-id="95430-168">**Figure 4**: Name the DAL Method TotalNumberOfProducts</span></span>


<span data-ttu-id="95430-169">单击完成之后, 该向导将添加`TotalNumberOfProducts`对 DAL 的方法。</span><span class="sxs-lookup"><span data-stu-id="95430-169">After clicking Finish, the wizard will add the `TotalNumberOfProducts` method to the DAL.</span></span> <span data-ttu-id="95430-170">DAL 中的标量返回方法返回 null 的类型，如果 SQL 查询的结果是`NULL`。</span><span class="sxs-lookup"><span data-stu-id="95430-170">The scalar returning methods in the DAL return nullable types, in case the result from the SQL query is `NULL`.</span></span> <span data-ttu-id="95430-171">我们`COUNT`查询，但是，将始终返回非`NULL`值; 无论如何，DAL 方法将返回一个可以为 null 的整数。</span><span class="sxs-lookup"><span data-stu-id="95430-171">Our `COUNT` query, however, will always return a non-`NULL` value; regardless, the DAL method returns a nullable integer.</span></span>

<span data-ttu-id="95430-172">除了 DAL 方法中，我们还需要在 BLL 中的方法。</span><span class="sxs-lookup"><span data-stu-id="95430-172">In addition to the DAL method, we also need a method in the BLL.</span></span> <span data-ttu-id="95430-173">打开`ProductsBLL`类文件，并添加`TotalNumberOfProducts`方法，只需向下调用 DAL s`TotalNumberOfProducts`方法：</span><span class="sxs-lookup"><span data-stu-id="95430-173">Open the `ProductsBLL` class file and add a `TotalNumberOfProducts` method that simply calls down to the DAL s `TotalNumberOfProducts` method:</span></span>


[!code-vb[Main](efficiently-paging-through-large-amounts-of-data-vb/samples/sample2.vb)]

<span data-ttu-id="95430-174">DAL s`TotalNumberOfProducts`方法返回一个可以为 null 的整数; 但是，我们创建的 ve`ProductsBLL`类的`TotalNumberOfProducts`方法，以便它返回标准的整数。</span><span class="sxs-lookup"><span data-stu-id="95430-174">The DAL s `TotalNumberOfProducts` method returns a nullable integer; however, we ve created the `ProductsBLL` class s `TotalNumberOfProducts` method so that it returns a standard integer.</span></span> <span data-ttu-id="95430-175">因此，我们需要能够`ProductsBLL`类 s`TotalNumberOfProducts`方法返回的 DAL s 返回的可以为 null 的整数的值部分`TotalNumberOfProducts`方法。</span><span class="sxs-lookup"><span data-stu-id="95430-175">Therefore, we need to have the `ProductsBLL` class s `TotalNumberOfProducts` method return the value portion of the nullable integer returned by the DAL s `TotalNumberOfProducts` method.</span></span> <span data-ttu-id="95430-176">在调用`GetValueOrDefault()`返回的值可为 null 的整数，如果存在; 如果可以为 null 的整数`null`，但是，它将返回默认的整数值为 0。</span><span class="sxs-lookup"><span data-stu-id="95430-176">The call to `GetValueOrDefault()` returns the value of the nullable integer, if it exists; if the nullable integer is `null`, however, it returns the default integer value, 0.</span></span>

## <a name="step-3-returning-the-precise-subset-of-records"></a><span data-ttu-id="95430-177">步骤 3： 返回记录的精确的子集</span><span class="sxs-lookup"><span data-stu-id="95430-177">Step 3: Returning the Precise Subset of Records</span></span>

<span data-ttu-id="95430-178">我们的下一个任务是在 DAL 和 BLL 接受开始的行索引的创建方法和最大行数变量前面所述，并返回相应的记录。</span><span class="sxs-lookup"><span data-stu-id="95430-178">Our next task is to create methods in the DAL and BLL that accept the Start Row Index and Maximum Rows variables discussed earlier and return the appropriate records.</span></span> <span data-ttu-id="95430-179">在此之前，让 s 先来看一下所需的 SQL 脚本。</span><span class="sxs-lookup"><span data-stu-id="95430-179">Before we do that, let s first look at the needed SQL script.</span></span> <span data-ttu-id="95430-180">我们面临的挑战是，我们必须能够有效地分配到整个结果，以便我们可以返回从开始处开始的行索引 （和最多的记录的最大记录数） 仅对这些记录正在换通过中的每一行的索引。</span><span class="sxs-lookup"><span data-stu-id="95430-180">The challenge facing us is that we must be able to efficiently assign an index to each row in the entire results being paged through so that we can return just those records starting at the Start Row Index (and up to the Maximum Records number of records).</span></span>

<span data-ttu-id="95430-181">如果已存在一个列用作行索引的数据库表中，这不是一个挑战。</span><span class="sxs-lookup"><span data-stu-id="95430-181">This is not a challenge if there is already a column in the database table that serves as a row index.</span></span> <span data-ttu-id="95430-182">乍一看我们可能会认为`Products`表 s`ProductID`字段便已足够，因为第一个产品有`ProductID`为 1，2，第二个，依此类推。</span><span class="sxs-lookup"><span data-stu-id="95430-182">At first glance we might think that the `Products` table s `ProductID` field would suffice, as the first product has `ProductID` of 1, the second a 2, and so on.</span></span> <span data-ttu-id="95430-183">但是，删除产品会使序列，其此方法中的存在间隔。</span><span class="sxs-lookup"><span data-stu-id="95430-183">However, deleting a product leaves a gap in the sequence, nullifying this approach.</span></span>

<span data-ttu-id="95430-184">有两种常规方法用于有效地将行索引相关联的数据进行分页，从而允许通过记录要检索的精确子集：</span><span class="sxs-lookup"><span data-stu-id="95430-184">There are two general techniques used to efficiently associate a row index with the data to page through, thereby enabling the precise subset of records to be retrieved:</span></span>

- <span data-ttu-id="95430-185">**使用 SQL Server 2005 s`ROW_NUMBER()`关键字**到 SQL Server 2005 新`ROW_NUMBER()`关键字将排名基于某个排序每个返回的记录与相关联。</span><span class="sxs-lookup"><span data-stu-id="95430-185">**Using SQL Server 2005 s `ROW_NUMBER()` Keyword** new to SQL Server 2005, the `ROW_NUMBER()` keyword associates a ranking with each returned record based on some ordering.</span></span> <span data-ttu-id="95430-186">此排名可用作每个行的行索引。</span><span class="sxs-lookup"><span data-stu-id="95430-186">This ranking can be used as a row index for each row.</span></span>
- <span data-ttu-id="95430-187">**使用表变量和`SET ROWCOUNT`**  SQL Server s [ `SET ROWCOUNT`语句](https://msdn.microsoft.com/library/ms188774.aspx)可用于指定查询应终止; 之前处理的总记录数[表变量](http://www.sqlteam.com/item.asp?ItemID=9454)akin 到可以保存表格数据的本地 T-SQL 变量[临时表](http://www.sqlteam.com/item.asp?ItemID=2029)。</span><span class="sxs-lookup"><span data-stu-id="95430-187">**Using a Table Variable and `SET ROWCOUNT`** SQL Server s [`SET ROWCOUNT` statement](https://msdn.microsoft.com/library/ms188774.aspx) can be used to specify how many total records a query should process before terminating; [table variables](http://www.sqlteam.com/item.asp?ItemID=9454) are local T-SQL variables that can hold tabular data, akin to [temporary tables](http://www.sqlteam.com/item.asp?ItemID=2029).</span></span> <span data-ttu-id="95430-188">这种方法同样适用于 Microsoft SQL Server 2005 和 SQL Server 2000 (而`ROW_NUMBER()`的方法仅适用于 SQL Server 2005)。</span><span class="sxs-lookup"><span data-stu-id="95430-188">This approach works equally well with both Microsoft SQL Server 2005 and SQL Server 2000 (whereas the `ROW_NUMBER()` approach only works with SQL Server 2005).</span></span>  
  
  <span data-ttu-id="95430-189">这里的思路是，创建具有一个表变量`IDENTITY`列和通过换其数据时的表的主键列。</span><span class="sxs-lookup"><span data-stu-id="95430-189">The idea here is to create a table variable that has an `IDENTITY` column and columns for the primary keys of the table whose data is being paged through.</span></span> <span data-ttu-id="95430-190">接下来，通过调其数据时的表的内容转储到表变量，从而将连续的行索引相关联 (通过`IDENTITY`列) 的表中每个记录。</span><span class="sxs-lookup"><span data-stu-id="95430-190">Next, the contents of the table whose data is being paged through is dumped into the table variable, thereby associating a sequential row index (via the `IDENTITY` column) for each record in the table.</span></span> <span data-ttu-id="95430-191">一旦填充表变量，`SELECT`语句对表变量中，与基础表联接，可执行以拉出特定记录。</span><span class="sxs-lookup"><span data-stu-id="95430-191">Once the table variable has been populated, a `SELECT` statement on the table variable, joined with the underlying table, can be executed to pull out the particular records.</span></span> <span data-ttu-id="95430-192">`SET ROWCOUNT`语句用于智能地限制需要被转储到表变量的记录数。</span><span class="sxs-lookup"><span data-stu-id="95430-192">The `SET ROWCOUNT` statement is used to intelligently limit the number of records that need to be dumped into the table variable.</span></span>  
  
  <span data-ttu-id="95430-193">此方法的效率取决于所请求的页号为`SET ROWCOUNT`值分配的值开始的行索引以及最大行数。</span><span class="sxs-lookup"><span data-stu-id="95430-193">This approach s efficiency is based on the page number being requested, as the `SET ROWCOUNT` value is assigned the value of Start Row Index plus the Maximum Rows.</span></span> <span data-ttu-id="95430-194">分页浏览如第一个编号较低的页数据的若干页时这种方法是非常有效。</span><span class="sxs-lookup"><span data-stu-id="95430-194">When paging through low-numbered pages such as the first few pages of data this approach is very efficient.</span></span> <span data-ttu-id="95430-195">但是，它展示默认类似于分页的性能时检索快要结束页。</span><span class="sxs-lookup"><span data-stu-id="95430-195">However, it exhibits default paging-like performance when retrieving a page near the end.</span></span>

<span data-ttu-id="95430-196">本教程通过实现自定义分页使用`ROW_NUMBER()`关键字。</span><span class="sxs-lookup"><span data-stu-id="95430-196">This tutorial implements custom paging using the `ROW_NUMBER()` keyword.</span></span> <span data-ttu-id="95430-197">有关使用表变量的详细信息和`SET ROWCOUNT`技术，请参阅[多个有效的方法对于分页通过大型结果集](http://www.4guysfromrolla.com/webtech/042606-1.shtml)。</span><span class="sxs-lookup"><span data-stu-id="95430-197">For more information on using the table variable and `SET ROWCOUNT` technique, see [A More Efficient Method for Paging Through Large Result Sets](http://www.4guysfromrolla.com/webtech/042606-1.shtml).</span></span>

<span data-ttu-id="95430-198">`ROW_NUMBER()`关键字与上一特定的排序方式使用以下语法返回每个记录相关联排名：</span><span class="sxs-lookup"><span data-stu-id="95430-198">The `ROW_NUMBER()` keyword associated a ranking with each record returned over a particular ordering using the following syntax:</span></span>


[!code-sql[Main](efficiently-paging-through-large-amounts-of-data-vb/samples/sample3.sql)]

<span data-ttu-id="95430-199">`ROW_NUMBER()` 返回一个数字值，指定每个记录方面指示排序的排名。</span><span class="sxs-lookup"><span data-stu-id="95430-199">`ROW_NUMBER()` returns a numerical value that specifies the rank for each record with regards to the indicated ordering.</span></span> <span data-ttu-id="95430-200">例如，若要查看每个产品，按照从最顺序排列的排名代价高昂的最少，我们可以使用以下查询：</span><span class="sxs-lookup"><span data-stu-id="95430-200">For example, to see the rank for each product, ordered from the most expensive to the least, we could use the following query:</span></span>


[!code-sql[Main](efficiently-paging-through-large-amounts-of-data-vb/samples/sample4.sql)]

<span data-ttu-id="95430-201">图 5 显示了此查询的结果通过 Visual Studio 中的查询窗口运行时。</span><span class="sxs-lookup"><span data-stu-id="95430-201">Figure 5 shows this query s results when run through the query window in Visual Studio.</span></span> <span data-ttu-id="95430-202">请注意，订购价格，以及每个行的价格排位的产品。</span><span class="sxs-lookup"><span data-stu-id="95430-202">Note that the products are ordered by price, along with a price rank for each row.</span></span>


![价格排名所包含的每个返回的记录](efficiently-paging-through-large-amounts-of-data-vb/_static/image5.png)

<span data-ttu-id="95430-204">**图 5**: 价格排名所包含的每个返回的记录</span><span class="sxs-lookup"><span data-stu-id="95430-204">**Figure 5**: The Price Rank is Included for Each Returned Record</span></span>


> [!NOTE]
> <span data-ttu-id="95430-205">`ROW_NUMBER()` 只有一种新的多个排名函数是在 SQL Server 2005 中可用。</span><span class="sxs-lookup"><span data-stu-id="95430-205">`ROW_NUMBER()` is just one of the many new ranking functions available in SQL Server 2005.</span></span> <span data-ttu-id="95430-206">有关更全面的讨论`ROW_NUMBER()`，以及其他排名函数，读取[Microsoft SQL Server 2005 返回排名结果](http://www.4guysfromrolla.com/webtech/010406-1.shtml)。</span><span class="sxs-lookup"><span data-stu-id="95430-206">For a more thorough discussion of `ROW_NUMBER()`, along with the other ranking functions, read [Returning Ranked Results with Microsoft SQL Server 2005](http://www.4guysfromrolla.com/webtech/010406-1.shtml).</span></span>


<span data-ttu-id="95430-207">当由指定排名结果`ORDER BY`中的列`OVER`子句 (`UnitPrice`，在上面的示例)，SQL Server 必须对结果进行排序。</span><span class="sxs-lookup"><span data-stu-id="95430-207">When ranking the results by the specified `ORDER BY` column in the `OVER` clause (`UnitPrice`, in the above example), SQL Server must sort the results.</span></span> <span data-ttu-id="95430-208">这是一种快捷操作，如果有聚集的索引的列的结果排序，通过，或者如果没有覆盖索引，但可以否则成本更高。</span><span class="sxs-lookup"><span data-stu-id="95430-208">This is a quick operation if there is a clustered index over the column(s) the results are being ordered by, or if there is a covering index, but can be more costly otherwise.</span></span> <span data-ttu-id="95430-209">若要帮助我们改进足够大的查询的性能，请考虑添加按对结果排序所依据的列的非聚集索引。</span><span class="sxs-lookup"><span data-stu-id="95430-209">To help improve performance for sufficiently large queries, consider adding a non-clustered index for the column by which the results are ordered by.</span></span> <span data-ttu-id="95430-210">请参阅[排名函数和 SQL Server 2005 中的性能](http://www.sql-server-performance.com/ak_ranking_functions.asp)有关性能注意事项的更详细信息。</span><span class="sxs-lookup"><span data-stu-id="95430-210">See [Ranking Functions and Performance in SQL Server 2005](http://www.sql-server-performance.com/ak_ranking_functions.asp) for a more detailed look at the performance considerations.</span></span>

<span data-ttu-id="95430-211">返回的排名信息`ROW_NUMBER()`不能直接用于`WHERE`子句。</span><span class="sxs-lookup"><span data-stu-id="95430-211">The ranking information returned by `ROW_NUMBER()` cannot directly be used in the `WHERE` clause.</span></span> <span data-ttu-id="95430-212">但是，派生的表可以用于返回`ROW_NUMBER()`结果，然后可以出现在`WHERE`子句。</span><span class="sxs-lookup"><span data-stu-id="95430-212">However, a derived table can be used to return the `ROW_NUMBER()` result, which can then appear in the `WHERE` clause.</span></span> <span data-ttu-id="95430-213">例如，以下查询使用派生的表与返回产品名称和单价列中，`ROW_NUMBER()`结果，然后使用`WHERE`子句仅返回其价格排名的那些产品将 11 到 20 之间：</span><span class="sxs-lookup"><span data-stu-id="95430-213">For example, the following query uses a derived table to return the ProductName and UnitPrice columns, along with the `ROW_NUMBER()` result, and then uses a `WHERE` clause to only return those products whose price rank is between 11 and 20:</span></span>


[!code-sql[Main](efficiently-paging-through-large-amounts-of-data-vb/samples/sample5.sql)]

<span data-ttu-id="95430-214">扩展此概念有点延伸远，我们可以利用这种方法来检索给定的所需的起始行索引和最大行值的数据的特定页面：</span><span class="sxs-lookup"><span data-stu-id="95430-214">Extending this concept a bit further, we can utilize this approach to retrieve a specific page of data given the desired Start Row Index and Maximum Rows values:</span></span>


[!code-html[Main](efficiently-paging-through-large-amounts-of-data-vb/samples/sample6.html)]

> [!NOTE]
> <span data-ttu-id="95430-215">正如在本教程中，我们将看到的更高版本上 *`StartRowIndex`* 提供的对象数据源编制索引的索引从零，开始而`ROW_NUMBER()`返回 SQL Server 2005 值编制索引的索引从 1 开始。</span><span class="sxs-lookup"><span data-stu-id="95430-215">As we will see later on in this tutorial, the *`StartRowIndex`* supplied by the ObjectDataSource is indexed starting at zero, whereas the `ROW_NUMBER()` value returned by SQL Server 2005 is indexed starting at 1.</span></span> <span data-ttu-id="95430-216">因此，`WHERE`子句将返回这些记录其中`PriceRank`严格大于 *`StartRowIndex`* 且小于或等于 *`StartRowIndex`*  + *`MaximumRows`*.</span><span class="sxs-lookup"><span data-stu-id="95430-216">Therefore, the `WHERE` clause returns those records where `PriceRank` is strictly greater than *`StartRowIndex`* and less than or equal to *`StartRowIndex`* + *`MaximumRows`*.</span></span>


<span data-ttu-id="95430-217">现在，我们已讨论过如何`ROW_NUMBER()`可以是用于检索给定的起始行索引和最大行数的值的数据的特定页，我们现在需要实现此逻辑作为 DAL 和 BLL 中的方法。</span><span class="sxs-lookup"><span data-stu-id="95430-217">Now that we ve discussed how `ROW_NUMBER()` can be used to retrieve a particular page of data given the Start Row Index and Maximum Rows values, we now need to implement this logic as methods in the DAL and BLL.</span></span>

<span data-ttu-id="95430-218">创建此查询，我们必须决定在排序时的结果将被排名;让我们来按其名称的字母顺序对产品进行排序。</span><span class="sxs-lookup"><span data-stu-id="95430-218">When creating this query we must decide the ordering by which the results will be ranked; let s sort the products by their name in alphabetical order.</span></span> <span data-ttu-id="95430-219">这意味着，如果使用自定义分页实现在本教程中我们将不是能够创建自定义分页的报表，不是还可以进行排序。</span><span class="sxs-lookup"><span data-stu-id="95430-219">This means that with the custom paging implementation in this tutorial we will not be able to create a custom paged report than can also be sorted.</span></span> <span data-ttu-id="95430-220">在下一步的教程中，不过，我们将了解如何可以提供此类功能。</span><span class="sxs-lookup"><span data-stu-id="95430-220">In the next tutorial, though, we'll see how such functionality can be provided.</span></span>

<span data-ttu-id="95430-221">在上一部分中我们创建 DAL 方法作为临时 SQL 语句。</span><span class="sxs-lookup"><span data-stu-id="95430-221">In the previous section we created the DAL method as an ad-hoc SQL statement.</span></span> <span data-ttu-id="95430-222">遗憾的是，使用 TableAdapter 向导不等的 Visual Studio 中的 T-SQL 分析器`OVER`使用语法`ROW_NUMBER()`函数。</span><span class="sxs-lookup"><span data-stu-id="95430-222">Unfortunately, the T-SQL parser in Visual Studio used by the TableAdapter wizard doesn t like the `OVER` syntax used by the `ROW_NUMBER()` function.</span></span> <span data-ttu-id="95430-223">因此，我们必须为存储过程来创建此 DAL 方法。</span><span class="sxs-lookup"><span data-stu-id="95430-223">Therefore, we must create this DAL method as a stored procedure.</span></span> <span data-ttu-id="95430-224">从视图菜单 （或命中的 Ctrl + Alt + S） 中选择服务器资源管理器并展开`NORTHWND.MDF`节点。</span><span class="sxs-lookup"><span data-stu-id="95430-224">Select the Server Explorer from the View menu (or hit Ctrl+Alt+S) and expand the `NORTHWND.MDF` node.</span></span> <span data-ttu-id="95430-225">若要添加新的存储的过程，右键单击存储过程节点并选择添加新的存储过程 （请参阅图 6）。</span><span class="sxs-lookup"><span data-stu-id="95430-225">To add a new stored procedure, right-click on the Stored Procedures node and choose Add a New Stored Procedure (see Figure 6).</span></span>


![添加新的存储的过程通过产品的分页](efficiently-paging-through-large-amounts-of-data-vb/_static/image6.png)

<span data-ttu-id="95430-227">**图 6**： 添加新的存储的过程通过产品的分页</span><span class="sxs-lookup"><span data-stu-id="95430-227">**Figure 6**: Add a New Stored Procedure for Paging Through the Products</span></span>


<span data-ttu-id="95430-228">此存储的过程应接受两个整数输入的参数的`@startRowIndex`并`@maximumRows`，并使用`ROW_NUMBER()`函数按排序`ProductName`字段中，返回大于指定的那些行`@startRowIndex`和小于或等于`@startRowIndex`  +  `@maximumRow` s。</span><span class="sxs-lookup"><span data-stu-id="95430-228">This stored procedure should accept two integer input parameters - `@startRowIndex` and `@maximumRows` and use the `ROW_NUMBER()` function ordered by the `ProductName` field, returning only those rows greater than the specified `@startRowIndex` and less than or equal to `@startRowIndex` + `@maximumRow` s.</span></span> <span data-ttu-id="95430-229">到新的存储过程中输入以下脚本，然后单击保存图标以将存储的过程添加到数据库。</span><span class="sxs-lookup"><span data-stu-id="95430-229">Enter the following script into the new stored procedure and then click the Save icon to add the stored procedure to the database.</span></span>


[!code-sql[Main](efficiently-paging-through-large-amounts-of-data-vb/samples/sample7.sql)]

<span data-ttu-id="95430-230">在创建后的存储的过程，请花费片刻时间对它进行测试。右键单击`GetProductsPaged`存储的过程中在服务器资源管理器的名称并选择执行选项。</span><span class="sxs-lookup"><span data-stu-id="95430-230">After creating the stored procedure, take a moment to test it out. Right-click on the `GetProductsPaged` stored procedure name in the Server Explorer and choose the Execute option.</span></span> <span data-ttu-id="95430-231">Visual Studio 随后会提示您为输入参数`@startRowIndex`和`@maximumRow`s （请参阅图 7）。</span><span class="sxs-lookup"><span data-stu-id="95430-231">Visual Studio will then prompt you for the input parameters, `@startRowIndex` and `@maximumRow` s (see Figure 7).</span></span> <span data-ttu-id="95430-232">请尝试不同的值，并检查结果。</span><span class="sxs-lookup"><span data-stu-id="95430-232">Try different values and examine the results.</span></span>


![输入一个值@startRowIndex和@maximumRows参数](efficiently-paging-through-large-amounts-of-data-vb/_static/image7.png)

<span data-ttu-id="95430-234"><strong>图 7</strong>： 输入一个值@startRowIndex和@maximumRows参数</span><span class="sxs-lookup"><span data-stu-id="95430-234"><strong>Figure 7</strong>: Enter a Value for the @startRowIndex and @maximumRows Parameters</span></span>


<span data-ttu-id="95430-235">之后选择这些输入参数值，输出窗口将显示结果。</span><span class="sxs-lookup"><span data-stu-id="95430-235">After choosing these input parameters values, the Output window will show the results.</span></span> <span data-ttu-id="95430-236">图 8 显示了两个 10 中传递时的结果`@startRowIndex`和`@maximumRows`参数。</span><span class="sxs-lookup"><span data-stu-id="95430-236">Figure 8 shows the results when passing in 10 for both the `@startRowIndex` and `@maximumRows` parameters.</span></span>


<span data-ttu-id="95430-237">[![返回记录，将显示在第二个数据页](efficiently-paging-through-large-amounts-of-data-vb/_static/image9.png)](efficiently-paging-through-large-amounts-of-data-vb/_static/image8.png)</span><span class="sxs-lookup"><span data-stu-id="95430-237">[![The Records That Would Appear in the Second Page of Data are Returned](efficiently-paging-through-large-amounts-of-data-vb/_static/image9.png)](efficiently-paging-through-large-amounts-of-data-vb/_static/image8.png)</span></span>

<span data-ttu-id="95430-238">**图 8**： 返回记录，将显示在第二个数据页 ([单击以查看实际尺寸的图像](efficiently-paging-through-large-amounts-of-data-vb/_static/image10.png))</span><span class="sxs-lookup"><span data-stu-id="95430-238">**Figure 8**: The Records That Would Appear in the Second Page of Data are Returned ([Click to view full-size image](efficiently-paging-through-large-amounts-of-data-vb/_static/image10.png))</span></span>


<span data-ttu-id="95430-239">与此存储过程创建的我们已准备好创建 re`ProductsTableAdapter`方法。</span><span class="sxs-lookup"><span data-stu-id="95430-239">With this stored procedure created, we re ready to create the `ProductsTableAdapter` method.</span></span> <span data-ttu-id="95430-240">打开`Northwind.xsd`类型化数据集，在中单击右键`ProductsTableAdapter`，然后选择添加查询选项。</span><span class="sxs-lookup"><span data-stu-id="95430-240">Open the `Northwind.xsd` Typed DataSet, right-click in the `ProductsTableAdapter`, and choose the Add Query option.</span></span> <span data-ttu-id="95430-241">而不是创建使用的临时 SQL 语句的查询，创建使用现有的存储的过程。</span><span class="sxs-lookup"><span data-stu-id="95430-241">Instead of creating the query using an ad-hoc SQL statement, create it using an existing stored procedure.</span></span>


![创建使用现有的存储的过程的 DAL 方法](efficiently-paging-through-large-amounts-of-data-vb/_static/image11.png)

<span data-ttu-id="95430-243">**图 9**： 创建使用现有的存储的过程的 DAL 方法</span><span class="sxs-lookup"><span data-stu-id="95430-243">**Figure 9**: Create the DAL Method Using an Existing Stored Procedure</span></span>


<span data-ttu-id="95430-244">接下来，我们会提示选择要调用的存储的过程。</span><span class="sxs-lookup"><span data-stu-id="95430-244">Next, we are prompted to select the stored procedure to invoke.</span></span> <span data-ttu-id="95430-245">选取`GetProductsPaged`存储过程从下拉列表。</span><span class="sxs-lookup"><span data-stu-id="95430-245">Pick the `GetProductsPaged` stored procedure from the drop-down list.</span></span>


![选择 GetProductsPaged 存储过程从下拉列表](efficiently-paging-through-large-amounts-of-data-vb/_static/image12.png)

<span data-ttu-id="95430-247">**图 10**： 选择 GetProductsPaged 存储过程从下拉列表</span><span class="sxs-lookup"><span data-stu-id="95430-247">**Figure 10**: Choose the GetProductsPaged Stored Procedure from the Drop-Down List</span></span>


<span data-ttu-id="95430-248">下一屏幕中，将要求您的数据类型返回的存储过程： 表格数据、 单个值或没有值。</span><span class="sxs-lookup"><span data-stu-id="95430-248">The next screen then asks you what kind of data is returned by the stored procedure: tabular data, a single value, or no value.</span></span> <span data-ttu-id="95430-249">由于`GetProductsPaged`存储的过程可以返回多个记录，指示它返回表格格式数据。</span><span class="sxs-lookup"><span data-stu-id="95430-249">Since the `GetProductsPaged` stored procedure can return multiple records, indicate that it returns tabular data.</span></span>


![指示存储的过程返回表格格式数据](efficiently-paging-through-large-amounts-of-data-vb/_static/image13.png)

<span data-ttu-id="95430-251">**图 11**： 指示存储的过程返回表格格式数据</span><span class="sxs-lookup"><span data-stu-id="95430-251">**Figure 11**: Indicate that the Stored Procedure Returns Tabular Data</span></span>


<span data-ttu-id="95430-252">最后，指示你想要创建的方法的名称。</span><span class="sxs-lookup"><span data-stu-id="95430-252">Finally, indicate the names of the methods you want to have created.</span></span> <span data-ttu-id="95430-253">与我们前面的教程中，请继续并创建方法使用这两种填充 DataTable 返回 DataTable。</span><span class="sxs-lookup"><span data-stu-id="95430-253">As with our previous tutorials, go ahead and create methods using both the Fill a DataTable and Return a DataTable.</span></span> <span data-ttu-id="95430-254">第一个方法命名`FillPaged`，第二个`GetProductsPaged`。</span><span class="sxs-lookup"><span data-stu-id="95430-254">Name the first method `FillPaged` and the second `GetProductsPaged`.</span></span>


![名称方法 FillPaged 和 GetProductsPaged](efficiently-paging-through-large-amounts-of-data-vb/_static/image14.png)

<span data-ttu-id="95430-256">**图 12**： 名称方法 FillPaged 和 GetProductsPaged</span><span class="sxs-lookup"><span data-stu-id="95430-256">**Figure 12**: Name the Methods FillPaged and GetProductsPaged</span></span>


<span data-ttu-id="95430-257">除了创建 DAL 方法返回的产品特定页，我们还需要提供 BLL 中的此类功能。</span><span class="sxs-lookup"><span data-stu-id="95430-257">In addition to created a DAL method to return a particular page of products, we also need to provide such functionality in the BLL.</span></span> <span data-ttu-id="95430-258">DAL 与方法一样，BLL 的 GetProductsPaged 方法必须接受用于指定起始行索引和最大行数的两个整数输入，并且必须返回只在指定范围内的记录。</span><span class="sxs-lookup"><span data-stu-id="95430-258">Like the DAL method, the BLL s GetProductsPaged method must accept two integer inputs for specifying the Start Row Index and Maximum Rows, and must return just those records that fall within the specified range.</span></span> <span data-ttu-id="95430-259">只是调用向下的到 DAL 的 GetProductsPaged 方法，就像这样在 ProductsBLL 类中创建此类的 BLL 方法：</span><span class="sxs-lookup"><span data-stu-id="95430-259">Create such a BLL method in the ProductsBLL class that merely calls down into the DAL s GetProductsPaged method, like so:</span></span>


[!code-vb[Main](efficiently-paging-through-large-amounts-of-data-vb/samples/sample8.vb)]

<span data-ttu-id="95430-260">可以使用任何名称为 BLL 的方法的输入参数，但是正如我们稍后将看到的选择要使用`startRowIndex`和`maximumRows`我们节省从一个额外的配置对象数据源，才能使用此方法时的工作。</span><span class="sxs-lookup"><span data-stu-id="95430-260">You can use any name for the BLL method s input parameters, but, as we will see shortly, choosing to use `startRowIndex` and `maximumRows` saves us from an extra bit of work when configuring an ObjectDataSource to use this method.</span></span>

## <a name="step-4-configuring-the-objectdatasource-to-use-custom-paging"></a><span data-ttu-id="95430-261">步骤 4： 配置 ObjectDataSource 用于自定义分页</span><span class="sxs-lookup"><span data-stu-id="95430-261">Step 4: Configuring the ObjectDataSource to Use Custom Paging</span></span>

<span data-ttu-id="95430-262">使用用于访问完整的记录的特定子集的 BLL 和 DAL 方法，我们准备就绪后，若要创建 GridView 控制其使用自定义分页的基础记录通过该页面。</span><span class="sxs-lookup"><span data-stu-id="95430-262">With the BLL and DAL methods for accessing a particular subset of records complete, we re ready to create a GridView control that pages through its underlying records using custom paging.</span></span> <span data-ttu-id="95430-263">首先打开`EfficientPaging.aspx`页中`PagingAndSorting`文件夹中，将 GridView 添加到页上，并将其配置为使用新的 ObjectDataSource 控件。</span><span class="sxs-lookup"><span data-stu-id="95430-263">Start by opening the `EfficientPaging.aspx` page in the `PagingAndSorting` folder, add a GridView to the page, and configure it to use a new ObjectDataSource control.</span></span> <span data-ttu-id="95430-264">在我们过去的教程，我们通常必须配置为使用 ObjectDataSource`ProductsBLL`类的`GetProducts`方法。</span><span class="sxs-lookup"><span data-stu-id="95430-264">In our past tutorials, we often had the ObjectDataSource configured to use the `ProductsBLL` class s `GetProducts` method.</span></span> <span data-ttu-id="95430-265">这一次，但是，我们想要使用`GetProductsPaged`方法相反，因为`GetProducts`方法将返回*所有*数据库中的产品而`GetProductsPaged`返回只记录的特定子集。</span><span class="sxs-lookup"><span data-stu-id="95430-265">This time, however, we want to use the `GetProductsPaged` method instead, since the `GetProducts` method returns *all* of the products in the database whereas `GetProductsPaged` returns just a particular subset of records.</span></span>


![配置对象数据源使用 ProductsBLL 类的 GetProductsPaged 方法](efficiently-paging-through-large-amounts-of-data-vb/_static/image15.png)

<span data-ttu-id="95430-267">**图 13**： 配置 ObjectDataSource 使用 ProductsBLL 类的 GetProductsPaged 方法</span><span class="sxs-lookup"><span data-stu-id="95430-267">**Figure 13**: Configure the ObjectDataSource to Use the ProductsBLL Class s GetProductsPaged Method</span></span>


<span data-ttu-id="95430-268">由于我们重新创建只读的 GridView，花一点时间设置方法下拉列表中的 INSERT、 UPDATE，并删除选项卡添加到 （无）。</span><span class="sxs-lookup"><span data-stu-id="95430-268">Since we re creating a read-only GridView, take a moment to set the method drop-down list in the INSERT, UPDATE, and DELETE tabs to (None).</span></span>

<span data-ttu-id="95430-269">接下来，ObjectDataSource 向导提示我们输入的源`GetProductsPaged`s 方法`startRowIndex`和`maximumRows`输入参数值。</span><span class="sxs-lookup"><span data-stu-id="95430-269">Next, the ObjectDataSource wizard prompts us for the sources of the `GetProductsPaged` method s `startRowIndex` and `maximumRows` input parameters values.</span></span> <span data-ttu-id="95430-270">这些输入的参数实际上将会通过 GridView 自动，因此只需将源设置为 None 并单击完成。</span><span class="sxs-lookup"><span data-stu-id="95430-270">These input parameters will actually be set by the GridView automatically, so simply leave the source set to None and click Finish.</span></span>


![将保留为无输入的参数源](efficiently-paging-through-large-amounts-of-data-vb/_static/image16.png)

<span data-ttu-id="95430-272">**图 14**： 保留为无输入的参数源</span><span class="sxs-lookup"><span data-stu-id="95430-272">**Figure 14**: Leave the Input Parameter Sources as None</span></span>


<span data-ttu-id="95430-273">完成 ObjectDataSource 向导后，命令将 BoundField 或 CheckBoxField 每个产品的数据字段包含 GridView。</span><span class="sxs-lookup"><span data-stu-id="95430-273">After completing the ObjectDataSource wizard, the GridView will contain a BoundField or CheckBoxField for each of the product data fields.</span></span> <span data-ttu-id="95430-274">随时根据需要定制 GridView 的外观。</span><span class="sxs-lookup"><span data-stu-id="95430-274">Feel free to tailor the GridView s appearance as you see fit.</span></span> <span data-ttu-id="95430-275">我已选择仅显示`ProductName`， `CategoryName`， `SupplierName`， `QuantityPerUnit`，和`UnitPrice`BoundFields。</span><span class="sxs-lookup"><span data-stu-id="95430-275">I ve opted to display only the `ProductName`, `CategoryName`, `SupplierName`, `QuantityPerUnit`, and `UnitPrice` BoundFields.</span></span> <span data-ttu-id="95430-276">此外，配置 GridView 支持分页，通过检查其智能标记中的启用分页复选框。</span><span class="sxs-lookup"><span data-stu-id="95430-276">Also, configure the GridView to support paging by checking the Enable Paging checkbox in its smart tag.</span></span> <span data-ttu-id="95430-277">更改后，GridView 和 ObjectDataSource 声明性标记应类似于下面：</span><span class="sxs-lookup"><span data-stu-id="95430-277">After these changes, the GridView and ObjectDataSource declarative markup should look similar to the following:</span></span>


[!code-aspx[Main](efficiently-paging-through-large-amounts-of-data-vb/samples/sample9.aspx)]

<span data-ttu-id="95430-278">如果在访问通过浏览器页面，但是，这个 GridView 已经没有任何地方进行查找。</span><span class="sxs-lookup"><span data-stu-id="95430-278">If you visit the page through a browser, however, the GridView is no where to be found.</span></span>


![这个 GridView 已经不显示](efficiently-paging-through-large-amounts-of-data-vb/_static/image17.png)

<span data-ttu-id="95430-280">**图 15**： 的 GridView 是不会显示</span><span class="sxs-lookup"><span data-stu-id="95430-280">**Figure 15**: The GridView is Not Displayed</span></span>


<span data-ttu-id="95430-281">这个 GridView 已经丢失，因为 ObjectDataSource 当前使用 0 作为值的两个`GetProductsPaged``startRowIndex`和`maximumRows`输入参数。</span><span class="sxs-lookup"><span data-stu-id="95430-281">The GridView is missing because the ObjectDataSource is currently using 0 as the values for both of the `GetProductsPaged` `startRowIndex` and `maximumRows` input parameters.</span></span> <span data-ttu-id="95430-282">因此，生成的 SQL 查询返回任何记录，并因此不显示 GridView。</span><span class="sxs-lookup"><span data-stu-id="95430-282">Hence, the resulting SQL query is returning no records and therefore the GridView is not displayed.</span></span>

<span data-ttu-id="95430-283">若要解决此问题，我们需要配置对象数据源以使用自定义分页。</span><span class="sxs-lookup"><span data-stu-id="95430-283">To remedy this, we need to configure the ObjectDataSource to use custom paging.</span></span> <span data-ttu-id="95430-284">这可以通过以下步骤完成：</span><span class="sxs-lookup"><span data-stu-id="95430-284">This can be accomplished in the following steps:</span></span>

1. <span data-ttu-id="95430-285">**设置 ObjectDataSource s`EnablePaging`属性设置为`true`** 这会指示必须将传递给 ObjectDataSource`SelectMethod`其他两个参数： 一个用于指定开始的行索引 ([ `StartRowIndexParameterName` ](https://msdn.microsoft.com/library/system.web.ui.webcontrols.objectdatasource.startrowindexparametername.aspx))，另一个用于指定最大行数 ([`MaximumRowsParameterName`](https://msdn.microsoft.com/library/system.web.ui.webcontrols.objectdatasource.maximumrowsparametername.aspx))。</span><span class="sxs-lookup"><span data-stu-id="95430-285">**Set the ObjectDataSource s `EnablePaging` property to `true`** this indicates to the ObjectDataSource that it must pass to the `SelectMethod` two additional parameters: one to specify the Start Row Index ([`StartRowIndexParameterName`](https://msdn.microsoft.com/library/system.web.ui.webcontrols.objectdatasource.startrowindexparametername.aspx)), and one to specify the Maximum Rows ([`MaximumRowsParameterName`](https://msdn.microsoft.com/library/system.web.ui.webcontrols.objectdatasource.maximumrowsparametername.aspx)).</span></span>
2. <span data-ttu-id="95430-286">**设置 ObjectDataSource s`StartRowIndexParameterName`并`MaximumRowsParameterName`属性相应地**`StartRowIndexParameterName`并`MaximumRowsParameterName`属性指示传入的输入参数的名称`SelectMethod`用于自定义分页目的。</span><span class="sxs-lookup"><span data-stu-id="95430-286">**Set the ObjectDataSource s `StartRowIndexParameterName` and `MaximumRowsParameterName` Properties Accordingly** the `StartRowIndexParameterName` and `MaximumRowsParameterName` properties indicate the names of the input parameters passed into the `SelectMethod` for custom paging purposes.</span></span> <span data-ttu-id="95430-287">默认情况下，这些参数名称是`startIndexRow`并`maximumRows`，这就是为什么，创建时`GetProductsPaged`方法在 BLL，我使用了这些值用于输入参数。</span><span class="sxs-lookup"><span data-stu-id="95430-287">By default, these parameter names are `startIndexRow` and `maximumRows`, which is why, when creating the `GetProductsPaged` method in the BLL, I used these values for the input parameters.</span></span> <span data-ttu-id="95430-288">如果选择了使用不同的参数名称的 BLL s`GetProductsPaged`等方法`startIndex`并`maxRows`，您需要的示例设置 ObjectDataSource s`StartRowIndexParameterName`和`MaximumRowsParameterName`属性相应地 （例如为 startIndex`StartRowIndexParameterName`和最大行数为`MaximumRowsParameterName`)。</span><span class="sxs-lookup"><span data-stu-id="95430-288">If you chose to use different parameter names for the BLL s `GetProductsPaged` method such as `startIndex` and `maxRows`, for example you would need to set the ObjectDataSource s `StartRowIndexParameterName` and `MaximumRowsParameterName` properties accordingly (such as startIndex for `StartRowIndexParameterName` and maxRows for `MaximumRowsParameterName`).</span></span>
3. <span data-ttu-id="95430-289">**设置 ObjectDataSource s [ `SelectCountMethod`属性](https://msdn.microsoft.com/library/system.web.ui.webcontrols.objectdatasource.selectcountmethod(VS.80).aspx)总数量的记录被分页通过返回的方法的名称 (`TotalNumberOfProducts`)** 回想一下，`ProductsBLL`类的`TotalNumberOfProducts`方法返回通过使用执行的 DAL 方法正在分页的记录总数`SELECT COUNT(*) FROM Products`查询。</span><span class="sxs-lookup"><span data-stu-id="95430-289">**Set the ObjectDataSource s [`SelectCountMethod` Property](https://msdn.microsoft.com/library/system.web.ui.webcontrols.objectdatasource.selectcountmethod(VS.80).aspx) to the Name of the Method that Returns the Total Number of Records Being Paged Through (`TotalNumberOfProducts`)** recall that the `ProductsBLL` class s `TotalNumberOfProducts` method returns the total number of records being paged through using a DAL method that executes a `SELECT COUNT(*) FROM Products` query.</span></span> <span data-ttu-id="95430-290">ObjectDataSource 需要此信息以正确呈现分页界面。</span><span class="sxs-lookup"><span data-stu-id="95430-290">This information is needed by the ObjectDataSource in order to correctly render the paging interface.</span></span>
4. <span data-ttu-id="95430-291">**删除`startRowIndex`并`maximumRows` `<asp:Parameter>` ObjectDataSource s 声明性标记中的元素**在配置向导通过对象数据源时，Visual Studio 会自动添加了两个`<asp:Parameter>`元素有关`GetProductsPaged`的方法的输入参数。</span><span class="sxs-lookup"><span data-stu-id="95430-291">**Remove the `startRowIndex` and `maximumRows` `<asp:Parameter>` Elements from the ObjectDataSource s Declarative Markup** when configuring the ObjectDataSource through the wizard, Visual Studio automatically added two `<asp:Parameter>` elements for the `GetProductsPaged` method s input parameters.</span></span> <span data-ttu-id="95430-292">通过设置`EnablePaging`到`true`，将自动传递这些参数; 如果它们也出现在声明性语法，ObjectDataSource 将尝试传递*四个*参数`GetProductsPaged`方法和两个参数`TotalNumberOfProducts`方法。</span><span class="sxs-lookup"><span data-stu-id="95430-292">By setting `EnablePaging` to `true`, these parameters will be passed automatically; if they also appear in the declarative syntax, the ObjectDataSource will attempt to pass *four* parameters to the `GetProductsPaged` method and two parameters to the `TotalNumberOfProducts` method.</span></span> <span data-ttu-id="95430-293">如果你忘记了以删除这些`<asp:Parameter>`元素，当访问通过浏览器，你将收到错误消息的页面： *ObjectDataSource ObjectDataSource1 找不到非泛型方法 TotalNumberOfProducts 具有参数： startRowIndex，值*。</span><span class="sxs-lookup"><span data-stu-id="95430-293">If you forget to remove these `<asp:Parameter>` elements, when visiting the page through a browser you'll get an error message like: *ObjectDataSource 'ObjectDataSource1' could not find a non-generic method 'TotalNumberOfProducts' that has parameters: startRowIndex, maximumRows*.</span></span>

<span data-ttu-id="95430-294">进行这些更改后，ObjectDataSource s 声明性语法应如以下所示：</span><span class="sxs-lookup"><span data-stu-id="95430-294">After making these changes, the ObjectDataSource s declarative syntax should look like the following:</span></span>


[!code-aspx[Main](efficiently-paging-through-large-amounts-of-data-vb/samples/sample10.aspx)]

<span data-ttu-id="95430-295">请注意，`EnablePaging`并`SelectCountMethod`已设置属性和`<asp:Parameter>`元素已被删除。</span><span class="sxs-lookup"><span data-stu-id="95430-295">Note that the `EnablePaging` and `SelectCountMethod` properties have been set and the `<asp:Parameter>` elements have been removed.</span></span> <span data-ttu-id="95430-296">进行这些更改之后，图 16 所示属性窗口的屏幕的截图。</span><span class="sxs-lookup"><span data-stu-id="95430-296">Figure 16 shows a screen shot of the Properties window after these changes have been made.</span></span>


![若要使用自定义分页，配置 ObjectDataSource 控件](efficiently-paging-through-large-amounts-of-data-vb/_static/image18.png)

<span data-ttu-id="95430-298">**图 16**： 若要使用自定义分页，配置 ObjectDataSource 控件</span><span class="sxs-lookup"><span data-stu-id="95430-298">**Figure 16**: To Use Custom Paging, Configure the ObjectDataSource Control</span></span>


<span data-ttu-id="95430-299">进行这些更改后，请访问此页上的通过浏览器。</span><span class="sxs-lookup"><span data-stu-id="95430-299">After making these changes, visit this page through a browser.</span></span> <span data-ttu-id="95430-300">应会看到 10 种产品列出，请按字母顺序排序。</span><span class="sxs-lookup"><span data-stu-id="95430-300">You should see 10 products listed, ordered alphabetically.</span></span> <span data-ttu-id="95430-301">请花费片刻时间逐步一次一页数据。</span><span class="sxs-lookup"><span data-stu-id="95430-301">Take a moment to step through the data one page at a time.</span></span> <span data-ttu-id="95430-302">虽然默认的分页和自定义分页之间没有可见差异从最终用户 s 角度来看，自定义分页更有效地页，通过大量的数据因为它仅检索那些需要为某一给定页显示的记录。</span><span class="sxs-lookup"><span data-stu-id="95430-302">While there is no visual difference from the end user s perspective between default paging and custom paging, custom paging more efficiently pages through large amounts of data as it only retrieves those records that need to be displayed for a given page.</span></span>


<span data-ttu-id="95430-303">[![数据、 Ordered 按产品名称，是分页使用自定义分页](efficiently-paging-through-large-amounts-of-data-vb/_static/image20.png)](efficiently-paging-through-large-amounts-of-data-vb/_static/image19.png)</span><span class="sxs-lookup"><span data-stu-id="95430-303">[![The Data, Ordered by the Product s Name, is Paged Using Custom Paging](efficiently-paging-through-large-amounts-of-data-vb/_static/image20.png)](efficiently-paging-through-large-amounts-of-data-vb/_static/image19.png)</span></span>

<span data-ttu-id="95430-304">**图 17**: 数据、 Ordered 按产品名称，是分页使用自定义分页 ([单击以查看实际尺寸的图像](efficiently-paging-through-large-amounts-of-data-vb/_static/image21.png))</span><span class="sxs-lookup"><span data-stu-id="95430-304">**Figure 17**: The Data, Ordered by the Product s Name, is Paged Using Custom Paging ([Click to view full-size image](efficiently-paging-through-large-amounts-of-data-vb/_static/image21.png))</span></span>


> [!NOTE]
> <span data-ttu-id="95430-305">使用自定义分页，页计数值返回的 ObjectDataSource 的`SelectCountMethod`GridView 的视图状态中存储。</span><span class="sxs-lookup"><span data-stu-id="95430-305">With custom paging, the page count value returned by the ObjectDataSource�s `SelectCountMethod` is stored in the GridView�s view state.</span></span> <span data-ttu-id="95430-306">其他 GridView 变量`PageIndex`， `EditIndex`， `SelectedIndex`，`DataKeys`集合中，依次类推存储在*控制状态*，其中保留而不考虑 GridView 的值`EnableViewState`属性。</span><span class="sxs-lookup"><span data-stu-id="95430-306">Other GridView variables the `PageIndex`, `EditIndex`, `SelectedIndex`, `DataKeys` collection, and so on are stored in *control state*, which is persisted regardless of the value of the GridView�s `EnableViewState` property.</span></span> <span data-ttu-id="95430-307">由于`PageCount`值被存储在回发期间使用的分页界面中包括用于将您带到最后一页的链接时使用视图状态，则必须启用 GridView 的视图状态。</span><span class="sxs-lookup"><span data-stu-id="95430-307">Since the `PageCount` value is persisted across postbacks using view state, when using a paging interface that includes a link to take you to the last page, it is imperative that the GridView�s view state be enabled.</span></span> <span data-ttu-id="95430-308">（如果分页界面不包含的直接链接到最后一页上，然后你可以禁用视图状态。）</span><span class="sxs-lookup"><span data-stu-id="95430-308">(If your paging interface does not include a direct link to the last page, then you may disable view state.)</span></span>


<span data-ttu-id="95430-309">单击最后一页链接导致回发，并指示 GridView 来更新其`PageIndex`属性。</span><span class="sxs-lookup"><span data-stu-id="95430-309">Clicking the last page link causes a postback and instructs the GridView to update its `PageIndex` property.</span></span> <span data-ttu-id="95430-310">如果单击最后一页链接，GridView 会分配其`PageIndex`属性的值之一不会早于其`PageCount`属性。</span><span class="sxs-lookup"><span data-stu-id="95430-310">If the last page link is clicked, the GridView assigns its `PageIndex` property to a value one less than its `PageCount` property.</span></span> <span data-ttu-id="95430-311">使用视图状态已禁用，`PageCount`值会丢失在经过回发和`PageIndex`改为分配的最大整数值。</span><span class="sxs-lookup"><span data-stu-id="95430-311">With view state disabled, the `PageCount` value is lost across postbacks and the `PageIndex` is assigned the maximum integer value instead.</span></span> <span data-ttu-id="95430-312">接下来，尝试确定的起始行索引乘以 GridView`PageSize`和`PageCount`属性。</span><span class="sxs-lookup"><span data-stu-id="95430-312">Next, the GridView attempts to determine the starting row index by multiplying the `PageSize` and `PageCount` properties.</span></span> <span data-ttu-id="95430-313">这会导致`OverflowException`由于产品超出了允许的最大整数大小。</span><span class="sxs-lookup"><span data-stu-id="95430-313">This results in an `OverflowException` since the product exceeds the maximum allowed integer size.</span></span>

## <a name="implement-custom-paging-and-sorting"></a><span data-ttu-id="95430-314">实现自定义分页和排序</span><span class="sxs-lookup"><span data-stu-id="95430-314">Implement Custom Paging and Sorting</span></span>

<span data-ttu-id="95430-315">我们当前的自定义分页实现要求通过换数据时所依据的顺序指定以静态方式创建时`GetProductsPaged`存储过程。</span><span class="sxs-lookup"><span data-stu-id="95430-315">Our current custom paging implementation requires that the order by which the data is paged through be specified statically when creating the `GetProductsPaged` stored procedure.</span></span> <span data-ttu-id="95430-316">但是，你可能已记下 GridView s 智能标记包含除了启用分页选项启用排序复选框。</span><span class="sxs-lookup"><span data-stu-id="95430-316">However, you may have noted that the GridView s smart tag contains an Enable Sorting checkbox in addition to the Enable Paging option.</span></span> <span data-ttu-id="95430-317">遗憾的是，将排序支持添加到我们当前的自定义分页实现 GridView 仅将排序数据的当前正在查看页上的记录。</span><span class="sxs-lookup"><span data-stu-id="95430-317">Unfortunately, adding sorting support to the GridView with our current custom paging implementation will only sort the records on the currently viewed page of data.</span></span> <span data-ttu-id="95430-318">例如，如果配置 GridView 也支持分页和查看数据，第一页时按降序排序，产品名称的排序然后，它将在第 1 页上反转产品的顺序。</span><span class="sxs-lookup"><span data-stu-id="95430-318">For example, if you configure the GridView to also support paging and then, when viewing the first page of data, sort by product name in descending order, it will reverse the order of the products on page 1.</span></span> <span data-ttu-id="95430-319">如图 18 所示，此类显示了墨鱼作为第一个产品时按反向字母顺序，将忽略的 71 其他产品按字母顺序; 晚墨鱼，排序排序操作中被视为第一页上的这些记录。</span><span class="sxs-lookup"><span data-stu-id="95430-319">As Figure 18 shows, such shows Carnarvon Tigers as the first product when sorting in reverse alphabetical order, which ignores the 71 other products that come after Carnarvon Tigers, alphabetically; only those records on the first page are considered in the sorting.</span></span>


<span data-ttu-id="95430-320">[![仅显示数据当前页上进行排序](efficiently-paging-through-large-amounts-of-data-vb/_static/image23.png)](efficiently-paging-through-large-amounts-of-data-vb/_static/image22.png)</span><span class="sxs-lookup"><span data-stu-id="95430-320">[![Only the Data Shown on the Current Page is Sorted](efficiently-paging-through-large-amounts-of-data-vb/_static/image23.png)](efficiently-paging-through-large-amounts-of-data-vb/_static/image22.png)</span></span>

<span data-ttu-id="95430-321">**图 18**： 仅显示数据当前页上进行排序 ([单击以查看实际尺寸的图像](efficiently-paging-through-large-amounts-of-data-vb/_static/image24.png))</span><span class="sxs-lookup"><span data-stu-id="95430-321">**Figure 18**: Only the Data Shown on the Current Page is Sorted ([Click to view full-size image](efficiently-paging-through-large-amounts-of-data-vb/_static/image24.png))</span></span>


<span data-ttu-id="95430-322">排序仅适用于数据的当前页后已从 BLL s 检索的数据的排序发生因为`GetProductsPaged`方法，而此方法仅返回的特定页中的记录。</span><span class="sxs-lookup"><span data-stu-id="95430-322">The sorting only applies to the current page of data because the sorting is occurring after the data has been retrieved from the BLL s `GetProductsPaged` method, and this method only returns those records for the specific page.</span></span> <span data-ttu-id="95430-323">若要实现正确排序，我们需要传递到排序表达式`GetProductsPaged`方法，以便返回数据的特定页之前适当排名数据。</span><span class="sxs-lookup"><span data-stu-id="95430-323">To implement sorting correctly, we need to pass the sort expression to the `GetProductsPaged` method so that the data can be ranked appropriately before returning the specific page of data.</span></span> <span data-ttu-id="95430-324">我们将了解如何实现此目的在我们下一步的教程。</span><span class="sxs-lookup"><span data-stu-id="95430-324">We'll see how to accomplish this in our next tutorial.</span></span>

## <a name="implementing-custom-paging-and-deleting"></a><span data-ttu-id="95430-325">实现自定义分页和删除</span><span class="sxs-lookup"><span data-stu-id="95430-325">Implementing Custom Paging and Deleting</span></span>

<span data-ttu-id="95430-326">如果您启用使用自定义分页技术，您会发现从最后一页中删除最后一条记录时分页的数据的 GridView 中删除功能，GridView 消失而不是适当递减 GridView 的`PageIndex`.</span><span class="sxs-lookup"><span data-stu-id="95430-326">If you enabling deleting functionality in a GridView whose data is paged using custom paging techniques you will find that when deleting the last record from the last page, the GridView disappears rather than appropriately decrementing the GridView s `PageIndex`.</span></span> <span data-ttu-id="95430-327">若要重现此错误，启用删除本教程只是我们刚刚创建的。</span><span class="sxs-lookup"><span data-stu-id="95430-327">To reproduce this bug, enable deleting for the tutorial just we just created.</span></span> <span data-ttu-id="95430-328">转到最后一页 （页 9），其中应看到一个产品，因为我们都分页通过 81 产品，每次 10 种产品。</span><span class="sxs-lookup"><span data-stu-id="95430-328">Go to the last page (page 9), where you should see a single product since we are paging through 81 products, 10 products at a time.</span></span> <span data-ttu-id="95430-329">删除此产品。</span><span class="sxs-lookup"><span data-stu-id="95430-329">Delete this product.</span></span>

<span data-ttu-id="95430-330">在删除最后一个产品，GridView*应*自动转到第八个页上，并使用默认的分页时，会出现此类功能。</span><span class="sxs-lookup"><span data-stu-id="95430-330">Upon deleting the last product, the GridView *should* automatically go to the eighth page, and such functionality is exhibited with default paging.</span></span> <span data-ttu-id="95430-331">使用自定义分页，但是，删除的最后一页的最后一个产品后 GridView 只需从屏幕上消失完全。</span><span class="sxs-lookup"><span data-stu-id="95430-331">With custom paging, however, after deleting that last product on the last page, the GridView simply disappears from the screen altogether.</span></span> <span data-ttu-id="95430-332">确切原因*为什么*发生这种情况有点超出了本教程的范围; 请参阅[从使用自定义分页 GridView 中删除最后一页上的最后一个记录](http://scottonwriting.net/sowblog/posts/7326.aspx)并与来源的低级别的详细信息此问题。</span><span class="sxs-lookup"><span data-stu-id="95430-332">The precise reason *why* this happens is a bit beyond the scope of this tutorial; see [Deleting the Last Record on the Last Page from a GridView with Custom Paging](http://scottonwriting.net/sowblog/posts/7326.aspx) for the low-level details as to the source of this problem.</span></span> <span data-ttu-id="95430-333">在摘要中它由于以下一系列步骤，单击删除按钮时执行的 GridView 的 s:</span><span class="sxs-lookup"><span data-stu-id="95430-333">In summary it s due to the following sequence of steps that are performed by the GridView when the Delete button is clicked:</span></span>

1. <span data-ttu-id="95430-334">删除的记录</span><span class="sxs-lookup"><span data-stu-id="95430-334">Delete the record</span></span>
2. <span data-ttu-id="95430-335">获取相应的记录，以显示指定`PageIndex`和 `PageSize`</span><span class="sxs-lookup"><span data-stu-id="95430-335">Get the appropriate records to display for the specified `PageIndex` and `PageSize`</span></span>
3. <span data-ttu-id="95430-336">检查以确保`PageIndex`不超出数据源; 中的数据的页数，如果它存在，自动递减 GridView 的`PageIndex`属性</span><span class="sxs-lookup"><span data-stu-id="95430-336">Check to ensure that the `PageIndex` does not exceed the number of pages of data in the data source; if it does, automatically decrement the GridView s `PageIndex` property</span></span>
4. <span data-ttu-id="95430-337">绑定到 GridView 使用在步骤 2 中获取的记录的数据的相应页</span><span class="sxs-lookup"><span data-stu-id="95430-337">Bind the appropriate page of data to the GridView using the records obtained in Step 2</span></span>

<span data-ttu-id="95430-338">此问题的根源，在步骤 2`PageIndex`时获取要显示的记录仍是使用`PageIndex`只删除其唯一记录的最后一页。</span><span class="sxs-lookup"><span data-stu-id="95430-338">The problem stems from the fact that in Step 2 the `PageIndex` used when grabbing the records to display is still the `PageIndex` of the last page whose sole record was just deleted.</span></span> <span data-ttu-id="95430-339">因此，在步骤 2*没有*将返回的记录，因为数据的最后一页不再包含任何记录。</span><span class="sxs-lookup"><span data-stu-id="95430-339">Therefore, in Step 2, *no* records are returned since that last page of data no longer contains any records.</span></span> <span data-ttu-id="95430-340">然后，在步骤 3 中，GridView 认识到，其`PageIndex`属性大于数据源中的页的总数 （因为我们已删除的最后一页中的最后一个记录） 并因此减少其`PageIndex`属性。</span><span class="sxs-lookup"><span data-stu-id="95430-340">Then, in Step 3, the GridView realizes that its `PageIndex` property is greater than the total number of pages in the data source (since we ve deleted the last record in the last page) and therefore decrements its `PageIndex` property.</span></span> <span data-ttu-id="95430-341">在步骤 4 中 GridView 尝试将其本身绑定到在步骤 2 中; 检索到的数据但是，在步骤 2 中不返回任何记录，因此导致空 GridView。</span><span class="sxs-lookup"><span data-stu-id="95430-341">In Step 4 the GridView attempts to bind itself to the data retrieved in Step 2; however, in Step 2 no records were returned, therefore resulting in an empty GridView.</span></span> <span data-ttu-id="95430-342">使用默认的分页，此问题不是 t surface 因为在步骤 2 中*所有*从数据源中检索记录。</span><span class="sxs-lookup"><span data-stu-id="95430-342">With default paging, this problem doesn t surface because in Step 2 *all* records are retrieved from the data source.</span></span>

<span data-ttu-id="95430-343">若要解决此问题，我们有两个选项。</span><span class="sxs-lookup"><span data-stu-id="95430-343">To fix this we have two options.</span></span> <span data-ttu-id="95430-344">第一个步骤是创建事件处理程序的 GridView s`RowDeleted`确定只需删除的页中显示多少条记录的事件处理程序。</span><span class="sxs-lookup"><span data-stu-id="95430-344">The first is to create an event handler for the GridView s `RowDeleted` event handler that determines how many records were displayed in the page that was just deleted.</span></span> <span data-ttu-id="95430-345">如果出现只有一条记录，则只需删除的记录必须被最后一个，我们需要递减 GridView 的`PageIndex`。</span><span class="sxs-lookup"><span data-stu-id="95430-345">If there was only one record, then the record just deleted must have been the last one and we need to decrement the GridView s `PageIndex`.</span></span> <span data-ttu-id="95430-346">当然，我们只想更新`PageIndex`如果删除操作是否实际成功，这可以确定通过确保`e.Exception`属性是`null`。</span><span class="sxs-lookup"><span data-stu-id="95430-346">Of course, we only want to update the `PageIndex` if the delete operation was actually successful, which can be determined by ensuring that the `e.Exception` property is `null`.</span></span>

<span data-ttu-id="95430-347">这种方法有效，因为它会更新`PageIndex`步骤 1 之后但在步骤 2 之前。</span><span class="sxs-lookup"><span data-stu-id="95430-347">This approach works because it updates the `PageIndex` after Step 1 but before Step 2.</span></span> <span data-ttu-id="95430-348">因此，在步骤 2 中，相应的记录集将返回。</span><span class="sxs-lookup"><span data-stu-id="95430-348">Therefore, in Step 2, the appropriate set of records is returned.</span></span> <span data-ttu-id="95430-349">若要实现此目的，使用以下代码：</span><span class="sxs-lookup"><span data-stu-id="95430-349">To accomplish this, use code like the following:</span></span>


[!code-vb[Main](efficiently-paging-through-large-amounts-of-data-vb/samples/sample11.vb)]

<span data-ttu-id="95430-350">备用解决方法是创建事件处理程序的 ObjectDataSource s`RowDeleted`事件，以及设置`AffectedRows`属性的值为 1。</span><span class="sxs-lookup"><span data-stu-id="95430-350">An alternative workaround is to create an event handler for the ObjectDataSource s `RowDeleted` event and to set the `AffectedRows` property to a value of 1.</span></span> <span data-ttu-id="95430-351">删除在步骤 1 中 （但之前重新检索在步骤 2 中的数据） 的记录后, GridView 更新其`PageIndex`属性，如果一个或多个行受影响的操作。</span><span class="sxs-lookup"><span data-stu-id="95430-351">After deleting the record in Step 1 (but before re-retrieving the data in Step 2), the GridView updates its `PageIndex` property if one or more rows were affected by the operation.</span></span> <span data-ttu-id="95430-352">但是， `AffectedRows` ObjectDataSource 通过不设置属性，因此忽略此步骤。</span><span class="sxs-lookup"><span data-stu-id="95430-352">However, the `AffectedRows` property is not set by the ObjectDataSource and therefore this step is omitted.</span></span> <span data-ttu-id="95430-353">具有执行此步骤的一种方法是手动设置`AffectedRows`属性如果删除操作成功完成。</span><span class="sxs-lookup"><span data-stu-id="95430-353">One way to have this step executed is to manually set the `AffectedRows` property if the delete operation completes successfully.</span></span> <span data-ttu-id="95430-354">可以使用如下所示的代码完成此：</span><span class="sxs-lookup"><span data-stu-id="95430-354">This can be accomplished using code like the following:</span></span>


[!code-vb[Main](efficiently-paging-through-large-amounts-of-data-vb/samples/sample12.vb)]

<span data-ttu-id="95430-355">这两个这些事件处理程序的代码可在代码隐藏类的`EfficientPaging.aspx`示例。</span><span class="sxs-lookup"><span data-stu-id="95430-355">The code for both of these events handlers can be found in code-behind class of the `EfficientPaging.aspx` example.</span></span>

## <a name="comparing-the-performance-of-default-and-custom-paging"></a><span data-ttu-id="95430-356">默认和自定义分页的性能比较</span><span class="sxs-lookup"><span data-stu-id="95430-356">Comparing the Performance of Default and Custom Paging</span></span>

<span data-ttu-id="95430-357">由于自定义分页仅检索所需的记录，而返回默认的分页*所有*的每个页面，查看记录它 s 清除自定义分页，比默认的分页更有效。</span><span class="sxs-lookup"><span data-stu-id="95430-357">Since custom paging only retrieves the needed records, whereas default paging returns *all* of the records for each page being viewed, it s clear that custom paging is more efficient than default paging.</span></span> <span data-ttu-id="95430-358">但只是如何更高效是自定义分页？</span><span class="sxs-lookup"><span data-stu-id="95430-358">But just how much more efficient is custom paging?</span></span> <span data-ttu-id="95430-359">通过将从默认的分页移到自定义分页，可以查看哪种提高性能？</span><span class="sxs-lookup"><span data-stu-id="95430-359">What sort of performance gains can be seen by moving from default paging to custom paging?</span></span>

<span data-ttu-id="95430-360">遗憾的是，有 s 没有一种款式满足所有在此处回答。</span><span class="sxs-lookup"><span data-stu-id="95430-360">Unfortunately, there s no one size fits all answer here.</span></span> <span data-ttu-id="95430-361">性能提升取决于多种因素，最突出两人是正在通过用寻呼发送的记录和负载的数字置于 web 服务器和数据库服务器之间的数据库服务器和通信通道。</span><span class="sxs-lookup"><span data-stu-id="95430-361">The performance gain depends on a number of factors, the most prominent two being the number of records being paged through and the load placed on the database server and communication channels between the web server and database server.</span></span> <span data-ttu-id="95430-362">对于包含少量几十个记录的小型表，性能差异可能可以忽略不计。</span><span class="sxs-lookup"><span data-stu-id="95430-362">For small tables with just a few dozen records, the performance difference may be negligible.</span></span> <span data-ttu-id="95430-363">但是，对于大型表，具有数千个到成千上万的行，性能差异是很严重的。</span><span class="sxs-lookup"><span data-stu-id="95430-363">For large tables, with thousands to hundreds of thousands of rows, though, the performance difference is acute.</span></span>

<span data-ttu-id="95430-364">我的项目[ASP.NET 2.0 与 SQL Server 2005 中的自定义分页](http://aspnet.4guysfromrolla.com/articles/031506-1.aspx)，包含一些性能测试，我运行来表现出这两种分页方法时分页通过与数据库表之间的性能差异50,000 个记录。</span><span class="sxs-lookup"><span data-stu-id="95430-364">An article of mine, [Custom Paging in ASP.NET 2.0 with SQL Server 2005](http://aspnet.4guysfromrolla.com/articles/031506-1.aspx), contains some performance tests I ran to exhibit the differences in performance between these two paging techniques when paging through a database table with 50,000 records.</span></span> <span data-ttu-id="95430-365">在这些测试中，我研究了这两个时间来执行 SQL Server 级别的查询 (使用[SQL Profiler](https://msdn.microsoft.com/library/ms173757.aspx)) 并在 ASP.NET 页使用[ASP.NET 的跟踪功能](https://msdn.microsoft.com/library/y13fw6we.aspx)。</span><span class="sxs-lookup"><span data-stu-id="95430-365">In these tests I examined both the time to execute the query at the SQL Server level (using [SQL Profiler](https://msdn.microsoft.com/library/ms173757.aspx)) and at the ASP.NET page using [ASP.NET s tracing features](https://msdn.microsoft.com/library/y13fw6we.aspx).</span></span> <span data-ttu-id="95430-366">请记住，这些测试是在单个活动用户，我开发机器上运行，并因此是一百和不模拟典型网站的负载模式。</span><span class="sxs-lookup"><span data-stu-id="95430-366">Keep in mind that these tests were run on my development box with a single active user, and therefore are unscientific and do not mimic typical website load patterns.</span></span> <span data-ttu-id="95430-367">无论如何，结果说明了执行时间的默认实例和自定义分页的相对差异时使用足够大量的数据。</span><span class="sxs-lookup"><span data-stu-id="95430-367">Regardless, the results illustrate the relative differences in execution time for default and custom paging when working with sufficiently large amounts of data.</span></span>


|  | <span data-ttu-id="95430-368">**Avg.持续时间 （秒）**</span><span class="sxs-lookup"><span data-stu-id="95430-368">**Avg. Duration (sec)**</span></span> | <span data-ttu-id="95430-369">**读取次数**</span><span class="sxs-lookup"><span data-stu-id="95430-369">**Reads**</span></span> |
| --- | --- | --- |
| <span data-ttu-id="95430-370">**默认分页 SQL Profiler**</span><span class="sxs-lookup"><span data-stu-id="95430-370">**Default Paging SQL Profiler**</span></span> | <span data-ttu-id="95430-371">1.411</span><span class="sxs-lookup"><span data-stu-id="95430-371">1.411</span></span> | <span data-ttu-id="95430-372">383</span><span class="sxs-lookup"><span data-stu-id="95430-372">383</span></span> |
| <span data-ttu-id="95430-373">**自定义分页 SQL Profiler**</span><span class="sxs-lookup"><span data-stu-id="95430-373">**Custom Paging SQL Profiler**</span></span> | <span data-ttu-id="95430-374">0.002</span><span class="sxs-lookup"><span data-stu-id="95430-374">0.002</span></span> | <span data-ttu-id="95430-375">29</span><span class="sxs-lookup"><span data-stu-id="95430-375">29</span></span> |
| <span data-ttu-id="95430-376">**默认分页 ASP.NET 跟踪**</span><span class="sxs-lookup"><span data-stu-id="95430-376">**Default Paging ASP.NET Trace**</span></span> | <span data-ttu-id="95430-377">2.379</span><span class="sxs-lookup"><span data-stu-id="95430-377">2.379</span></span> | <span data-ttu-id="95430-378">*N/A*</span><span class="sxs-lookup"><span data-stu-id="95430-378">*N/A*</span></span> |
| <span data-ttu-id="95430-379">**自定义分页 ASP.NET 跟踪**</span><span class="sxs-lookup"><span data-stu-id="95430-379">**Custom Paging ASP.NET Trace**</span></span> | <span data-ttu-id="95430-380">0.029</span><span class="sxs-lookup"><span data-stu-id="95430-380">0.029</span></span> | <span data-ttu-id="95430-381">*N/A*</span><span class="sxs-lookup"><span data-stu-id="95430-381">*N/A*</span></span> |


<span data-ttu-id="95430-382">正如您所看到的检索数据的特定页所需数量累计为 354 小于读取的平均和中所花时间完成。</span><span class="sxs-lookup"><span data-stu-id="95430-382">As you can see, retrieving a particular page of data required 354 less reads on average and completed in a fraction of the time.</span></span> <span data-ttu-id="95430-383">在 ASP.NET 页上，自定义的页面是能够接近于 1/100 中呈现<sup>th</sup>花费的时间使用默认的分页时。</span><span class="sxs-lookup"><span data-stu-id="95430-383">At the ASP.NET page, custom the page was able to render in close to 1/100<sup>th</sup> of the time it took when using default paging.</span></span> <span data-ttu-id="95430-384">请参阅[我的文章](http://aspnet.4guysfromrolla.com/articles/031506-1.aspx)对于这些结果与代码和数据库的详细信息，可以下载重现您自己的环境中的这些测试。</span><span class="sxs-lookup"><span data-stu-id="95430-384">See [my article](http://aspnet.4guysfromrolla.com/articles/031506-1.aspx) for more information on these results along with code and a database you can download to reproduce these tests in your own environment.</span></span>

## <a name="summary"></a><span data-ttu-id="95430-385">总结</span><span class="sxs-lookup"><span data-stu-id="95430-385">Summary</span></span>

<span data-ttu-id="95430-386">默认分页很容易做到在数据 Web 控件 s 智能标记中实现只是检查启用分页复选框，但此类简单起见，但代价是性能。</span><span class="sxs-lookup"><span data-stu-id="95430-386">Default paging is a cinch to implement just check the Enable Paging checkbox in the data Web control s smart tag but such simplicity comes at the cost of performance.</span></span> <span data-ttu-id="95430-387">使用默认分页，当用户请求数据的任何页*所有*返回记录，即使仅极小一部分它们可能会显示。</span><span class="sxs-lookup"><span data-stu-id="95430-387">With default paging, when a user requests any page of data *all* records are returned, even though only a tiny fraction of them may be shown.</span></span> <span data-ttu-id="95430-388">为了应对这项性能开销，ObjectDataSource 提供了可选的分页选项自定义分页。</span><span class="sxs-lookup"><span data-stu-id="95430-388">To combat this performance overhead, the ObjectDataSource offers an alternative paging option custom paging.</span></span>

<span data-ttu-id="95430-389">尽管在默认通过检索需要显示，这些记录分页 s 性能问题时改进了自定义分页它更为复杂，若要实现自定义分页的 s。</span><span class="sxs-lookup"><span data-stu-id="95430-389">While custom paging improves upon default paging s performance issues by retrieving only those records that need to be displayed, it s more involved to implement custom paging.</span></span> <span data-ttu-id="95430-390">首先，必须正确 （有效地） 访问所请求的记录的特定子集编写查询。</span><span class="sxs-lookup"><span data-stu-id="95430-390">First, a query must be written that correctly (and efficiently) accesses the specific subset of records requested.</span></span> <span data-ttu-id="95430-391">这可以实现多种方式;在本教程中，我们探讨的一个是使用 SQL Server 2005 s 新`ROW_NUMBER()`排名的函数的结果，，并返回只是那些结果的排名处于指定范围内。</span><span class="sxs-lookup"><span data-stu-id="95430-391">This can be accomplished in a number of ways; the one we examined in this tutorial is to use SQL Server 2005 s new `ROW_NUMBER()` function to rank results, and then to return just those results whose ranking falls within a specified range.</span></span> <span data-ttu-id="95430-392">此外，我们需要添加一种方法来确定正在通过用寻呼发送的记录总数。</span><span class="sxs-lookup"><span data-stu-id="95430-392">Furthermore, we need to add a means to determine the total number of records being paged through.</span></span> <span data-ttu-id="95430-393">在创建后这些 DAL 和 BLL 方法，我们还需要配置对象数据源，以便它可以确定总记录数将被分页通过以及正确传递给 BLL 的起始行索引和最大行数的值。</span><span class="sxs-lookup"><span data-stu-id="95430-393">After creating these DAL and BLL methods, we also need to configure the ObjectDataSource so that it can determine how many total records are being paged through and can correctly pass the Start Row Index and Maximum Rows values to the BLL.</span></span>

<span data-ttu-id="95430-394">实现自定义分页确实需要多个步骤，并与默认的分页不几乎一样简单，而自定义分页是必不可少的分页的数据量足够大时。</span><span class="sxs-lookup"><span data-stu-id="95430-394">While implementing custom paging does require a number of steps and is not nearly as simple as default paging, custom paging is a necessity when paging through sufficiently large amounts of data.</span></span> <span data-ttu-id="95430-395">结果检查作为显示的自定义分页可以减轻秒从 ASP.NET 页呈现时间，并可由一个或多个数量级淡化数据库服务器上的负载。</span><span class="sxs-lookup"><span data-stu-id="95430-395">As the results examined showed, custom paging can shed seconds off of the ASP.NET page render time and can lighten the load on the database server by one ore more orders of magnitude.</span></span>

<span data-ttu-id="95430-396">快乐编程 ！</span><span class="sxs-lookup"><span data-stu-id="95430-396">Happy Programming!</span></span>

## <a name="about-the-author"></a><span data-ttu-id="95430-397">关于作者</span><span class="sxs-lookup"><span data-stu-id="95430-397">About the Author</span></span>

<span data-ttu-id="95430-398">[Scott Mitchell](http://www.4guysfromrolla.com/ScottMitchell.shtml)的七个部 asp/ASP.NET 书籍并创办了作者[4GuysFromRolla.com](http://www.4guysfromrolla.com)，自 1998 年以来一直致力于 Microsoft Web 技术。</span><span class="sxs-lookup"><span data-stu-id="95430-398">[Scott Mitchell](http://www.4guysfromrolla.com/ScottMitchell.shtml), author of seven ASP/ASP.NET books and founder of [4GuysFromRolla.com](http://www.4guysfromrolla.com), has been working with Microsoft Web technologies since 1998.</span></span> <span data-ttu-id="95430-399">Scott 是独立的顾问、 培训师和编写器。</span><span class="sxs-lookup"><span data-stu-id="95430-399">Scott works as an independent consultant, trainer, and writer.</span></span> <span data-ttu-id="95430-400">他最新著作是[ *Sams Teach 自己 ASP.NET 2.0 24 小时内*](https://www.amazon.com/exec/obidos/ASIN/0672327384/4guysfromrollaco)。</span><span class="sxs-lookup"><span data-stu-id="95430-400">His latest book is [*Sams Teach Yourself ASP.NET 2.0 in 24 Hours*](https://www.amazon.com/exec/obidos/ASIN/0672327384/4guysfromrollaco).</span></span> <span data-ttu-id="95430-401">他可以到达[ mitchell@4GuysFromRolla.com。](mailto:mitchell@4GuysFromRolla.com)</span><span class="sxs-lookup"><span data-stu-id="95430-401">He can be reached at [mitchell@4GuysFromRolla.com.](mailto:mitchell@4GuysFromRolla.com)</span></span> <span data-ttu-id="95430-402">或通过他的博客，其中，请参阅[ http://ScottOnWriting.NET ](http://ScottOnWriting.NET)。</span><span class="sxs-lookup"><span data-stu-id="95430-402">or via his blog, which can be found at [http://ScottOnWriting.NET](http://ScottOnWriting.NET).</span></span>

> [!div class="step-by-step"]
> <span data-ttu-id="95430-403">[上一页](paging-and-sorting-report-data-vb.md)
> [下一页](sorting-custom-paged-data-vb.md)</span><span class="sxs-lookup"><span data-stu-id="95430-403">[Previous](paging-and-sorting-report-data-vb.md)
[Next](sorting-custom-paged-data-vb.md)</span></span>
