---
uid: web-forms/overview/data-access/displaying-data-with-the-datalist-and-repeater/nested-data-web-controls-cs
title: 嵌套的数据 Web 控件 (C#) |Microsoft Docs
author: rick-anderson
description: 在本教程中我们将探讨如何使用 Repeater 嵌套在另一个 Repeater。 这些示例将演示了如何以填充内部 Repeater 这两个 d...
ms.author: aspnetcontent
ms.date: 09/13/2006
ms.assetid: ad3cb0ec-26cf-42d7-b81b-184a34ec9f86
msc.legacyurl: /web-forms/overview/data-access/displaying-data-with-the-datalist-and-repeater/nested-data-web-controls-cs
msc.type: authoredcontent
ms.openlocfilehash: bed7d3772d86b897cafc38a424723da6adf08f97
ms.sourcegitcommit: b28cd0313af316c051c2ff8549865bff67f2fbb4
ms.translationtype: MT
ms.contentlocale: zh-CN
ms.lasthandoff: 07/05/2018
ms.locfileid: "37839378"
---
<a name="nested-data-web-controls-c"></a><span data-ttu-id="bfc76-104">嵌套的数据 Web 控件 (C#)</span><span class="sxs-lookup"><span data-stu-id="bfc76-104">Nested Data Web Controls (C#)</span></span>
====================
<span data-ttu-id="bfc76-105">通过[Scott Mitchell](https://twitter.com/ScottOnWriting)</span><span class="sxs-lookup"><span data-stu-id="bfc76-105">by [Scott Mitchell](https://twitter.com/ScottOnWriting)</span></span>

<span data-ttu-id="bfc76-106">[下载示例应用程序](http://download.microsoft.com/download/9/c/1/9c1d03ee-29ba-4d58-aa1a-f201dcc822ea/ASPNET_Data_Tutorial_32_CS.exe)或[下载 PDF](nested-data-web-controls-cs/_static/datatutorial32cs1.pdf)</span><span class="sxs-lookup"><span data-stu-id="bfc76-106">[Download Sample App](http://download.microsoft.com/download/9/c/1/9c1d03ee-29ba-4d58-aa1a-f201dcc822ea/ASPNET_Data_Tutorial_32_CS.exe) or [Download PDF](nested-data-web-controls-cs/_static/datatutorial32cs1.pdf)</span></span>

> <span data-ttu-id="bfc76-107">在本教程中我们将探讨如何使用 Repeater 嵌套在另一个 Repeater。</span><span class="sxs-lookup"><span data-stu-id="bfc76-107">In this tutorial we will explore how to use a Repeater nested inside another Repeater.</span></span> <span data-ttu-id="bfc76-108">这些示例将演示了如何以声明方式和以编程方式填充内部 Repeater。</span><span class="sxs-lookup"><span data-stu-id="bfc76-108">The examples will illustrate how to populate the inner Repeater both declaratively and programmatically.</span></span>


## <a name="introduction"></a><span data-ttu-id="bfc76-109">介绍</span><span class="sxs-lookup"><span data-stu-id="bfc76-109">Introduction</span></span>

<span data-ttu-id="bfc76-110">除了静态 HTML 和数据绑定语法，模板还可包含 Web 控件和用户控件。</span><span class="sxs-lookup"><span data-stu-id="bfc76-110">In addition to static HTML and databinding syntax, templates can also include Web controls and User Controls.</span></span> <span data-ttu-id="bfc76-111">这些 Web 控件可以有其属性分配通过声明性数据绑定语法，或可以在相应的服务器端事件处理程序中以编程方式访问。</span><span class="sxs-lookup"><span data-stu-id="bfc76-111">These Web controls can have their properties assigned via declarative, databinding syntax, or can be accessed programmatically in the appropriate server-side event handlers.</span></span>

<span data-ttu-id="bfc76-112">通过嵌入在模板中的控件，可自定义和改进的外观和用户体验。</span><span class="sxs-lookup"><span data-stu-id="bfc76-112">By embedding controls within a template, the appearance and user experience can be customized and improved upon.</span></span> <span data-ttu-id="bfc76-113">例如，在[GridView 控件中使用 Templatefield](../custom-formatting/using-templatefields-in-the-gridview-control-cs.md)教程中，我们已了解如何通过在 TemplateField 来显示雇员的雇佣日期; 中添加一个日历控件自定义 GridView 的显示[添加验证控件的编辑和插入接口](../editing-inserting-and-deleting-data/adding-validation-controls-to-the-editing-and-inserting-interfaces-cs.md)并[自定义数据修改界面](../editing-inserting-and-deleting-data/customizing-the-data-modification-interface-cs.md)教程，我们已了解如何自定义的编辑和插入界面添加验证控件、 文本框、 Dropdownlist 和其他 Web 控件。</span><span class="sxs-lookup"><span data-stu-id="bfc76-113">For example, in the [Using TemplateFields in the GridView Control](../custom-formatting/using-templatefields-in-the-gridview-control-cs.md) tutorial, we saw how to customize the GridView s display by adding a Calendar control in a TemplateField to show an employee s hire date; in the [Adding Validation Controls to the Editing and Inserting Interfaces](../editing-inserting-and-deleting-data/adding-validation-controls-to-the-editing-and-inserting-interfaces-cs.md) and [Customizing the Data Modification Interface](../editing-inserting-and-deleting-data/customizing-the-data-modification-interface-cs.md) tutorials, we saw how to customize the editing and inserting interfaces by adding validation controls, TextBoxes, DropDownLists, and other Web controls.</span></span>

<span data-ttu-id="bfc76-114">模板还可以包含其他数据 Web 控件。</span><span class="sxs-lookup"><span data-stu-id="bfc76-114">Templates can also contain other data Web controls.</span></span> <span data-ttu-id="bfc76-115">也就是说，我们可以让其模板中包含另一个 DataList （或转发器或 GridView 或 DetailsView，等等） DataList。</span><span class="sxs-lookup"><span data-stu-id="bfc76-115">That is, we can have a DataList that contains another DataList (or Repeater or GridView or DetailsView, and so on) within its templates.</span></span> <span data-ttu-id="bfc76-116">此类接口的挑战适当的数据绑定到的内部数据 Web 控件。</span><span class="sxs-lookup"><span data-stu-id="bfc76-116">The challenge with such an interface is binding the appropriate data to the inner data Web control.</span></span> <span data-ttu-id="bfc76-117">有几个不同的方法可用，范围为从使用于编程的 ObjectDataSource 的声明性选项。</span><span class="sxs-lookup"><span data-stu-id="bfc76-117">There are a few different approaches available, ranging from declarative options using the ObjectDataSource to programmatic ones.</span></span>

<span data-ttu-id="bfc76-118">在本教程中我们将探讨如何使用 Repeater 嵌套在另一个 Repeater。</span><span class="sxs-lookup"><span data-stu-id="bfc76-118">In this tutorial we will explore how to use a Repeater nested inside another Repeater.</span></span> <span data-ttu-id="bfc76-119">外部 Repeater 将包含在数据库中，每个类别的项显示类别名称和说明。</span><span class="sxs-lookup"><span data-stu-id="bfc76-119">The outer Repeater will contain an item for each category in the database, displaying the category s name and description.</span></span> <span data-ttu-id="bfc76-120">每个类别项 s 内部 Repeater 将显示属于该类别的每个产品的信息 （请参阅图 1） 中的项目符号列表。</span><span class="sxs-lookup"><span data-stu-id="bfc76-120">Each category item s inner Repeater will display information for each product belonging to that category (see Figure 1) in a bulleted list.</span></span> <span data-ttu-id="bfc76-121">我们的示例将演示了如何以声明方式和以编程方式填充内部 Repeater。</span><span class="sxs-lookup"><span data-stu-id="bfc76-121">Our examples will illustrate how to populate the inner Repeater both declaratively and programmatically.</span></span>


<span data-ttu-id="bfc76-122">[![列出每个类别，以及其产品，](nested-data-web-controls-cs/_static/image2.png)](nested-data-web-controls-cs/_static/image1.png)</span><span class="sxs-lookup"><span data-stu-id="bfc76-122">[![Each Category, Along with its Products, are Listed](nested-data-web-controls-cs/_static/image2.png)](nested-data-web-controls-cs/_static/image1.png)</span></span>

<span data-ttu-id="bfc76-123">**图 1**： 列出每个类别，以及其产品，([单击以查看实际尺寸的图像](nested-data-web-controls-cs/_static/image3.png))</span><span class="sxs-lookup"><span data-stu-id="bfc76-123">**Figure 1**: Each Category, Along with its Products, are Listed ([Click to view full-size image](nested-data-web-controls-cs/_static/image3.png))</span></span>


## <a name="step-1-creating-the-category-listing"></a><span data-ttu-id="bfc76-124">步骤 1： 创建的类别列表</span><span class="sxs-lookup"><span data-stu-id="bfc76-124">Step 1: Creating the Category Listing</span></span>

<span data-ttu-id="bfc76-125">当生成使用嵌套数据 Web 控件时，我发现非常有用的设计、 创建和测试最外面的数据 Web 控件第一次，而无需担心内部嵌套的控件甚至。</span><span class="sxs-lookup"><span data-stu-id="bfc76-125">When building a page that uses nested data Web controls, I find it helpful to design, create, and test the outermost data Web control first, without even worrying about the inner nested control.</span></span> <span data-ttu-id="bfc76-126">因此，让我们来开始将 Repeater 添加到列表的名称和每个类别的说明页所需的步骤执行每个步骤。</span><span class="sxs-lookup"><span data-stu-id="bfc76-126">Therefore, let s start by walking through the steps necessary to add a Repeater to the page that lists the name and description for each category.</span></span>

<span data-ttu-id="bfc76-127">首先打开`NestedControls.aspx`页中`DataListRepeaterBasics`文件夹并将 Repeater 控件添加到页上，设置其`ID`属性设置为`CategoryList`。</span><span class="sxs-lookup"><span data-stu-id="bfc76-127">Start by opening the `NestedControls.aspx` page in the `DataListRepeaterBasics` folder and add a Repeater control to the page, setting its `ID` property to `CategoryList`.</span></span> <span data-ttu-id="bfc76-128">从 Repeater s 智能标记中，选择创建名为新 ObjectDataSource `CategoriesDataSource`。</span><span class="sxs-lookup"><span data-stu-id="bfc76-128">From the Repeater s smart tag, choose to create a new ObjectDataSource named `CategoriesDataSource`.</span></span>


<span data-ttu-id="bfc76-129">[![命名新 ObjectDataSource CategoriesDataSource](nested-data-web-controls-cs/_static/image5.png)](nested-data-web-controls-cs/_static/image4.png)</span><span class="sxs-lookup"><span data-stu-id="bfc76-129">[![Name the New ObjectDataSource CategoriesDataSource](nested-data-web-controls-cs/_static/image5.png)](nested-data-web-controls-cs/_static/image4.png)</span></span>

<span data-ttu-id="bfc76-130">**图 2**： 命名新 ObjectDataSource `CategoriesDataSource` ([单击以查看实际尺寸的图像](nested-data-web-controls-cs/_static/image6.png))</span><span class="sxs-lookup"><span data-stu-id="bfc76-130">**Figure 2**: Name the New ObjectDataSource `CategoriesDataSource` ([Click to view full-size image](nested-data-web-controls-cs/_static/image6.png))</span></span>


<span data-ttu-id="bfc76-131">以便它将从其数据配置 ObjectDataSource`CategoriesBLL`类的`GetCategories`方法。</span><span class="sxs-lookup"><span data-stu-id="bfc76-131">Configure the ObjectDataSource so that it pulls its data from the `CategoriesBLL` class s `GetCategories` method.</span></span>


<span data-ttu-id="bfc76-132">[![配置对象数据源使用 CategoriesBLL 类的 GetCategories 方法](nested-data-web-controls-cs/_static/image8.png)](nested-data-web-controls-cs/_static/image7.png)</span><span class="sxs-lookup"><span data-stu-id="bfc76-132">[![Configure the ObjectDataSource to Use the CategoriesBLL Class s GetCategories Method](nested-data-web-controls-cs/_static/image8.png)](nested-data-web-controls-cs/_static/image7.png)</span></span>

<span data-ttu-id="bfc76-133">**图 3**： 配置为使用 ObjectDataSource`CategoriesBLL`类 s`GetCategories`方法 ([单击以查看实际尺寸的图像](nested-data-web-controls-cs/_static/image9.png))</span><span class="sxs-lookup"><span data-stu-id="bfc76-133">**Figure 3**: Configure the ObjectDataSource to Use the `CategoriesBLL` Class s `GetCategories` Method ([Click to view full-size image](nested-data-web-controls-cs/_static/image9.png))</span></span>


<span data-ttu-id="bfc76-134">若要指定 Repeater 的模板内容需要转到源视图并手动输入的声明性语法。</span><span class="sxs-lookup"><span data-stu-id="bfc76-134">To specify the Repeater s template content we need to go to the Source view and manually enter the declarative syntax.</span></span> <span data-ttu-id="bfc76-135">添加`ItemTemplate`，它显示在类别的名称`<h4>`元素和一个段落元素中的类别的说明 (`<p>`)。</span><span class="sxs-lookup"><span data-stu-id="bfc76-135">Add an `ItemTemplate` that displays the category s name in an `<h4>` element and the category s description in a paragraph element (`<p>`).</span></span> <span data-ttu-id="bfc76-136">此外，let s 用水平标尺分隔每个类别 (`<hr>`)。</span><span class="sxs-lookup"><span data-stu-id="bfc76-136">Furthermore, let s separate each category with a horizontal rule (`<hr>`).</span></span> <span data-ttu-id="bfc76-137">进行这些更改后您的页面应包含用于 Repeater 和类似于以下的 ObjectDataSource 声明性语法：</span><span class="sxs-lookup"><span data-stu-id="bfc76-137">After making these changes your page should contain declarative syntax for the Repeater and ObjectDataSource that is similar to the following:</span></span>


[!code-aspx[Main](nested-data-web-controls-cs/samples/sample1.aspx)]

<span data-ttu-id="bfc76-138">图 4 显示了我们的浏览器查看时的进度。</span><span class="sxs-lookup"><span data-stu-id="bfc76-138">Figure 4 shows our progress when viewed through a browser.</span></span>


<span data-ttu-id="bfc76-139">[![每个类别名称和描述列出，则分隔水平标尺](nested-data-web-controls-cs/_static/image11.png)](nested-data-web-controls-cs/_static/image10.png)</span><span class="sxs-lookup"><span data-stu-id="bfc76-139">[![Each Category s Name and Description is Listed, Separated by a Horizontal Rule](nested-data-web-controls-cs/_static/image11.png)](nested-data-web-controls-cs/_static/image10.png)</span></span>

<span data-ttu-id="bfc76-140">**图 4**： 每个类别的名称和描述列出，则用水平标尺分隔 ([单击以查看实际尺寸的图像](nested-data-web-controls-cs/_static/image12.png))</span><span class="sxs-lookup"><span data-stu-id="bfc76-140">**Figure 4**: Each Category s Name and Description is Listed, Separated by a Horizontal Rule ([Click to view full-size image](nested-data-web-controls-cs/_static/image12.png))</span></span>


## <a name="step-2-adding-the-nested-product-repeater"></a><span data-ttu-id="bfc76-141">步骤 2： 添加嵌套的产品 Repeater</span><span class="sxs-lookup"><span data-stu-id="bfc76-141">Step 2: Adding the Nested Product Repeater</span></span>

<span data-ttu-id="bfc76-142">列出完整的类别，与我们的下一个任务是将添加到 Repeater `CategoryList` s`ItemTemplate`显示有关这些产品属于相应的类别的信息。</span><span class="sxs-lookup"><span data-stu-id="bfc76-142">With the category listing complete, our next task is to add a Repeater to the `CategoryList` s `ItemTemplate` that displays information about those products belonging to the appropriate category.</span></span> <span data-ttu-id="bfc76-143">有多种方式，我们可以为此内部 Repeater，其中两个我们很快就会检索数据。</span><span class="sxs-lookup"><span data-stu-id="bfc76-143">There are a number of ways we can retrieve the data for this inner Repeater, two of which we'll explore shortly.</span></span> <span data-ttu-id="bfc76-144">现在，让 s 只需创建产品 Repeater 中`CategoryList`Repeater 的`ItemTemplate`。</span><span class="sxs-lookup"><span data-stu-id="bfc76-144">For now, let s just create the products Repeater within the `CategoryList` Repeater s `ItemTemplate`.</span></span> <span data-ttu-id="bfc76-145">具体而言，让我们来安装产品 Repeater 显示项目符号列表中的每个产品与每个列表项包括产品的名称和价格。</span><span class="sxs-lookup"><span data-stu-id="bfc76-145">Specifically, let s have the product Repeater display each product in a bulleted list with each list item including the product s name and price.</span></span>

<span data-ttu-id="bfc76-146">若要创建我们需要手动输入的内部 Repeater s 声明性语法和模板到此 Repeater `CategoryList` s `ItemTemplate`。</span><span class="sxs-lookup"><span data-stu-id="bfc76-146">To create this Repeater we need to manually enter the inner Repeater s declarative syntax and templates into the `CategoryList` s `ItemTemplate`.</span></span> <span data-ttu-id="bfc76-147">添加以下标记内的`CategoryList`Repeater 的`ItemTemplate`:</span><span class="sxs-lookup"><span data-stu-id="bfc76-147">Add the following markup within the `CategoryList` Repeater s `ItemTemplate`:</span></span>


[!code-aspx[Main](nested-data-web-controls-cs/samples/sample2.aspx)]

## <a name="step-3-binding-the-category-specific-products-to-the-productsbycategorylist-repeater"></a><span data-ttu-id="bfc76-148">步骤 3： 绑定到 ProductsByCategoryList Repeater 的特定于类别的产品</span><span class="sxs-lookup"><span data-stu-id="bfc76-148">Step 3: Binding the Category-Specific Products to the ProductsByCategoryList Repeater</span></span>

<span data-ttu-id="bfc76-149">如果您在这里访问通过浏览器页面，屏幕将显示如图 4 所示相同因为我们尚未将任何数据绑定到 Repeater 的 ve。</span><span class="sxs-lookup"><span data-stu-id="bfc76-149">If you visit the page through a browser at this point, your screen will look the same as in Figure 4 because we ve yet to bind any data to the Repeater.</span></span> <span data-ttu-id="bfc76-150">有几种方法，我们可以获取相应的产品记录并将其绑定到 Repeater，比其他一些更高效。</span><span class="sxs-lookup"><span data-stu-id="bfc76-150">There are a few ways that we can grab the appropriate product records and bind them to the Repeater, some more efficient than others.</span></span> <span data-ttu-id="bfc76-151">此处的主要挑战取回指定类别的相应产品。</span><span class="sxs-lookup"><span data-stu-id="bfc76-151">The main challenge here is getting back the appropriate products for the specified category.</span></span>

<span data-ttu-id="bfc76-152">要将绑定到内部 Repeater 控件的数据可以访问以声明方式，通过在 ObjectDataSource `CategoryList` Repeater 的`ItemTemplate`，或以编程方式，从 ASP.NET 页的代码隐藏页。</span><span class="sxs-lookup"><span data-stu-id="bfc76-152">The data to bind to the inner Repeater control can either be accessed declaratively, through an ObjectDataSource in the `CategoryList` Repeater s `ItemTemplate`, or programmatically, from the ASP.NET page s code-behind page.</span></span> <span data-ttu-id="bfc76-153">同样，此数据可绑定到内部 Repeater 或者以声明方式-通过内部 Repeater s`DataSourceID`属性或通过声明性数据绑定语法或以编程方式通过引用在内部 Repeater `CategoryList` Repeater s`ItemDataBound`事件处理程序，以编程方式设置其`DataSource`属性，并调用其`DataBind()`方法。</span><span class="sxs-lookup"><span data-stu-id="bfc76-153">Similarly, this data can be bound to the inner Repeater either declaratively - through the inner Repeater s `DataSourceID` property or through declarative databinding syntax or programmatically by referencing the inner Repeater in the `CategoryList` Repeater s `ItemDataBound` event handler, programmatically setting its `DataSource` property, and calling its `DataBind()` method.</span></span> <span data-ttu-id="bfc76-154">让我们来探讨每一个这些方法。</span><span class="sxs-lookup"><span data-stu-id="bfc76-154">Let s explore each of these approaches.</span></span>

## <a name="accessing-the-data-declaratively-with-an-objectdatasource-control-and-theitemdataboundevent-handler"></a><span data-ttu-id="bfc76-155">访问数据以声明方式使用 ObjectDataSource 控件和`ItemDataBound`事件处理程序</span><span class="sxs-lookup"><span data-stu-id="bfc76-155">Accessing the Data Declaratively with an ObjectDataSource Control and the`ItemDataBound`Event Handler</span></span>

<span data-ttu-id="bfc76-156">自我们已使用在本系列教程的最适合用于访问数据，此示例中坚持使用 ObjectDataSource 整个广泛 ObjectDataSource。</span><span class="sxs-lookup"><span data-stu-id="bfc76-156">Since we ve used the ObjectDataSource extensively throughout this tutorial series, the most natural choice for accessing data for this example is to stick with the ObjectDataSource.</span></span> <span data-ttu-id="bfc76-157">`ProductsBLL`类具有`GetProductsByCategoryID(categoryID)`方法，它返回有关属于指定这些产品的信息*`categoryID`*。</span><span class="sxs-lookup"><span data-stu-id="bfc76-157">The `ProductsBLL` class has a `GetProductsByCategoryID(categoryID)` method that returns information about those products that belong to the specified *`categoryID`*.</span></span> <span data-ttu-id="bfc76-158">因此，我们可以添加到 ObjectDataSource `CategoryList` Repeater 的`ItemTemplate`并将其配置为从此类的方法访问其数据。</span><span class="sxs-lookup"><span data-stu-id="bfc76-158">Therefore, we can add an ObjectDataSource to the `CategoryList` Repeater s `ItemTemplate` and configure it to access its data from this class s method.</span></span>

<span data-ttu-id="bfc76-159">遗憾的是，Repeater 不允许其模板无法通过设计视图编辑，因此我们需要手动添加此 ObjectDataSource 控件声明性语法。</span><span class="sxs-lookup"><span data-stu-id="bfc76-159">Unfortunately, the Repeater doesn t allow its templates to be edited through the Design view so we need to add the declarative syntax for this ObjectDataSource control by hand.</span></span> <span data-ttu-id="bfc76-160">下面的语法演示`CategoryList`Repeater s`ItemTemplate`后添加此新对象数据源 (`ProductsByCategoryDataSource`):</span><span class="sxs-lookup"><span data-stu-id="bfc76-160">The following syntax shows the `CategoryList` Repeater s `ItemTemplate` after adding this new ObjectDataSource (`ProductsByCategoryDataSource`):</span></span>


[!code-aspx[Main](nested-data-web-controls-cs/samples/sample3.aspx)]

<span data-ttu-id="bfc76-161">使用 ObjectDataSource 方法时，我们需要设置`ProductsByCategoryList`Repeater s`DataSourceID`属性设置为`ID`的 ObjectDataSource (`ProductsByCategoryDataSource`)。</span><span class="sxs-lookup"><span data-stu-id="bfc76-161">When using the ObjectDataSource approach we need to set the `ProductsByCategoryList` Repeater s `DataSourceID` property to the `ID` of the ObjectDataSource (`ProductsByCategoryDataSource`).</span></span> <span data-ttu-id="bfc76-162">另请注意，我们 ObjectDataSource 已`<asp:Parameter>`指定的元素*`categoryID`* 值将传递到`GetProductsByCategoryID(categoryID)`方法。</span><span class="sxs-lookup"><span data-stu-id="bfc76-162">Also, notice that our ObjectDataSource has an `<asp:Parameter>` element that specifies the *`categoryID`* value that will be passed into the `GetProductsByCategoryID(categoryID)` method.</span></span> <span data-ttu-id="bfc76-163">但如何指定此值呢？</span><span class="sxs-lookup"><span data-stu-id="bfc76-163">But how do we specify this value?</span></span> <span data-ttu-id="bfc76-164">理想情况下，我们 d 能够只需将设置`DefaultValue`属性的`<asp:Parameter>`元素使用数据绑定语法如下所示：</span><span class="sxs-lookup"><span data-stu-id="bfc76-164">Ideally, we d be able to just set the `DefaultValue` property of the `<asp:Parameter>` element using databinding syntax, like so:</span></span>


[!code-aspx[Main](nested-data-web-controls-cs/samples/sample4.aspx)]

<span data-ttu-id="bfc76-165">遗憾的是，数据绑定语法才有效中具有控件`DataBinding`事件。</span><span class="sxs-lookup"><span data-stu-id="bfc76-165">Unfortunately, databinding syntax is only valid in controls that have a `DataBinding` event.</span></span> <span data-ttu-id="bfc76-166">`Parameter`类缺少这种情况下，因此上述语法是非法的并将导致运行时错误。</span><span class="sxs-lookup"><span data-stu-id="bfc76-166">The `Parameter` class lacks such an event and therefore the above syntax is illegal and will result in a runtime error.</span></span>

<span data-ttu-id="bfc76-167">若要设置此值，我们需要创建的事件处理程序`CategoryList`Repeater 的`ItemDataBound`事件。</span><span class="sxs-lookup"><span data-stu-id="bfc76-167">To set this value, we need to create an event handler for the `CategoryList` Repeater s `ItemDataBound` event.</span></span> <span data-ttu-id="bfc76-168">请记住，`ItemDataBound`事件触发一次绑定到 Repeater 的每个项。</span><span class="sxs-lookup"><span data-stu-id="bfc76-168">Recall that the `ItemDataBound` event fires once for each item bound to the Repeater.</span></span> <span data-ttu-id="bfc76-169">因此，对于外部 Repeater 将引发此事件每次我们可以分配当前`CategoryID`值设为`ProductsByCategoryDataSource`ObjectDataSource 的`CategoryID`参数。</span><span class="sxs-lookup"><span data-stu-id="bfc76-169">Therefore, each time this event fires for the outer Repeater we can assign the current `CategoryID` value to the `ProductsByCategoryDataSource` ObjectDataSource s `CategoryID` parameter.</span></span>

<span data-ttu-id="bfc76-170">创建事件处理程序`CategoryList`Repeater 的`ItemDataBound`事件使用以下代码：</span><span class="sxs-lookup"><span data-stu-id="bfc76-170">Create an event handler for the `CategoryList` Repeater s `ItemDataBound` event with the following code:</span></span>


[!code-csharp[Main](nested-data-web-controls-cs/samples/sample5.cs)]

<span data-ttu-id="bfc76-171">此事件处理程序首先会确保我们重新处理数据项而不是标头、 页脚或分隔符项。</span><span class="sxs-lookup"><span data-stu-id="bfc76-171">This event handler starts by ensuring that we re dealing with a data item rather than the header, footer, or separator item.</span></span> <span data-ttu-id="bfc76-172">接下来，我们引用的实际`CategoriesRow`只需绑定到当前实例`RepeaterItem`。</span><span class="sxs-lookup"><span data-stu-id="bfc76-172">Next, we reference the actual `CategoriesRow` instance that has just been bound to the current `RepeaterItem`.</span></span> <span data-ttu-id="bfc76-173">最后，我们引用在 ObjectDataSource `ItemTemplate` ，并分配其`CategoryID`参数值为`CategoryID`的当前`RepeaterItem`。</span><span class="sxs-lookup"><span data-stu-id="bfc76-173">Finally, we reference the ObjectDataSource in the `ItemTemplate` and assign its `CategoryID` parameter value to the `CategoryID` of the current `RepeaterItem`.</span></span>

<span data-ttu-id="bfc76-174">与此事件处理程序中， `ProductsByCategoryList` Repeater 中每个`RepeaterItem`绑定到这些产品`RepeaterItem`的类别。</span><span class="sxs-lookup"><span data-stu-id="bfc76-174">With this event handler, the `ProductsByCategoryList` Repeater in each `RepeaterItem` is bound to those products in the `RepeaterItem` s category.</span></span> <span data-ttu-id="bfc76-175">图 5 显示生成的输出的屏幕截图。</span><span class="sxs-lookup"><span data-stu-id="bfc76-175">Figure 5 shows a screen shot of the resulting output.</span></span>


<span data-ttu-id="bfc76-176">[![外部 Repeater 列出了每个类别;内部的一个为该类别中列出的产品](nested-data-web-controls-cs/_static/image14.png)](nested-data-web-controls-cs/_static/image13.png)</span><span class="sxs-lookup"><span data-stu-id="bfc76-176">[![The Outer Repeater Lists Each Category; the Inner One Lists the Products for that Category](nested-data-web-controls-cs/_static/image14.png)](nested-data-web-controls-cs/_static/image13.png)</span></span>

<span data-ttu-id="bfc76-177">**图 5**: 外部 Repeater 列出了每个类别; 内部一个列出该类别的产品 ([单击以查看实际尺寸的图像](nested-data-web-controls-cs/_static/image15.png))</span><span class="sxs-lookup"><span data-stu-id="bfc76-177">**Figure 5**: The Outer Repeater Lists Each Category; the Inner One Lists the Products for that Category ([Click to view full-size image](nested-data-web-controls-cs/_static/image15.png))</span></span>


## <a name="accessing-the-products-by-category-data-programmatically"></a><span data-ttu-id="bfc76-178">以编程方式访问的产品类别数据</span><span class="sxs-lookup"><span data-stu-id="bfc76-178">Accessing the Products by Category Data Programmatically</span></span>

<span data-ttu-id="bfc76-179">而不是使用 ObjectDataSource 来检索当前类别的产品，我们可以在我们的 ASP.NET 页面 + s 代码隐藏类中创建一种方法 (或在`App_Code`文件夹或在单独的类库项目) 返回相应的一组产品中传递时`CategoryID`。</span><span class="sxs-lookup"><span data-stu-id="bfc76-179">Instead of using an ObjectDataSource to retrieve the products for the current category, we could create a method in our ASP.NET page s code-behind class (or in the `App_Code` folder or in a separate Class Library project) that returns the appropriate set of products when passed in a `CategoryID`.</span></span> <span data-ttu-id="bfc76-180">假设我们有这样的方法，在我们的 ASP.NET 页面 + s 代码隐藏类中被命名为`GetProductsInCategory(categoryID)`。</span><span class="sxs-lookup"><span data-stu-id="bfc76-180">Imagine that we had such a method in our ASP.NET page s code-behind class and that it was named `GetProductsInCategory(categoryID)`.</span></span> <span data-ttu-id="bfc76-181">使用此方法准备就绪后我们无法绑定到使用下面的声明性语法内部 Repeater 当前类别的产品：</span><span class="sxs-lookup"><span data-stu-id="bfc76-181">With this method in place we could bind the products for the current category to the inner Repeater using the following declarative syntax:</span></span>


[!code-aspx[Main](nested-data-web-controls-cs/samples/sample6.aspx)]

<span data-ttu-id="bfc76-182">Repeater s`DataSource`属性使用的数据绑定语法来指示其数据来自于`GetProductsInCategory(categoryID)`方法。</span><span class="sxs-lookup"><span data-stu-id="bfc76-182">The Repeater s `DataSource` property uses the databinding syntax to indicate that its data comes from the `GetProductsInCategory(categoryID)` method.</span></span> <span data-ttu-id="bfc76-183">由于`Eval("CategoryID")`返回类型的值`Object`，我们将对象转换为`Integer`然后再将其传递`GetProductsInCategory(categoryID)`方法。</span><span class="sxs-lookup"><span data-stu-id="bfc76-183">Since `Eval("CategoryID")` returns a value of type `Object`, we cast the object to an `Integer` before passing it into the `GetProductsInCategory(categoryID)` method.</span></span> <span data-ttu-id="bfc76-184">请注意，`CategoryID`访问下面的语法是通过数据绑定`CategoryID`中*外部*Repeater (`CategoryList`)，即该 s 绑定到的记录`Categories`表。</span><span class="sxs-lookup"><span data-stu-id="bfc76-184">Note that the `CategoryID` accessed here via the databinding syntax is the `CategoryID` in the *outer* Repeater (`CategoryList`), the one that s bound to the records in the `Categories` table.</span></span> <span data-ttu-id="bfc76-185">因此，我们知道`CategoryID`不能为数据库`NULL`值，该值就是我们可以隐式强制转换的原因`Eval`方法，而如果检查我们重新处理`DBNull`。</span><span class="sxs-lookup"><span data-stu-id="bfc76-185">Therefore, we know that `CategoryID` cannot be a database `NULL` value, which is why we can blindly cast the `Eval` method without checking if we re dealing with a `DBNull`.</span></span>

<span data-ttu-id="bfc76-186">使用此方法时，我们需要创建`GetProductsInCategory(categoryID)`方法，并将其检索相应的一组给定所提供的产品*`categoryID`*。</span><span class="sxs-lookup"><span data-stu-id="bfc76-186">With this approach, we need to create the `GetProductsInCategory(categoryID)` method and have it retrieve the appropriate set of products given the supplied *`categoryID`*.</span></span> <span data-ttu-id="bfc76-187">可以为此，我们只需返回`ProductsDataTable`返回的`ProductsBLL`类的`GetProductsByCategoryID(categoryID)`方法。</span><span class="sxs-lookup"><span data-stu-id="bfc76-187">We can do this by simply returning the `ProductsDataTable` returned by the `ProductsBLL` class s `GetProductsByCategoryID(categoryID)` method.</span></span> <span data-ttu-id="bfc76-188">让我们来创建`GetProductsInCategory(categoryID)`中的代码隐藏类的方法我们`NestedControls.aspx`页。</span><span class="sxs-lookup"><span data-stu-id="bfc76-188">Let s create the `GetProductsInCategory(categoryID)` method in the code-behind class for our `NestedControls.aspx` page.</span></span> <span data-ttu-id="bfc76-189">完成此操作使用以下代码：</span><span class="sxs-lookup"><span data-stu-id="bfc76-189">Do so using the following code:</span></span>


[!code-csharp[Main](nested-data-web-controls-cs/samples/sample7.cs)]

<span data-ttu-id="bfc76-190">此方法只需创建的实例`ProductsBLL`方法，并返回的结果`GetProductsByCategoryID(categoryID)`方法。</span><span class="sxs-lookup"><span data-stu-id="bfc76-190">This method simply creates an instance of the `ProductsBLL` method and returns the results of the `GetProductsByCategoryID(categoryID)` method.</span></span> <span data-ttu-id="bfc76-191">请注意该方法必须标记为`Public`或`Protected`; 如果该方法标记为`Private`，它将不能从 ASP.NET 页 s 声明性标记访问。</span><span class="sxs-lookup"><span data-stu-id="bfc76-191">Note that the method must be marked `Public` or `Protected`; if the method is marked `Private`, it will not be accessible from the ASP.NET page s declarative markup.</span></span>

<span data-ttu-id="bfc76-192">若要使用此新技术这些更改后，请花点时间查看通过浏览器页面。</span><span class="sxs-lookup"><span data-stu-id="bfc76-192">After making these changes to use this new technique, take a moment to view the page through a browser.</span></span> <span data-ttu-id="bfc76-193">输出应与输出相同时使用 ObjectDataSource 和`ItemDataBound`事件处理程序方法 （回头查看图 5，请参阅屏幕截图）。</span><span class="sxs-lookup"><span data-stu-id="bfc76-193">The output should be identical to the output when using the ObjectDataSource and `ItemDataBound` event handler approach (refer back to Figure 5 to see a screen shot).</span></span>

> [!NOTE]
> <span data-ttu-id="bfc76-194">它可能看起来通话创建`GetProductsInCategory(categoryID)`ASP.NET 页面 + s 代码隐藏类中的方法。</span><span class="sxs-lookup"><span data-stu-id="bfc76-194">It may seem like busywork to create the `GetProductsInCategory(categoryID)` method in the ASP.NET page s code-behind class.</span></span> <span data-ttu-id="bfc76-195">毕竟，此方法只需创建的实例`ProductsBLL`类，并返回的结果及其`GetProductsByCategoryID(categoryID)`方法。</span><span class="sxs-lookup"><span data-stu-id="bfc76-195">After all, this method simply creates an instance of the `ProductsBLL` class and returns the results of its `GetProductsByCategoryID(categoryID)` method.</span></span> <span data-ttu-id="bfc76-196">为什么不只是调用此方法直接从内部中继器中的数据绑定语法如： `DataSource='<%# ProductsBLL.GetProductsByCategoryID((int)(Eval("CategoryID"))) %>'`？</span><span class="sxs-lookup"><span data-stu-id="bfc76-196">Why not just call this method directly from the databinding syntax in the inner Repeater, like: `DataSource='<%# ProductsBLL.GetProductsByCategoryID((int)(Eval("CategoryID"))) %>'`?</span></span> <span data-ttu-id="bfc76-197">尽管此语法赢得了我们的当前实现不起作用`ProductsBLL`类 (由于`GetProductsByCategoryID(categoryID)`方法是实例方法)，您可以修改`ProductsBLL`包括静态`GetProductsByCategoryID(categoryID)`方法或具有包括静态类`Instance()`方法返回的新实例`ProductsBLL`类。</span><span class="sxs-lookup"><span data-stu-id="bfc76-197">Although this syntax won t work with our current implementation of the `ProductsBLL` class (since the `GetProductsByCategoryID(categoryID)` method is an instance method), you could modify `ProductsBLL` to include a static `GetProductsByCategoryID(categoryID)` method or have the class include a static `Instance()` method to return a new instance of the `ProductsBLL` class.</span></span>


<span data-ttu-id="bfc76-198">虽然此类修改将不再需要`GetProductsInCategory(categoryID)`ASP.NET 页面 + s 代码隐藏类中的方法，代码隐藏类方法使我们更灵活地使用检索的数据，我们稍后将看到。</span><span class="sxs-lookup"><span data-stu-id="bfc76-198">While such modifications would eliminate the need for the `GetProductsInCategory(categoryID)` method in the ASP.NET page s code-behind class, the code-behind class method gives us more flexibility in working with the data retrieved, as we'll see shortly.</span></span>

## <a name="retrieving-all-of-the-product-information-at-once"></a><span data-ttu-id="bfc76-199">检索所有次产品信息</span><span class="sxs-lookup"><span data-stu-id="bfc76-199">Retrieving All of the Product Information at Once</span></span>

<span data-ttu-id="bfc76-200">两个早期技术我们检查已通过调用获取这些类别的产品的当前`ProductsBLL`类 s`GetProductsByCategoryID(categoryID)`方法 (第一种方法之所以这样做是通过对象数据源，通过第二个`GetProductsInCategory(categoryID)`中的方法代码隐藏类）。</span><span class="sxs-lookup"><span data-stu-id="bfc76-200">The two pervious techniques we ve examined grab those products for the current category by making a call to the `ProductsBLL` class s `GetProductsByCategoryID(categoryID)` method (the first approach did so through an ObjectDataSource, the second through the `GetProductsInCategory(categoryID)` method in the code-behind class).</span></span> <span data-ttu-id="bfc76-201">每次调用此方法，直至数据访问层，业务逻辑层调用的查询返回行的 SQL 语句的数据库`Products`表`CategoryID`字段与匹配所提供的输入的参数。</span><span class="sxs-lookup"><span data-stu-id="bfc76-201">Each time this method is invoked, the Business Logic Layer calls down to the Data Access Layer, which queries the database with a SQL statement that returns rows from the `Products` table whose `CategoryID` field matches the supplied input parameter.</span></span>

<span data-ttu-id="bfc76-202">给定*N*系统中的类别，这种方法网络*N* + 1 调用数据库数据库查询来获取所有类别，然后*N*调用以获取产品特定于每个类别。</span><span class="sxs-lookup"><span data-stu-id="bfc76-202">Given *N* categories in the system, this approach nets *N* + 1 calls to the database one database query to get all of the categories and then *N* calls to get the products specific to each category.</span></span> <span data-ttu-id="bfc76-203">但是，我们可以检索仅使用两个数据库调用一次调用获取所有各类别以及一个用于获取所有产品的所有所需的数据。</span><span class="sxs-lookup"><span data-stu-id="bfc76-203">We can, however, retrieve all the needed data in just two database calls one call to get all of the categories and another to get all of the products.</span></span> <span data-ttu-id="bfc76-204">一旦我们有的所有产品，我们可以筛选这些产品因此，只有匹配当前的产品`CategoryID`绑定到该类别 s 内部 Repeater。</span><span class="sxs-lookup"><span data-stu-id="bfc76-204">Once we have all of the products, we can filter those products so that only the products matching the current `CategoryID` are bound to that category s inner Repeater.</span></span>

<span data-ttu-id="bfc76-205">若要提供此功能，我们只需稍做修改到`GetProductsInCategory(categoryID)`中我们的 ASP.NET 页面 + s 代码隐藏类的方法。</span><span class="sxs-lookup"><span data-stu-id="bfc76-205">To provide this functionality, we only need to make a slight modification to the `GetProductsInCategory(categoryID)` method in our ASP.NET page s code-behind class.</span></span> <span data-ttu-id="bfc76-206">而不是盲目地返回的结果`ProductsBLL`类 s`GetProductsByCategoryID(categoryID)`方法中，我们可以改为第一次访问*所有*的产品 (如果它们没有 t 已访问)，然后返回的只是筛选的视图产品基于传入的`CategoryID`。</span><span class="sxs-lookup"><span data-stu-id="bfc76-206">Rather than blindly returning the results of the `ProductsBLL` class s `GetProductsByCategoryID(categoryID)` method, we can instead first access *all* of the products (if they haven t been accessed already) and then return just the filtered view of the products based on the passed-in `CategoryID`.</span></span>


[!code-csharp[Main](nested-data-web-controls-cs/samples/sample8.cs)]

<span data-ttu-id="bfc76-207">请注意页面级变量添加`allProducts`。</span><span class="sxs-lookup"><span data-stu-id="bfc76-207">Note the addition of the page-level variable, `allProducts`.</span></span> <span data-ttu-id="bfc76-208">此保存有关的所有产品的信息，会填充第一次`GetProductsInCategory(categoryID)`调用方法。</span><span class="sxs-lookup"><span data-stu-id="bfc76-208">This holds information about all of the products and is populated the first time the `GetProductsInCategory(categoryID)` method is invoked.</span></span> <span data-ttu-id="bfc76-209">之后，确保`allProducts`，创建对象并将其填充方法筛选器 DataTable 的结果，以便它的行只`CategoryID`匹配指定`CategoryID`可访问。</span><span class="sxs-lookup"><span data-stu-id="bfc76-209">After ensuring that the `allProducts` object has been created and populated, the method filters the DataTable s results such that only those rows whose `CategoryID` matches the specified `CategoryID` are accessible.</span></span> <span data-ttu-id="bfc76-210">这种方法可以减少从访问数据库的次数*N* + 两到 1。</span><span class="sxs-lookup"><span data-stu-id="bfc76-210">This approach reduces the number of times the database is accessed from *N* + 1 down to two.</span></span>

<span data-ttu-id="bfc76-211">此增强功能不会引入到页面的呈现的标记的任何更改，也不会带来另一种方法比返回更少的记录。</span><span class="sxs-lookup"><span data-stu-id="bfc76-211">This enhancement does not introduce any change to the rendered markup of the page, nor does it bring back fewer records than the other approach.</span></span> <span data-ttu-id="bfc76-212">它只是减少了对数据库的调用数。</span><span class="sxs-lookup"><span data-stu-id="bfc76-212">It simply reduces the number of calls to the database.</span></span>

> [!NOTE]
> <span data-ttu-id="bfc76-213">一个直观的方式可能原因减少数据库访问的数量也会肯定提高性能。</span><span class="sxs-lookup"><span data-stu-id="bfc76-213">One might intuitively reason that reducing the number of database accesses would assuredly improve performance.</span></span> <span data-ttu-id="bfc76-214">但是，这可能不是这种情况。</span><span class="sxs-lookup"><span data-stu-id="bfc76-214">However, this might not be the case.</span></span> <span data-ttu-id="bfc76-215">如果有大量的产品的`CategoryID`是`NULL`，有关示例，然后调用`GetProducts`方法返回的永远不会显示的产品数目。</span><span class="sxs-lookup"><span data-stu-id="bfc76-215">If you have a large number of products whose `CategoryID` is `NULL`, for example, then the call to the `GetProducts` method returns a number of products that are never displayed.</span></span> <span data-ttu-id="bfc76-216">此外，返回的所有产品会都很浪费如果您重新仅显示子集的类别，可能会都出现这种情况，如果已实现分页。</span><span class="sxs-lookup"><span data-stu-id="bfc76-216">Moreover, returning all of the products can be wasteful if you re only showing a subset of the categories, which might be the case if you have implemented paging.</span></span>


<span data-ttu-id="bfc76-217">如往常一样，当涉及到分析两种技术的性能，仅欢心的度量值是运行适合你应用程序 s 的常见案例方案的受控的测试。</span><span class="sxs-lookup"><span data-stu-id="bfc76-217">As always, when it comes to analyzing the performance of two techniques, the only surefire measure is to run controlled tests tailored for your application s common case scenarios.</span></span>

## <a name="summary"></a><span data-ttu-id="bfc76-218">总结</span><span class="sxs-lookup"><span data-stu-id="bfc76-218">Summary</span></span>

<span data-ttu-id="bfc76-219">在本教程中我们已了解如何将嵌套一个数据 Web 控件在另一个，专门研究具有与列出的项目符号列表中每个类别的产品内部 Repeater 显示每个类别项外部 Repeater。</span><span class="sxs-lookup"><span data-stu-id="bfc76-219">In this tutorial we saw how to nest one data Web control within another, specifically examining how to have an outer Repeater display an item for each category with an inner Repeater listing the products for each category in a bulleted list.</span></span> <span data-ttu-id="bfc76-220">生成嵌套的用户界面的主要难题在于访问以及正确的数据绑定到的内部数据 Web 控件。</span><span class="sxs-lookup"><span data-stu-id="bfc76-220">The main challenge in building a nested user interface lies in accessing and binding the correct data to the inner data Web control.</span></span> <span data-ttu-id="bfc76-221">有各种技术可用，我们在本教程中探讨其中两个。</span><span class="sxs-lookup"><span data-stu-id="bfc76-221">There are a variety of techniques available, two of which we examined in this tutorial.</span></span> <span data-ttu-id="bfc76-222">检查第一种方法中的外部数据 Web 控件 s 使用 ObjectDataSource`ItemTemplate`的已绑定到内部数据 Web 控件通过其`DataSourceID`属性。</span><span class="sxs-lookup"><span data-stu-id="bfc76-222">The first approach examined used an ObjectDataSource in the outer data Web control s `ItemTemplate` that was bound to the inner data Web control through its `DataSourceID` property.</span></span> <span data-ttu-id="bfc76-223">第二种方法来访问这些数据通过 ASP.NET 页面的代码隐藏类中的方法。</span><span class="sxs-lookup"><span data-stu-id="bfc76-223">The second technique accessed the data via a method in the ASP.NET page s code-behind class.</span></span> <span data-ttu-id="bfc76-224">然后，此方法可以绑定到的内部数据 Web 控件的`DataSource`通过数据绑定语法的属性。</span><span class="sxs-lookup"><span data-stu-id="bfc76-224">This method can then be bound to the inner data Web control s `DataSource` property through databinding syntax.</span></span>

<span data-ttu-id="bfc76-225">尽管在本教程中检查嵌套的用户界面使用 Repeater Repeater 中嵌套，但这些技术可以扩展到其他数据 Web 控件。</span><span class="sxs-lookup"><span data-stu-id="bfc76-225">While the nested user interface examined in this tutorial used a Repeater nested within a Repeater, these techniques can be extended to the other data Web controls.</span></span> <span data-ttu-id="bfc76-226">您可以嵌套 GridView 或 DataList 内的 GridView 中 Repeater 等。</span><span class="sxs-lookup"><span data-stu-id="bfc76-226">You can nest a Repeater within a GridView, or a GridView within a DataList, and so on.</span></span>

<span data-ttu-id="bfc76-227">快乐编程 ！</span><span class="sxs-lookup"><span data-stu-id="bfc76-227">Happy Programming!</span></span>

## <a name="about-the-author"></a><span data-ttu-id="bfc76-228">关于作者</span><span class="sxs-lookup"><span data-stu-id="bfc76-228">About the Author</span></span>

<span data-ttu-id="bfc76-229">[Scott Mitchell](http://www.4guysfromrolla.com/ScottMitchell.shtml)的七个部 asp/ASP.NET 书籍并创办了作者[4GuysFromRolla.com](http://www.4guysfromrolla.com)，自 1998 年以来一直致力于 Microsoft Web 技术。</span><span class="sxs-lookup"><span data-stu-id="bfc76-229">[Scott Mitchell](http://www.4guysfromrolla.com/ScottMitchell.shtml), author of seven ASP/ASP.NET books and founder of [4GuysFromRolla.com](http://www.4guysfromrolla.com), has been working with Microsoft Web technologies since 1998.</span></span> <span data-ttu-id="bfc76-230">Scott 是独立的顾问、 培训师和编写器。</span><span class="sxs-lookup"><span data-stu-id="bfc76-230">Scott works as an independent consultant, trainer, and writer.</span></span> <span data-ttu-id="bfc76-231">他最新著作是[ *Sams Teach 自己 ASP.NET 2.0 24 小时内*](https://www.amazon.com/exec/obidos/ASIN/0672327384/4guysfromrollaco)。</span><span class="sxs-lookup"><span data-stu-id="bfc76-231">His latest book is [*Sams Teach Yourself ASP.NET 2.0 in 24 Hours*](https://www.amazon.com/exec/obidos/ASIN/0672327384/4guysfromrollaco).</span></span> <span data-ttu-id="bfc76-232">他可以到达[ mitchell@4GuysFromRolla.com。](mailto:mitchell@4GuysFromRolla.com)</span><span class="sxs-lookup"><span data-stu-id="bfc76-232">He can be reached at [mitchell@4GuysFromRolla.com.](mailto:mitchell@4GuysFromRolla.com)</span></span> <span data-ttu-id="bfc76-233">或通过他的博客，其中，请参阅[ http://ScottOnWriting.NET ](http://ScottOnWriting.NET)。</span><span class="sxs-lookup"><span data-stu-id="bfc76-233">or via his blog, which can be found at [http://ScottOnWriting.NET](http://ScottOnWriting.NET).</span></span>

## <a name="special-thanks-to"></a><span data-ttu-id="bfc76-234">特别感谢</span><span class="sxs-lookup"><span data-stu-id="bfc76-234">Special Thanks To</span></span>

<span data-ttu-id="bfc76-235">很多有用的审阅者已评审本系列教程。</span><span class="sxs-lookup"><span data-stu-id="bfc76-235">This tutorial series was reviewed by many helpful reviewers.</span></span> <span data-ttu-id="bfc76-236">本教程中的潜在顾客审阅者已 Zack Jones 和 Liz Shulok。</span><span class="sxs-lookup"><span data-stu-id="bfc76-236">Lead reviewers for this tutorial were Zack Jones and Liz Shulok.</span></span> <span data-ttu-id="bfc76-237">是否有兴趣查看我即将推出的 MSDN 文章？</span><span class="sxs-lookup"><span data-stu-id="bfc76-237">Interested in reviewing my upcoming MSDN articles?</span></span> <span data-ttu-id="bfc76-238">如果是这样，给我在行[ mitchell@4GuysFromRolla.com。](mailto:mitchell@4GuysFromRolla.com)</span><span class="sxs-lookup"><span data-stu-id="bfc76-238">If so, drop me a line at [mitchell@4GuysFromRolla.com.](mailto:mitchell@4GuysFromRolla.com)</span></span>

> [!div class="step-by-step"]
> <span data-ttu-id="bfc76-239">[上一页](showing-multiple-records-per-row-with-the-datalist-control-cs.md)
> [下一页](displaying-data-with-the-datalist-and-repeater-controls-vb.md)</span><span class="sxs-lookup"><span data-stu-id="bfc76-239">[Previous](showing-multiple-records-per-row-with-the-datalist-control-cs.md)
[Next](displaying-data-with-the-datalist-and-repeater-controls-vb.md)</span></span>
