---
uid: web-forms/overview/older-versions-getting-started/deploying-web-site-projects/strategies-for-database-development-and-deployment-cs
title: 数据库开发和部署 (C#) 策略 |Microsoft Docs
author: rick-anderson
description: 部署第一次的数据驱动的应用程序时可以会盲目地将数据库复制到生产环境的开发环境中。 B...
ms.author: aspnetcontent
ms.date: 04/23/2009
ms.assetid: 3e8b0627-3eb7-488e-807e-067cba7cec05
msc.legacyurl: /web-forms/overview/older-versions-getting-started/deploying-web-site-projects/strategies-for-database-development-and-deployment-cs
msc.type: authoredcontent
ms.openlocfilehash: 0cec51d7b0e87f3073e27eb9bbdb4187d61307f2
ms.sourcegitcommit: b28cd0313af316c051c2ff8549865bff67f2fbb4
ms.translationtype: MT
ms.contentlocale: zh-CN
ms.lasthandoff: 07/05/2018
ms.locfileid: "37823665"
---
<a name="strategies-for-database-development-and-deployment-c"></a><span data-ttu-id="41c56-104">数据库开发和部署 (C#) 策略</span><span class="sxs-lookup"><span data-stu-id="41c56-104">Strategies for Database Development and Deployment (C#)</span></span>
====================
<span data-ttu-id="41c56-105">通过[Scott Mitchell](https://twitter.com/ScottOnWriting)</span><span class="sxs-lookup"><span data-stu-id="41c56-105">by [Scott Mitchell](https://twitter.com/ScottOnWriting)</span></span>

[<span data-ttu-id="41c56-106">下载 PDF</span><span class="sxs-lookup"><span data-stu-id="41c56-106">Download PDF</span></span>](http://download.microsoft.com/download/C/3/9/C391A649-B357-4A7B-BAA4-48C96871FEA6/aspnet_tutorial10_DBDevel_cs.pdf)

> <span data-ttu-id="41c56-107">部署第一次的数据驱动的应用程序时可以会盲目地将数据库复制到生产环境的开发环境中。</span><span class="sxs-lookup"><span data-stu-id="41c56-107">When deploying a data-driven application for the first time you can blindly copy the database in the development environment to the production environment.</span></span> <span data-ttu-id="41c56-108">但执行直接在后续部署中的副本将覆盖输入到生产数据库中的任何数据。</span><span class="sxs-lookup"><span data-stu-id="41c56-108">But performing a blind copy in subsequent deployments will overwrite any data entered into the production database.</span></span> <span data-ttu-id="41c56-109">相反，将数据库部署涉及将应用到生产数据库上上次部署以来对开发数据库所做的更改。</span><span class="sxs-lookup"><span data-stu-id="41c56-109">Instead, deploying a database involves applying the changes made to the development database since the last deployment onto the production database.</span></span> <span data-ttu-id="41c56-110">本教程中检查这些挑战，并提供各种策略来帮助进行 chronicling 并将其应用自上次部署以来对数据库所做的更改。</span><span class="sxs-lookup"><span data-stu-id="41c56-110">This tutorial examines these challenges and offers various strategies to assist with chronicling and applying the changes made to the database since the last deployment.</span></span>


## <a name="introduction"></a><span data-ttu-id="41c56-111">介绍</span><span class="sxs-lookup"><span data-stu-id="41c56-111">Introduction</span></span>

<span data-ttu-id="41c56-112">如前面的教程中所述，部署 ASP.NET 应用程序需要将相关的内容从开发环境复制到生产环境。</span><span class="sxs-lookup"><span data-stu-id="41c56-112">As discussed in previous tutorials, deploying an ASP.NET application entails copying the pertinent content from the development environment to the production environment.</span></span> <span data-ttu-id="41c56-113">部署不是一次性事件，但而不是每次发布新版本的软件时或当发生的其他 bug 或确定并解决安全问题。</span><span class="sxs-lookup"><span data-stu-id="41c56-113">Deployment is not a one-time event, but rather something that happens every time a new version of the software is released or when bugs or security concerns have been identified and addressed.</span></span> <span data-ttu-id="41c56-114">在复制的 ASP.NET 页面时，图像、 JavaScript 文件和其他此类文件到生产环境不需要关注如何将这些文件已更改自上次部署以来中。</span><span class="sxs-lookup"><span data-stu-id="41c56-114">When copying ASP.NET pages, images, JavaScript files, and other such files to the production environment you do not need to concern yourself with how these file have been changed since the last deployment.</span></span> <span data-ttu-id="41c56-115">您可以会盲目地将文件复制到生产环境中，覆盖现有内容。</span><span class="sxs-lookup"><span data-stu-id="41c56-115">You can blindly copy the file to production, overwriting the existing content.</span></span> <span data-ttu-id="41c56-116">遗憾的是，这种简单性不扩展到部署数据库。</span><span class="sxs-lookup"><span data-stu-id="41c56-116">Unfortunately, this simplicity does not extend to deploying the database.</span></span>

<span data-ttu-id="41c56-117">部署第一次的数据驱动的应用程序时可以会盲目地将数据库复制到生产环境的开发环境中。</span><span class="sxs-lookup"><span data-stu-id="41c56-117">When deploying a data-driven application for the first time you can blindly copy the database in the development environment to the production environment.</span></span> <span data-ttu-id="41c56-118">但执行直接在后续部署中的副本将覆盖输入到生产数据库中的任何数据。</span><span class="sxs-lookup"><span data-stu-id="41c56-118">But performing a blind copy in subsequent deployments will overwrite any data entered into the production database.</span></span> <span data-ttu-id="41c56-119">相反，部署数据库涉及应用*更改*自上次部署到生产数据库上对开发数据库。</span><span class="sxs-lookup"><span data-stu-id="41c56-119">Instead, deploying a database involves applying the *changes* made to the development database since the last deployment onto the production database.</span></span> <span data-ttu-id="41c56-120">本教程中检查这些挑战，并提供各种策略来帮助进行 chronicling 并将其应用自上次部署以来对数据库所做的更改。</span><span class="sxs-lookup"><span data-stu-id="41c56-120">This tutorial examines these challenges and offers various strategies to assist with chronicling and applying the changes made to the database since the last deployment.</span></span>

## <a name="the-challenges-of-deploying-a-database"></a><span data-ttu-id="41c56-121">部署数据库的挑战</span><span class="sxs-lookup"><span data-stu-id="41c56-121">The Challenges of Deploying a Database</span></span>

<span data-ttu-id="41c56-122">第一次部署数据驱动的应用程序之前，只有一个数据库，即在开发环境中，这正是你可以部署第一次的数据驱动的应用程序时盲目地数据库复制中的数据库到生产环境的开发环境。</span><span class="sxs-lookup"><span data-stu-id="41c56-122">Before a data-driven application has been deployed for the first time, there is only one database, namely the database in the development environment, which is why when deploying a data-driven application for the first time you can blindly copy the database in the development environment to the production environment.</span></span> <span data-ttu-id="41c56-123">但后部署应用程序有两个数据库副本： 一个在开发一个在生产环境中。</span><span class="sxs-lookup"><span data-stu-id="41c56-123">But once the application has been deployed there are two copies of the database: one in development and one in production.</span></span>

<span data-ttu-id="41c56-124">部署之间的数据库开发和生产数据库会变得不同步。生产数据库的架构保持不变，如添加新功能可能会更改开发数据库的架构。</span><span class="sxs-lookup"><span data-stu-id="41c56-124">Between deployments the development and production databases can become out of sync. While the production database s schema remains unchanged, the development database s schema may change as new features are added.</span></span> <span data-ttu-id="41c56-125">您可能添加或删除列、 表、 视图或存储的过程。</span><span class="sxs-lookup"><span data-stu-id="41c56-125">You might add or remove columns, tables, views, or stored procedures.</span></span> <span data-ttu-id="41c56-126">此外可能被添加到开发数据库的重要数据。</span><span class="sxs-lookup"><span data-stu-id="41c56-126">There may also be important data that gets added to the development database.</span></span> <span data-ttu-id="41c56-127">许多数据驱动应用程序包括使用硬编码、 特定于应用程序不是用户可编辑的数据填充查找表。</span><span class="sxs-lookup"><span data-stu-id="41c56-127">Many data-driven applications include lookup tables populated with hard-coded, application-specific data that are not user-editable.</span></span> <span data-ttu-id="41c56-128">例如，拍卖网站可能有一个带有描述正在双项的条件的选项的下拉列表： 新建、 等新、 好，和公平。</span><span class="sxs-lookup"><span data-stu-id="41c56-128">For example, an auction website might have a drop-down list with choices that describe the condition of the item being auctioned: New, Like New, Good, and Fair.</span></span> <span data-ttu-id="41c56-129">而不是硬编码直接在下拉列表中的这些选项是通常最好将它们放在数据库表。</span><span class="sxs-lookup"><span data-stu-id="41c56-129">Rather than hard-coding these options directly in the drop-down list it is usually better to place them in a database table.</span></span> <span data-ttu-id="41c56-130">如果在开发期间，一个名为不佳的新条件添加到表然后部署该应用程序时此相同的记录将需要添加到生产数据库中的查找表。</span><span class="sxs-lookup"><span data-stu-id="41c56-130">If, during development, a new condition named Poor is added to the table then when deploying the application this same record needs to be added to the lookup table in the production database.</span></span>

<span data-ttu-id="41c56-131">理想情况下，将数据库部署将涉及复制数据库从开发到生产环境。</span><span class="sxs-lookup"><span data-stu-id="41c56-131">Ideally, deploying the database would involve copying the database from development to production.</span></span> <span data-ttu-id="41c56-132">但请记住，在部署应用程序并继续开发后，生产数据库正在使用真实用户的实际数据填充。</span><span class="sxs-lookup"><span data-stu-id="41c56-132">But keep in mind that after you have deployed the application and resumed development, the production database is being populated with real data from real users.</span></span> <span data-ttu-id="41c56-133">因此，如果你打算只需将数据库复制从开发到生产环境，在下一步部署将覆盖生产数据库和丢失其现有数据。</span><span class="sxs-lookup"><span data-stu-id="41c56-133">Therefore, if you were to simply copy the database from development to production at the next deployment you would overwrite the production database and lose its existing data.</span></span> <span data-ttu-id="41c56-134">最终结果是，将数据库部署归结为应用开发数据库自上次部署以来所做的更改。</span><span class="sxs-lookup"><span data-stu-id="41c56-134">The net result is that deploying the database boils down to applying the changes made to the development database since the last deployment.</span></span>

<span data-ttu-id="41c56-135">由于将数据库部署涉及自上次部署以来应用中的架构和数据，也可能更改，更改历史记录必须维护 （或在部署时确定），以便这些更改可以应用于生产环境。</span><span class="sxs-lookup"><span data-stu-id="41c56-135">Because deploying a database involves applying the changes in the schema and, possibly, the data since the last deployment, a history of changes must be maintained (or determined at deploy-time) so that those changes can be applied on production.</span></span> <span data-ttu-id="41c56-136">有各种技术用于管理和将更改应用于数据模型。</span><span class="sxs-lookup"><span data-stu-id="41c56-136">There are a variety of techniques for managing and applying changes to the data model.</span></span>

### <a name="defining-the-baseline"></a><span data-ttu-id="41c56-137">定义基线</span><span class="sxs-lookup"><span data-stu-id="41c56-137">Defining the Baseline</span></span>

<span data-ttu-id="41c56-138">若要维护对应用程序的数据库的更改需要具有某些起始状态，向其所做的更改应用于的基线。</span><span class="sxs-lookup"><span data-stu-id="41c56-138">To maintain the changes to your application s database you need to have some starting state, a baseline to which the changes are applied to.</span></span> <span data-ttu-id="41c56-139">一种极端的起始状态可以是任何表、 视图或存储的过程的空数据库。</span><span class="sxs-lookup"><span data-stu-id="41c56-139">At one extreme the starting state could be an empty database with no tables, views, or stored procedures.</span></span> <span data-ttu-id="41c56-140">此类基准会导致大型更改日志，因为它必须包括所有数据库的表、 视图和存储的过程以及在初始部署之后所做的任何更改的创建。</span><span class="sxs-lookup"><span data-stu-id="41c56-140">Such a baseline results in a large change log because it must include the creation of all of the database s tables, views, and stored procedures along with any changes made after the initial deployment.</span></span> <span data-ttu-id="41c56-141">在另一端的极端情况下可以作为最初部署到生产环境的数据库的版本设置基线。</span><span class="sxs-lookup"><span data-stu-id="41c56-141">At the other end of the spectrum you could set the baseline as the version of the database that is initially deployed to the production environment.</span></span> <span data-ttu-id="41c56-142">选择此选项将产生更小的更改日志，因为它只包括对以下第一个部署的数据库所做的更改。</span><span class="sxs-lookup"><span data-stu-id="41c56-142">This choice results in a much smaller change log because it only includes the changes made to the database following the first deployment.</span></span> <span data-ttu-id="41c56-143">这是我更喜欢的方法。</span><span class="sxs-lookup"><span data-stu-id="41c56-143">This is the approach I prefer.</span></span> <span data-ttu-id="41c56-144">当然你可以选择道路方法的多个中间定义基线初始创建数据库和数据库将首先部署之间的一些点。</span><span class="sxs-lookup"><span data-stu-id="41c56-144">And of course you can choose a more middle of the road approach, defining the baseline as some point between the initial creation of the database and when the database is first deployed.</span></span>

<span data-ttu-id="41c56-145">后，请考虑所选基线生成可执行以重新创建基准版本的 SQL 脚本。</span><span class="sxs-lookup"><span data-stu-id="41c56-145">Once you have chosen a baseline consider generating a SQL script that can be executed to recreate the baseline version.</span></span> <span data-ttu-id="41c56-146">此类脚本可快速重新创建数据库的基准版本。</span><span class="sxs-lookup"><span data-stu-id="41c56-146">Such a script makes it possible to quickly recreate the baseline version of the database.</span></span> <span data-ttu-id="41c56-147">此功能便尤其有用，在大型项目中可能有多个开发人员在项目或其他环境，例如测试或过渡环境，其中每个需要其自己的数据库副本。</span><span class="sxs-lookup"><span data-stu-id="41c56-147">This functionality is especially useful in larger projects, where there may be multiple developers working on the project or additional environments, such as testing or staging, that each need their own copy of the database.</span></span>

<span data-ttu-id="41c56-148">有各种工具，以生成基准版本的 SQL 脚本。</span><span class="sxs-lookup"><span data-stu-id="41c56-148">There are a variety of tools at your disposal to generate a SQL script of the baseline version.</span></span> <span data-ttu-id="41c56-149">从 SQL Server Management Studio (SSMS) 您可以右键单击数据库，请转到任务子菜单，并选择生成脚本选项。</span><span class="sxs-lookup"><span data-stu-id="41c56-149">From SQL Server Management Studio (SSMS) you can right-click on the database, go to the Tasks submenu, and choose the Generate Scripts option.</span></span> <span data-ttu-id="41c56-150">这将启动脚本向导中，您可以指示要生成包含创建 s 对象的数据库的 SQL 命令的文件。</span><span class="sxs-lookup"><span data-stu-id="41c56-150">This launches the Script Wizard, which you can instruct to generate a file that contains the SQL commands to create your database s objects.</span></span> <span data-ttu-id="41c56-151">另一个选项是数据库发布向导，可以生成不仅能够创建数据库架构，但数据还将数据库表中的 SQL 命令。</span><span class="sxs-lookup"><span data-stu-id="41c56-151">Another option is the Database Publishing Wizard, which can generate the SQL commands to not only create the database schema, but also the data in the database tables.</span></span> <span data-ttu-id="41c56-152">数据库发布向导已在详细信息中检查回到*部署数据库*教程。</span><span class="sxs-lookup"><span data-stu-id="41c56-152">The Database Publishing Wizard was examined in detail back in the *Deploying a Database* tutorial.</span></span> <span data-ttu-id="41c56-153">无论使用何种工具，最后应具有可用于重新创建数据库，基线版本的脚本文件应需要出现。</span><span class="sxs-lookup"><span data-stu-id="41c56-153">Regardless of what tool you use, in the end you should have a script file that you can use to recreate the baseline version of your database, should the need arise.</span></span>

## <a name="documenting-the-database-changes-in-prose"></a><span data-ttu-id="41c56-154">记录中的文本信息的数据库更改</span><span class="sxs-lookup"><span data-stu-id="41c56-154">Documenting the Database Changes in Prose</span></span>

<span data-ttu-id="41c56-155">在开发阶段保持对数据模型的更改的日志的最简单方法是中的文本信息记录所做的更改。</span><span class="sxs-lookup"><span data-stu-id="41c56-155">The simplest way to maintain a log of changes to the data model during the development phase is to record the changes in prose.</span></span> <span data-ttu-id="41c56-156">例如，如果已部署的应用程序开发期间添加到一个新列`Employees`表中，删除某一列从`Orders`表，并添加新表 (`ProductCategories`)，你将保留文本文件或 Microsoft Word 文档使用以下历史记录：</span><span class="sxs-lookup"><span data-stu-id="41c56-156">For example, if during development of an already-deployed application you add a new column to the `Employees` table, remove a column from the `Orders` table, and add a new table (`ProductCategories`), you would maintain a text file or Microsoft Word document with the following history:</span></span>

<a id="0.4_table01"></a>


| <span data-ttu-id="41c56-157">**更改日期**</span><span class="sxs-lookup"><span data-stu-id="41c56-157">**Change Date**</span></span> | <span data-ttu-id="41c56-158">**更改的详细信息**</span><span class="sxs-lookup"><span data-stu-id="41c56-158">**Change Details**</span></span> |
| --- | --- |
| <span data-ttu-id="41c56-159">2009-02-03:</span><span class="sxs-lookup"><span data-stu-id="41c56-159">2009-02-03:</span></span> | <span data-ttu-id="41c56-160">添加的列`DepartmentID`(`int`，不为 NULL) 到`Employees`表。</span><span class="sxs-lookup"><span data-stu-id="41c56-160">Added column `DepartmentID` (`int`, NOT NULL) to the `Employees` table.</span></span> <span data-ttu-id="41c56-161">添加从外的键约束`Departments.DepartmentID`到`Employees.DepartmentID`。</span><span class="sxs-lookup"><span data-stu-id="41c56-161">Added a foreign key constraint from `Departments.DepartmentID` to `Employees.DepartmentID`.</span></span> |
| <span data-ttu-id="41c56-162">2009-02-05:</span><span class="sxs-lookup"><span data-stu-id="41c56-162">2009-02-05:</span></span> | <span data-ttu-id="41c56-163">已删除的列`TotalWeight`从`Orders`表。</span><span class="sxs-lookup"><span data-stu-id="41c56-163">Removed column `TotalWeight` from the `Orders` table.</span></span> <span data-ttu-id="41c56-164">中已捕获的数据关联`OrderDetails`记录。</span><span class="sxs-lookup"><span data-stu-id="41c56-164">Data already captured in associated `OrderDetails` records.</span></span> |
| <span data-ttu-id="41c56-165">2009-02-12:</span><span class="sxs-lookup"><span data-stu-id="41c56-165">2009-02-12:</span></span> | <span data-ttu-id="41c56-166">创建`ProductCategories`表。</span><span class="sxs-lookup"><span data-stu-id="41c56-166">Created the `ProductCategories` table.</span></span> <span data-ttu-id="41c56-167">有以下三列： `ProductCategoryID` (`int`， `IDENTITY`， `NOT NULL`)， `CategoryName` (`nvarchar(50)`， `NOT NULL`)，并且`Active`(`bit`， `NOT NULL`)。</span><span class="sxs-lookup"><span data-stu-id="41c56-167">There are three columns: `ProductCategoryID` (`int`, `IDENTITY`, `NOT NULL`), `CategoryName` (`nvarchar(50)`, `NOT NULL`), and `Active` (`bit`, `NOT NULL`).</span></span> <span data-ttu-id="41c56-168">添加到主键约束`ProductCategoryID`，默认值为 1 到`Active`。</span><span class="sxs-lookup"><span data-stu-id="41c56-168">Added a primary key constraint to `ProductCategoryID`, and a default value of 1 to `Active`.</span></span> |


<span data-ttu-id="41c56-169">有很多这种方法的缺点。</span><span class="sxs-lookup"><span data-stu-id="41c56-169">There are a number of drawbacks to this approach.</span></span> <span data-ttu-id="41c56-170">对于初学者而言，没有任何希望实现自动化。</span><span class="sxs-lookup"><span data-stu-id="41c56-170">For starters, there is no hope for automation.</span></span> <span data-ttu-id="41c56-171">随时需要这些更改应用于数据库-如时部署应用程序-开发人员必须手动实现每个更改，请一次一个。</span><span class="sxs-lookup"><span data-stu-id="41c56-171">Anytime these changes need to be applied to a database - such as when the application is deployed - a developer must manually implement each change, one at a time.</span></span> <span data-ttu-id="41c56-172">此外，如果您需要重新构造从基线使用的更改日志数据库的特定版本，这样做因此需要越来越多的时间根据日志的大小增长情况。</span><span class="sxs-lookup"><span data-stu-id="41c56-172">Moreover, if you need to reconstruct a particular version of the database from the baseline using the change log, doing so will take more and more time as the size of the log grows.</span></span> <span data-ttu-id="41c56-173">此方法的另一个缺点是详细的清晰，每个更改日志条目级别保留记录更改的人员。</span><span class="sxs-lookup"><span data-stu-id="41c56-173">Another drawback to this method is that the clarity and level of detail of each change log entry is left to the person recording the change.</span></span> <span data-ttu-id="41c56-174">在多个开发人员团队中一些可能会使比其他更详细、 更具可读性，或更精确的条目。</span><span class="sxs-lookup"><span data-stu-id="41c56-174">In a team with multiple developers some may make more detailed, more readable, or more precise entries than others.</span></span> <span data-ttu-id="41c56-175">此外，错误报告中也可能包含拼写错误和其他与用户相关的数据输入错误。</span><span class="sxs-lookup"><span data-stu-id="41c56-175">Also, typos and other human-related data entry errors are possible.</span></span>

<span data-ttu-id="41c56-176">记录中的文本信息的数据库更改的主要优势是简单。</span><span class="sxs-lookup"><span data-stu-id="41c56-176">The primary benefit of documenting the database changes in prose is simplicity.</span></span> <span data-ttu-id="41c56-177">您不 t 需要知道如何创建和更改数据库对象的 SQL 语法。</span><span class="sxs-lookup"><span data-stu-id="41c56-177">You don t need familiarity with the SQL syntax for creating and altering database objects.</span></span> <span data-ttu-id="41c56-178">相反，可以在文本信息记录所做的更改，实现通过 SQL Server Management Studio s 图形用户界面。</span><span class="sxs-lookup"><span data-stu-id="41c56-178">Instead, you can record the changes in prose and implement them through SQL Server Management Studio s graphical user interface.</span></span>

<span data-ttu-id="41c56-179">维护你更改日志中的文本信息，不可否认，不于某些项目，例如在范围内，较大的非常复杂和获胜 t 工作具有对数据模型中，频繁更改或涉及多个开发人员。</span><span class="sxs-lookup"><span data-stu-id="41c56-179">Maintaining your change log in prose is, admittedly, not very sophisticated and won t work well with certain projects, such as ones that are large in scope, have frequent changes to the data model, or involve multiple developers.</span></span> <span data-ttu-id="41c56-180">但我曾见过这种方法很好地对数据模型仅偶尔更改且其中个人开发人员不具有坚实的背景中创建和更改数据库对象的 SQL 语法的小型的人式项目中的工作。</span><span class="sxs-lookup"><span data-stu-id="41c56-180">But I have seen this approach work quite well in small, one-man projects that have only occasional changes to the data model and where the solo developer does not have a strong background in the SQL syntax for creating and altering database objects.</span></span>

> [!NOTE]
> <span data-ttu-id="41c56-181">虽然更改日志中的信息，从技术上讲，直到部署时，才需要我建议保持更改的历史记录。</span><span class="sxs-lookup"><span data-stu-id="41c56-181">While the information in the change log is, technically, only needed until deploy-time, I recommend keeping a history of changes.</span></span> <span data-ttu-id="41c56-182">但是，而不是维护一个不断增长更改日志文件，请考虑让每个数据库版本不同的更改日志文件。</span><span class="sxs-lookup"><span data-stu-id="41c56-182">But rather than maintaining a single, ever growing change log file, consider having a different change log file for each database version.</span></span> <span data-ttu-id="41c56-183">通常您将希望到版本数据库每次部署它。</span><span class="sxs-lookup"><span data-stu-id="41c56-183">Typically you will want to version the database each time it is deployed.</span></span> <span data-ttu-id="41c56-184">通过维护的更改日志的日志可以从该基线，开始重新创建任何数据库版本通过执行更改日志脚本从版本 1 开始，并继续执行直到达到版本需要重新创建。</span><span class="sxs-lookup"><span data-stu-id="41c56-184">By maintaining a log of change logs you can, starting from the baseline, recreate any database version by executing the change log scripts starting from version 1 and continuing until you reach the version you need to recreate.</span></span>


## <a name="recording-the-sql-change-statements"></a><span data-ttu-id="41c56-185">记录 SQL 更改语句</span><span class="sxs-lookup"><span data-stu-id="41c56-185">Recording the SQL Change Statements</span></span>

<span data-ttu-id="41c56-186">维护的更改日志中的文本信息的主要缺点是自动化的缺少。</span><span class="sxs-lookup"><span data-stu-id="41c56-186">The primary drawback of maintaining the change log in prose is the lack of automation.</span></span> <span data-ttu-id="41c56-187">理想情况下，实现对生产数据库在部署时的数据库更改会简单，只单击一个按钮用于执行脚本，而无需手动执行一系列说明。</span><span class="sxs-lookup"><span data-stu-id="41c56-187">Ideally, implementing the database changes to the production database at deploy-time would be as easy as clicking a button to execute a script rather than having to manually perform a list of instructions.</span></span> <span data-ttu-id="41c56-188">此类自动化可通过维护包含这些 SQL 命令，用于更改数据模型的更改日志。</span><span class="sxs-lookup"><span data-stu-id="41c56-188">Such automation is possible by maintaining a change log that contains those SQL commands used to alter the data model.</span></span>

<span data-ttu-id="41c56-189">SQL 语法包括多个用于创建和修改各种数据库对象的语句。</span><span class="sxs-lookup"><span data-stu-id="41c56-189">The SQL syntax includes a number of statements for creating and modifying various database objects.</span></span> <span data-ttu-id="41c56-190">例如， [ *CREATE TABLE 语句*](https://msdn.microsoft.com/library/ms174979.aspx)、 执行时，使用指定的列和约束创建一个新表。</span><span class="sxs-lookup"><span data-stu-id="41c56-190">For example, the [*CREATE TABLE statement*](https://msdn.microsoft.com/library/ms174979.aspx), when executed, creates a new table with the specified columns and constraints.</span></span> <span data-ttu-id="41c56-191">[ *ALTER TABLE 语句*](https://msdn.microsoft.com/library/ms190273.aspx)修改现有表中，添加、 删除或修改它的列或约束。</span><span class="sxs-lookup"><span data-stu-id="41c56-191">The [*ALTER TABLE statement*](https://msdn.microsoft.com/library/ms190273.aspx) modifies an existing table, adding, removing, or modifying its columns or constraints.</span></span> <span data-ttu-id="41c56-192">也有语句来创建、 修改和删除索引、 视图、 用户定义的函数、 存储的过程、 触发器和其他数据库对象。</span><span class="sxs-lookup"><span data-stu-id="41c56-192">There are also statements to create, modify, and drop indexes, views, user-defined functions, stored procedures, triggers, and other database objects.</span></span>

<span data-ttu-id="41c56-193">返回到前面的示例，在已部署应用程序添加到一个新列的开发过程中映像`Employees`表中，删除某一列从`Orders`表，并添加新表 (`ProductCategories`)。</span><span class="sxs-lookup"><span data-stu-id="41c56-193">Returning to our earlier example, image that during development of an already-deployed application you add a new column to the `Employees` table, remove a column from the `Orders` table, and add a new table (`ProductCategories`).</span></span> <span data-ttu-id="41c56-194">此类操作会导致使用以下 SQL 命令的更改日志文件：</span><span class="sxs-lookup"><span data-stu-id="41c56-194">Such actions would result in a change log file with the following SQL commands:</span></span>

[!code-sql[Main](strategies-for-database-development-and-deployment-cs/samples/sample1.sql)]

<span data-ttu-id="41c56-195">将这些更改推送到生产数据库在部署时是一次单击操作： 打开 SQL Server Management Studio、 连接到您的生产数据库、 打开新查询窗口中，粘贴更改日志的内容和单击执行运行脚本。</span><span class="sxs-lookup"><span data-stu-id="41c56-195">Pushing these changes to the production database at deploy-time is a one-click operation: open SQL Server Management Studio, connect to your production database, open a New Query window, paste the contents of the change log, and click Execute to run the script.</span></span>

## <a name="using-a-comparison-tool-to-synchronize-the-data-models"></a><span data-ttu-id="41c56-196">使用比较工具来进行同步的数据模型</span><span class="sxs-lookup"><span data-stu-id="41c56-196">Using a Comparison Tool to Synchronize the Data Models</span></span>

<span data-ttu-id="41c56-197">记录中的文本信息的数据库更改非常简单，但实现所做的更改需要开发人员每次更改其中一个在生产数据库上一次;记录更改 SQL 命令那样容易和快速像单击按钮，在生产数据库上实现这些更改，但需要学习和掌握的 SQL 语句和用于创建和更改数据库对象的语法。</span><span class="sxs-lookup"><span data-stu-id="41c56-197">Documenting database changes in prose is easy, but implementing the changes requires a developer to make each change on the production database one at a time; documenting the change SQL commands makes implementing those changes on the production database as easy and quick as clicking a button, but requires learning and mastering the SQL statements and syntax for creating and altering database objects.</span></span> <span data-ttu-id="41c56-198">数据库比较工具需要从这两种方法的最佳和放弃最差。</span><span class="sxs-lookup"><span data-stu-id="41c56-198">Database comparison tools take the best from both approaches and discard the worst.</span></span>

<span data-ttu-id="41c56-199">数据库比较工具比较架构或两个数据库的数据，并显示一个摘要报告，显示您数据库有何不同。</span><span class="sxs-lookup"><span data-stu-id="41c56-199">A database comparison tool compares the schema or data of two databases and displays a summary report showing you how the databases differ.</span></span> <span data-ttu-id="41c56-200">然后，只需单击一个按钮，可以生成用于同步一个或多个数据库对象的 SQL 命令。</span><span class="sxs-lookup"><span data-stu-id="41c56-200">Then, with the click of a button, you can generate the SQL commands for synchronizing one or more database objects.</span></span> <span data-ttu-id="41c56-201">简单地说，您可以使用数据库比较工具比较开发和生产数据库在部署时，生成文件，其中包含 SQL 命令，在执行时，会将更改应用于生产数据库的架构因此它镜像开发数据库的架构。</span><span class="sxs-lookup"><span data-stu-id="41c56-201">In a nutshell, you can use a database comparison tool to compare the development and production databases at deploy-time, generating a file that contains the SQL commands that, when executed, will apply the changes to the production database s schema so that it mirrors the development database s schema.</span></span>

<span data-ttu-id="41c56-202">有多种第三方数据库提供的许多不同的供应商的比较工具。</span><span class="sxs-lookup"><span data-stu-id="41c56-202">There are a variety of third-party database comparison tools offered by many different vendors.</span></span> <span data-ttu-id="41c56-203">是这样一个例子[ *SQL Compare*](http://www.red-gate.com/products/SQL_Compare/)，也可由[ *Red Gate Software*](http://www.red-gate.com/)。</span><span class="sxs-lookup"><span data-stu-id="41c56-203">One such example is [*SQL Compare*](http://www.red-gate.com/products/SQL_Compare/), by [*Red Gate Software*](http://www.red-gate.com/).</span></span> <span data-ttu-id="41c56-204">让我们来演练使用 SQL 进行比较来比较和同步开发和生产数据库架构的过程。</span><span class="sxs-lookup"><span data-stu-id="41c56-204">Let s walk through the process of using SQL Compare to compare and synchronize the development and production databases schemas.</span></span>

> [!NOTE]
> <span data-ttu-id="41c56-205">在撰写本文时 SQL Compare 的当前版本是版本 7.1 中，具有 Standard Edition 395 美元的成本计算。</span><span class="sxs-lookup"><span data-stu-id="41c56-205">At the time of this writing the current version of SQL Compare was version 7.1, with the Standard Edition costing $395.</span></span> <span data-ttu-id="41c56-206">通过下载免费的 14 天试用版，您可以照着操作。</span><span class="sxs-lookup"><span data-stu-id="41c56-206">You can follow along by downloading a free 14-day trial.</span></span>


<span data-ttu-id="41c56-207">SQL Compare 启动时将打开比较项目对话框中，显示已保存的 SQL Compare 项目。</span><span class="sxs-lookup"><span data-stu-id="41c56-207">When SQL Compare starts the Comparison Projects dialog box opens, showing the saved SQL Compare projects.</span></span> <span data-ttu-id="41c56-208">创建新项目。</span><span class="sxs-lookup"><span data-stu-id="41c56-208">Create a new project.</span></span> <span data-ttu-id="41c56-209">这将启动项目配置向导中，提示输入的数据库的相关信息进行比较 （请参阅图 1）。</span><span class="sxs-lookup"><span data-stu-id="41c56-209">This launches the Project Configuration wizard, which prompts for information about the databases to compare (see Figure 1).</span></span> <span data-ttu-id="41c56-210">输入的信息，开发和生产环境数据库。</span><span class="sxs-lookup"><span data-stu-id="41c56-210">Enter the information for the development and production environment databases.</span></span>


<span data-ttu-id="41c56-211">[![开发和生产数据库进行比较](strategies-for-database-development-and-deployment-cs/_static/image2.jpg)](strategies-for-database-development-and-deployment-cs/_static/image1.jpg)</span><span class="sxs-lookup"><span data-stu-id="41c56-211">[![Compare the Development and Production Databases](strategies-for-database-development-and-deployment-cs/_static/image2.jpg)](strategies-for-database-development-and-deployment-cs/_static/image1.jpg)</span></span>

<span data-ttu-id="41c56-212">**图 1**： 比较开发和生产数据库 ([单击以查看实际尺寸的图像](strategies-for-database-development-and-deployment-cs/_static/image3.jpg))</span><span class="sxs-lookup"><span data-stu-id="41c56-212">**Figure 1**: Compare the Development and Production Databases ([Click to view full-size image](strategies-for-database-development-and-deployment-cs/_static/image3.jpg))</span></span>


> [!NOTE]
> <span data-ttu-id="41c56-213">如果开发环境数据库是 SQL Express Edition 数据库文件中的`App_Data`你将需要在 SQL Server Express 数据库服务器中注册该数据库，以便从图 1 中所示的对话框中选择它的网站的文件夹。</span><span class="sxs-lookup"><span data-stu-id="41c56-213">If your development environment database is a SQL Express Edition database file in the `App_Data` folder of your website you will need to register the database in the SQL Server Express database server in order to select it from the dialog box shown in Figure 1.</span></span> <span data-ttu-id="41c56-214">若要实现此目的的最简单方法是打开 SQL Server Management Studio (SSMS)，连接到 SQL Server Express 数据库服务器，并附加该数据库。</span><span class="sxs-lookup"><span data-stu-id="41c56-214">The easiest way to accomplish this is to open SQL Server Management Studio (SSMS), connect to the SQL Server Express database server, and attach the database.</span></span> <span data-ttu-id="41c56-215">如果你没有在计算机上安装的 SSMS 可以下载并安装免费[ *SQL Server 2008 Management Studio Basic 版本*](https://www.microsoft.com/downloads/details.aspx?FamilyId=7522A683-4CB2-454E-B908-E805E9BD4E28&amp;displaylang=en)。</span><span class="sxs-lookup"><span data-stu-id="41c56-215">If you do not have SSMS installed on your computer you can download and install the free [*SQL Server 2008 Management Studio Basic version*](https://www.microsoft.com/downloads/details.aspx?FamilyId=7522A683-4CB2-454E-B908-E805E9BD4E28&amp;displaylang=en).</span></span>


<span data-ttu-id="41c56-216">除了选择要比较的数据库，还可以指定各种比较设置从选项选项卡。你可能想要启用的一种选择是"忽略约束和索引名称。"</span><span class="sxs-lookup"><span data-stu-id="41c56-216">In addition to selecting the databases to compare, you can also specify a variety of comparison settings from the Options tab. One option you may want to turn on is the "Ignore constraint and index names."</span></span> <span data-ttu-id="41c56-217">前面曾提到，在前面的教程，我们添加应用程序服务到开发和生产数据库的数据库对象。</span><span class="sxs-lookup"><span data-stu-id="41c56-217">Recall that in the preceding tutorial we added the application services database objects to the development and production databases.</span></span> <span data-ttu-id="41c56-218">如果您使用`aspnet_regsql.exe`生产数据库上创建这些对象，那么你将找到 primary key 和 unique 约束名称，在开发和生产数据库之间不同的工具。</span><span class="sxs-lookup"><span data-stu-id="41c56-218">If you used the `aspnet_regsql.exe` tool to create these objects on the production database then you will find that the primary key and unique constraint names differ between the development and production databases.</span></span> <span data-ttu-id="41c56-219">因此，SQL Compare 将标记为不同的应用程序服务表的所有。</span><span class="sxs-lookup"><span data-stu-id="41c56-219">Consequently, SQL Compare will flag all of the application services tables as differing.</span></span> <span data-ttu-id="41c56-220">您可以将"忽略约束和索引名称"未选中状态和同步的约束名称，或指示 SQL Compare 要忽略这些差异。</span><span class="sxs-lookup"><span data-stu-id="41c56-220">You can either leave the "Ignore constraint and index names" unchecked and synchronize the constraint names, or instruct SQL Compare to ignore these differences.</span></span>

<span data-ttu-id="41c56-221">选择到数据库后进行比较 （和查看比较选项），单击立即比较按钮以开始比较。</span><span class="sxs-lookup"><span data-stu-id="41c56-221">After selecting the databases to compare (and reviewing the comparison options), click the Compare Now button to begin the comparison.</span></span> <span data-ttu-id="41c56-222">接下来的几秒内，通过 SQL Compare 会检查两个数据库的架构并生成报告有何不同。</span><span class="sxs-lookup"><span data-stu-id="41c56-222">Over the next several seconds, SQL Compare examines the schemas of the two databases and generates a report of how they differ.</span></span> <span data-ttu-id="41c56-223">我特意进行了开发数据库，以显示 SQL Compare 界面中记下此类差异是如何进行一些修改。</span><span class="sxs-lookup"><span data-stu-id="41c56-223">I ve purposefully made some modifications to the development database to show how such discrepancies are noted in the SQL Compare interface.</span></span> <span data-ttu-id="41c56-224">如图 2 所示，我添加 ve`BirthDate`列添加到`Authors`要删除的表`ISBN`从列`Books`表，并添加了一个新表， `Ratings`，这是为了让用户访问站点速率已审阅的丛书。</span><span class="sxs-lookup"><span data-stu-id="41c56-224">As Figure 2 shows, I ve added a `BirthDate` column to the `Authors` table, removed the `ISBN` column from the `Books` table, and added a new table, `Ratings`, which is meant to let users visiting the site rate the reviewed books.</span></span>

> [!NOTE]
> <span data-ttu-id="41c56-225">在本教程中所做的数据模型更改是为了演示如何使用数据库比较工具。</span><span class="sxs-lookup"><span data-stu-id="41c56-225">The data model changes made in this tutorial were done to illustrate using a database comparison tool.</span></span> <span data-ttu-id="41c56-226">不会在将来的教程中在数据库中查找这些更改。</span><span class="sxs-lookup"><span data-stu-id="41c56-226">You will not find these changes in the database in future tutorials.</span></span>


<span data-ttu-id="41c56-227">[![SQL 比较列出了开发和生产数据库之间的差异](strategies-for-database-development-and-deployment-cs/_static/image5.jpg)](strategies-for-database-development-and-deployment-cs/_static/image4.jpg)</span><span class="sxs-lookup"><span data-stu-id="41c56-227">[![SQL Compare Lists the Differences Between the Development and Production Databases](strategies-for-database-development-and-deployment-cs/_static/image5.jpg)](strategies-for-database-development-and-deployment-cs/_static/image4.jpg)</span></span>

<span data-ttu-id="41c56-228">**图 2**: SQL 比较列出了开发之间的差异和生产数据库 ([单击以查看实际尺寸的图像](strategies-for-database-development-and-deployment-cs/_static/image6.jpg))</span><span class="sxs-lookup"><span data-stu-id="41c56-228">**Figure 2**: SQL Compare Lists the Differences Between the Development and Production Databases ([Click to view full-size image](strategies-for-database-development-and-deployment-cs/_static/image6.jpg))</span></span>


<span data-ttu-id="41c56-229">SQL Compare 分解成组的数据库对象、 快速显示哪些对象存在于这两个数据库中但不同，该对象存在于一个数据库，但不是另一个，和的对象相同。</span><span class="sxs-lookup"><span data-stu-id="41c56-229">SQL Compare breaks down the database objects into groups, quickly showing you what objects exist in both databases but are different, which objects exist in one database but not the other, and which objects are identical.</span></span> <span data-ttu-id="41c56-230">正如您所看到的有两个数据库中存在但不同的两个对象：`Authors`表，该表具有添加的列，和`Books`表，该表包含一个删除。</span><span class="sxs-lookup"><span data-stu-id="41c56-230">As you can see, there are two objects that exist in both databases but are different: the `Authors` table, which had a column added, and the `Books` table, which had one removed.</span></span> <span data-ttu-id="41c56-231">只能在开发数据库，即新创建中存在的一个对象`Ratings`表。</span><span class="sxs-lookup"><span data-stu-id="41c56-231">There is one object that exists only in the development database, namely the newly created `Ratings` table.</span></span> <span data-ttu-id="41c56-232">并且有两个数据库中完全相同的 117 对象。</span><span class="sxs-lookup"><span data-stu-id="41c56-232">And there are 117 objects that are identical in both databases.</span></span>

<span data-ttu-id="41c56-233">选择数据库对象将显示 SQL 差异窗口，其中显示了这些对象有何不同。</span><span class="sxs-lookup"><span data-stu-id="41c56-233">Selecting a database object displays the SQL Differences window, which shows how these objects differ.</span></span> <span data-ttu-id="41c56-234">SQL 差异窗口中，在图 2 中，底部显示突出显示的`Authors`开发数据库表中的有`BirthDate`列，该列中找不到`Authors`生产数据库上的表。</span><span class="sxs-lookup"><span data-stu-id="41c56-234">The SQL Differences window, displayed at the bottom in Figure 2, highlights that the `Authors` table in the development database has the `BirthDate` column, which is not found in the `Authors` table on the production database.</span></span>

<span data-ttu-id="41c56-235">后查看差异，并选择你想要同步的对象下, 一步是生成更新生产数据库的架构所需的 SQL 命令以匹配开发数据库。</span><span class="sxs-lookup"><span data-stu-id="41c56-235">After reviewing the differences and selecting which objects you want to synchronize, the next step is to generate the SQL commands needed to update the production database s schema to match the development database.</span></span> <span data-ttu-id="41c56-236">通过同步向导完成此操作。</span><span class="sxs-lookup"><span data-stu-id="41c56-236">This is accomplished through the Synchronization Wizard.</span></span> <span data-ttu-id="41c56-237">同步向导确认哪些对象同步，并总结了该操作计划 （参见图 3）。</span><span class="sxs-lookup"><span data-stu-id="41c56-237">The Synchronization Wizard confirms what objects to synchronize and summarizes the action plan (see Figure 3).</span></span> <span data-ttu-id="41c56-238">您可以立即同步数据库或生成具有可以在方便的时候运行的 SQL 命令的脚本。</span><span class="sxs-lookup"><span data-stu-id="41c56-238">You can synchronize the databases immediately or generate a script with the SQL commands that can be run at your leisure.</span></span>


<span data-ttu-id="41c56-239">[![使用同步向导以同步数据库架构](strategies-for-database-development-and-deployment-cs/_static/image8.jpg)](strategies-for-database-development-and-deployment-cs/_static/image7.jpg)</span><span class="sxs-lookup"><span data-stu-id="41c56-239">[![Use the Synchronization Wizard to Synchronize Your Databases Schemas](strategies-for-database-development-and-deployment-cs/_static/image8.jpg)](strategies-for-database-development-and-deployment-cs/_static/image7.jpg)</span></span>

<span data-ttu-id="41c56-240">**图 3**： 使用同步向导来同步数据库架构 ([单击以查看实际尺寸的图像](strategies-for-database-development-and-deployment-cs/_static/image9.jpg))</span><span class="sxs-lookup"><span data-stu-id="41c56-240">**Figure 3**: Use the Synchronization Wizard to Synchronize Your Databases Schemas ([Click to view full-size image](strategies-for-database-development-and-deployment-cs/_static/image9.jpg))</span></span>


<span data-ttu-id="41c56-241">数据库比较工具，如 Red Gate Software 的 SQL Compare 请将所做的更改应用到开发数据库架构与生产数据库指向和单击一样简单。</span><span class="sxs-lookup"><span data-stu-id="41c56-241">Database comparison tools like Red Gate Software s SQL Compare make applying the changes to the development database schema to the production database as easy as point and click.</span></span>

> [!NOTE]
> <span data-ttu-id="41c56-242">SQL 比较进行比较和同步两个数据库*架构*。</span><span class="sxs-lookup"><span data-stu-id="41c56-242">SQL Compare compares and synchronizes two databases *schemas*.</span></span> <span data-ttu-id="41c56-243">遗憾的是，它不进行比较和同步两个数据库表中的数据。</span><span class="sxs-lookup"><span data-stu-id="41c56-243">Unfortunately, it does not compare and synchronize the data within two databases tables.</span></span> <span data-ttu-id="41c56-244">Red Gate Software 提供的名为产品[ *SQL 数据比较*](http://www.red-gate.com/products/SQL_Data_Compare/)的比较和两个数据库之间同步数据，但它是从 SQL Compare 一个单独的产品，另一个 395 美元的费用。</span><span class="sxs-lookup"><span data-stu-id="41c56-244">Red Gate Software does offer a product named [*SQL Data Compare*](http://www.red-gate.com/products/SQL_Data_Compare/) that compares and synchronizes the data between two databases, but it is a separate product from SQL Compare and costs another $395.</span></span>


## <a name="taking-the-application-offline-during-deployment"></a><span data-ttu-id="41c56-245">使应用程序脱机部署过程</span><span class="sxs-lookup"><span data-stu-id="41c56-245">Taking the Application Offline During Deployment</span></span>

<span data-ttu-id="41c56-246">正如我们已看到在这些教程中，整个部署是一个过程，涉及多个步骤： 将从开发环境的 ASP.NET 页、 母版页、 CSS 文件、 JavaScript 文件、 图像和其他所需的内容复制到生产环境环境中;将复制生产环境特定的配置信息，如果需要;和自上次部署以来将所做的更改应用于数据模型。</span><span class="sxs-lookup"><span data-stu-id="41c56-246">As we ve seen throughout these tutorials, deployment is a process that involves multiple steps: copying the ASP.NET pages, master pages, CSS files, JavaScript files, images, and other necessary content from the development environment to the production environment; copying up the production environment-specific configuration information, if needed; and applying the changes to the data model since the last deployment.</span></span> <span data-ttu-id="41c56-247">具体取决于的文件数和更改数据库的复杂性，这些步骤可能需要从几秒钟到几分钟时间才能完成。</span><span class="sxs-lookup"><span data-stu-id="41c56-247">Depending on the number of files and the complexity of your database changes, these steps can take anywhere from a few seconds to several minutes to complete.</span></span> <span data-ttu-id="41c56-248">在此时段内的 web 应用程序在不断变化，并访问网站的用户可能会遇到错误或意外的行为。</span><span class="sxs-lookup"><span data-stu-id="41c56-248">During this window the web application is in flux and users visiting the site may experience errors or unexpected behavior.</span></span>

<span data-ttu-id="41c56-249">部署网站时，最好使 web 应用程序"脱机"直至部署已完成。</span><span class="sxs-lookup"><span data-stu-id="41c56-249">When deploying a website it is best to take the web application "offline" until deployment has completed.</span></span> <span data-ttu-id="41c56-250">使应用程序脱机 （和将其重新启动后在部署过程完成后） 非常简单，只将文件上传，然后将其删除。</span><span class="sxs-lookup"><span data-stu-id="41c56-250">Taking the application offline (and bringing it back up once the deployment process has finished) is as easy as uploading a file and then deleting it.</span></span> <span data-ttu-id="41c56-251">从 ASP.NET 2.0 中，名为的文件的存在`app_offline.htm`在应用程序根目录使整个网站"脱机"。</span><span class="sxs-lookup"><span data-stu-id="41c56-251">Starting with ASP.NET 2.0, the mere presence of a file named `app_offline.htm` in the application s root directory takes the entire website "offline."</span></span> <span data-ttu-id="41c56-252">对该站点上的 ASP.NET 页的任何请求自动进行响应的内容与`app_offline.htm`文件。</span><span class="sxs-lookup"><span data-stu-id="41c56-252">Any request to an ASP.NET page on that site is automatically responded with the contents of the `app_offline.htm` file.</span></span> <span data-ttu-id="41c56-253">删除该文件后，应用程序重新联机。</span><span class="sxs-lookup"><span data-stu-id="41c56-253">Once that file is removed, the application comes back online.</span></span>

<span data-ttu-id="41c56-254">采用应用程序脱机在部署期间，然后，只需上传`app_offline.htm`到生产环境的文件根目录之前开始部署过程并随后将它删除 （或将其更名为其他内容） 一次部署已完成。</span><span class="sxs-lookup"><span data-stu-id="41c56-254">Taking an application offline during deployment, then, is as simple as uploading an `app_offline.htm` file to the production environment s root directory prior to beginning the deployment process and then deleting it (or renaming it to something else) once deployment is complete.</span></span> <span data-ttu-id="41c56-255">有关此技术的详细信息请参阅 John Peterson 的文章，采用[ *ASP.NET 应用程序脱机*](http://www.15seconds.com/issue/061207.htm)。</span><span class="sxs-lookup"><span data-stu-id="41c56-255">For more information on this technique refer to John Peterson s article, Taking an [*ASP.NET Application Offline*](http://www.15seconds.com/issue/061207.htm).</span></span>

## <a name="summary"></a><span data-ttu-id="41c56-256">总结</span><span class="sxs-lookup"><span data-stu-id="41c56-256">Summary</span></span>

<span data-ttu-id="41c56-257">在部署数据驱动的应用程序的主要挑战是围绕将数据库部署。</span><span class="sxs-lookup"><span data-stu-id="41c56-257">The main challenge in deploying a data-driven application centers around deploying the database.</span></span> <span data-ttu-id="41c56-258">因为有两个版本的数据库的一个开发环境中，一个在生产环境中的这些两个数据库架构可能会成为同步，因为在开发过程中添加新功能。</span><span class="sxs-lookup"><span data-stu-id="41c56-258">Because there are two versions of the database - one in the development environment and one in the production environment - these two databases schemas can become out of sync as new features are added in development.</span></span> <span data-ttu-id="41c56-259">新增更多，因为正在使用真实用户的实际数据填充为生产数据库，您不能覆盖生产数据库与已修改的开发数据库像你可以部署对构成应用程序 （ASP.NET 页的文件时图像文件等）。</span><span class="sxs-lookup"><span data-stu-id="41c56-259">What s more, because the production database as being populated with real data from real users, you cannot overwrite the production database with the modified development database like you can when deploying the files that make up the application (the ASP.NET pages, image files, and so forth).</span></span> <span data-ttu-id="41c56-260">相反，将数据库部署需要实现的精确的一套自上次部署以来对生产数据库上的开发数据库所做更改。</span><span class="sxs-lookup"><span data-stu-id="41c56-260">Instead, deploying a database entails implementing the precise set of changes made to the development database on the production database since the last deployment.</span></span>

<span data-ttu-id="41c56-261">本教程介绍了用于维护并将数据库更改的日志应用三种方法。</span><span class="sxs-lookup"><span data-stu-id="41c56-261">This tutorial looked at three techniques for maintaining and applying a log of database changes.</span></span> <span data-ttu-id="41c56-262">最简单的方法是将中的文本信息记录所做的更改。</span><span class="sxs-lookup"><span data-stu-id="41c56-262">The simplest approach is to record the changes in prose.</span></span> <span data-ttu-id="41c56-263">虽然这种做法使一个手动过程在生产数据库上实现这些更改，它不需要了解的 SQL 命令用于创建和更改数据库对象。</span><span class="sxs-lookup"><span data-stu-id="41c56-263">While this tactic makes implementing these changes on the production database a manual process, it does not require knowledge of the SQL commands for creating and altering database objects.</span></span> <span data-ttu-id="41c56-264">更好的方法，以及在更大的项目或项目中使用多个开发人员而言，变得更加愉快的一个是作为一系列 SQL 命令记录所做的更改。</span><span class="sxs-lookup"><span data-stu-id="41c56-264">A more sophisticated approach, and one that is much more palatable in larger projects or projects with multiple developers, is to record the changes as a series of SQL commands.</span></span> <span data-ttu-id="41c56-265">这极大地 hastens 推出到目标数据库的这些更改。</span><span class="sxs-lookup"><span data-stu-id="41c56-265">This greatly hastens rolling out these changes to the target database.</span></span> <span data-ttu-id="41c56-266">最佳的这两种方法可以通过使用 Red Gate Software 的 SQL Compare 之类的数据库比较工具。</span><span class="sxs-lookup"><span data-stu-id="41c56-266">The best of both approaches can be achieved by using a database comparison tool, such as Red Gate Software s SQL Compare.</span></span>

<span data-ttu-id="41c56-267">本教程最后，我们专注于数据驱动的应用程序部署。</span><span class="sxs-lookup"><span data-stu-id="41c56-267">This tutorial concludes our focus on deploying a data-driven application.</span></span> <span data-ttu-id="41c56-268">下一步的系列教程探讨如何在生产环境中的错误响应。</span><span class="sxs-lookup"><span data-stu-id="41c56-268">The next set of tutorials looks at how to respond to errors in the production environment.</span></span> <span data-ttu-id="41c56-269">我们将介绍如何显示友好的错误页，而不是而不是黄色死亡屏幕。</span><span class="sxs-lookup"><span data-stu-id="41c56-269">We'll look at how to display a friendly error page rather instead of the Yellow Screen of Death.</span></span> <span data-ttu-id="41c56-270">我们将了解如何记录错误 s 详细信息以及如何进行此类错误发生时发出警报。</span><span class="sxs-lookup"><span data-stu-id="41c56-270">And we'll see how to log the error s details and how to alert you when such errors occur.</span></span>

<span data-ttu-id="41c56-271">快乐编程 ！</span><span class="sxs-lookup"><span data-stu-id="41c56-271">Happy Programming!</span></span>

> [!div class="step-by-step"]
> <span data-ttu-id="41c56-272">[上一页](configuring-a-website-that-uses-application-services-cs.md)
> [下一页](displaying-a-custom-error-page-cs.md)</span><span class="sxs-lookup"><span data-stu-id="41c56-272">[Previous](configuring-a-website-that-uses-application-services-cs.md)
[Next](displaying-a-custom-error-page-cs.md)</span></span>
