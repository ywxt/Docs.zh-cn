---
uid: web-forms/overview/advanced/aspnet-web-forms-connection-resiliency-and-command-interception
title: ASP.NET Web 窗体连接复原和命令截获 |Microsoft Docs
author: Erikre
description: 本教程介绍如何修改示例应用程序以支持连接复原和命令截获。
ms.author: aspnetcontent
ms.date: 03/31/2014
ms.assetid: 6d497001-fa80-4765-b4cc-181fe90b894e
msc.legacyurl: /web-forms/overview/advanced/aspnet-web-forms-connection-resiliency-and-command-interception
msc.type: authoredcontent
ms.openlocfilehash: 9a66b297608a5a8cd536b9af2a9ae4bb600a6bbb
ms.sourcegitcommit: b28cd0313af316c051c2ff8549865bff67f2fbb4
ms.translationtype: MT
ms.contentlocale: zh-CN
ms.lasthandoff: 07/05/2018
ms.locfileid: "37807084"
---
<a name="aspnet-web-forms-connection-resiliency-and-command-interception"></a><span data-ttu-id="b56d3-103">ASP.NET Web 窗体连接复原和命令截获</span><span class="sxs-lookup"><span data-stu-id="b56d3-103">ASP.NET Web Forms Connection Resiliency and Command Interception</span></span>
====================
<span data-ttu-id="b56d3-104">通过[Erik Reitan](https://github.com/Erikre)</span><span class="sxs-lookup"><span data-stu-id="b56d3-104">by [Erik Reitan](https://github.com/Erikre)</span></span>

<span data-ttu-id="b56d3-105">在本教程中，您将修改 Wingtip Toys 示例应用程序以支持连接复原和命令截获。</span><span class="sxs-lookup"><span data-stu-id="b56d3-105">In this tutorial, you will modify the Wingtip Toys sample application to support connection resiliency and command interception.</span></span> <span data-ttu-id="b56d3-106">通过启用连接复原，Wingtip Toys 示例应用程序将自动重试数据调用发生暂时性错误典型的云环境时。</span><span class="sxs-lookup"><span data-stu-id="b56d3-106">By enabling connection resiliency, the Wingtip Toys sample application will automatically retry data calls when transient errors typical of a cloud environment occur.</span></span> <span data-ttu-id="b56d3-107">此外，通过实施命令拦截，Wingtip Toys 示例应用程序将捕获所有发送到数据库才能登录或更改它们的 SQL 查询。</span><span class="sxs-lookup"><span data-stu-id="b56d3-107">Also, by implementing command interception, the Wingtip Toys sample application will catch all SQL queries sent to the database in order to log or change them.</span></span>

> [!NOTE] 
> 
> <span data-ttu-id="b56d3-108">此 Web 窗体教程基于 Tom Dykstra 以下 MVC 教程：</span><span class="sxs-lookup"><span data-stu-id="b56d3-108">This Web Forms tutorial was based on Tom Dykstra's following MVC tutorial:</span></span>  
> [<span data-ttu-id="b56d3-109">连接复原和命令截获与 ASP.NET MVC 应用程序中的实体框架</span><span class="sxs-lookup"><span data-stu-id="b56d3-109">Connection Resiliency and Command Interception with the Entity Framework in an ASP.NET MVC Application</span></span>](../../../mvc/overview/getting-started/getting-started-with-ef-using-mvc/connection-resiliency-and-command-interception-with-the-entity-framework-in-an-asp-net-mvc-application.md)


## <a name="what-youll-learn"></a><span data-ttu-id="b56d3-110">你将学习：</span><span class="sxs-lookup"><span data-stu-id="b56d3-110">What you'll learn:</span></span>

- <span data-ttu-id="b56d3-111">如何提供连接复原能力。</span><span class="sxs-lookup"><span data-stu-id="b56d3-111">How to provide connection resiliency.</span></span>
- <span data-ttu-id="b56d3-112">如何实现命令拦截。</span><span class="sxs-lookup"><span data-stu-id="b56d3-112">How to implement command interception.</span></span>

## <a name="prerequisites"></a><span data-ttu-id="b56d3-113">系统必备</span><span class="sxs-lookup"><span data-stu-id="b56d3-113">Prerequisites</span></span>

<span data-ttu-id="b56d3-114">在开始之前，请确保您已在计算机上安装以下软件：</span><span class="sxs-lookup"><span data-stu-id="b56d3-114">Before you start, make sure that you have the following software installed on your computer:</span></span>

- <span data-ttu-id="b56d3-115">[Microsoft Visual Studio 2013](https://www.microsoft.com/visualstudio/11/downloads#vs)或[Microsoft Visual Studio Express 2013 for Web](https://www.microsoft.com/visualstudio/11/downloads#express-web)。</span><span class="sxs-lookup"><span data-stu-id="b56d3-115">[Microsoft Visual Studio 2013](https://www.microsoft.com/visualstudio/11/downloads#vs) or [Microsoft Visual Studio Express 2013 for Web](https://www.microsoft.com/visualstudio/11/downloads#express-web).</span></span> <span data-ttu-id="b56d3-116">会自动安装.NET Framework。</span><span class="sxs-lookup"><span data-stu-id="b56d3-116">The .NET Framework is installed automatically.</span></span>
- <span data-ttu-id="b56d3-117">Wingtip Toys 示例项目中，以便可以实现在本教程中 Wingtip Toys 项目中所述的功能。</span><span class="sxs-lookup"><span data-stu-id="b56d3-117">The Wingtip Toys sample project, so that you can implement the functionality mentioned in this tutorial within the Wingtip Toys project.</span></span> <span data-ttu-id="b56d3-118">以下链接提供了下载详细信息：</span><span class="sxs-lookup"><span data-stu-id="b56d3-118">The following link provides download details:</span></span>

    - <span data-ttu-id="b56d3-119">[Getting Started with ASP.NET 4.5.1 Web 窗体的 Wingtip Toys](https://go.microsoft.com/fwlink/?LinkID=389434&amp;clcid=0x409) (C#)</span><span class="sxs-lookup"><span data-stu-id="b56d3-119">[Getting Started with ASP.NET 4.5.1 Web Forms - Wingtip Toys](https://go.microsoft.com/fwlink/?LinkID=389434&amp;clcid=0x409) (C#)</span></span>
- <span data-ttu-id="b56d3-120">本教程之前，请考虑查看相关的教程系列[Getting Started with ASP.NET 4.5 Web 窗体和 Visual Studio 2013](../getting-started/getting-started-with-aspnet-45-web-forms/introduction-and-overview.md)。</span><span class="sxs-lookup"><span data-stu-id="b56d3-120">Prior to completing this tutorial, consider reviewing the related tutorial series, [Getting Started with ASP.NET 4.5 Web Forms and Visual Studio 2013](../getting-started/getting-started-with-aspnet-45-web-forms/introduction-and-overview.md).</span></span> <span data-ttu-id="b56d3-121">此教程系列将帮助你熟悉**WingtipToys**项目和代码。</span><span class="sxs-lookup"><span data-stu-id="b56d3-121">The tutorial series will help you become familiar with the **WingtipToys** project and code.</span></span>

## <a name="connection-resiliency"></a><span data-ttu-id="b56d3-122">连接复原</span><span class="sxs-lookup"><span data-stu-id="b56d3-122">Connection resiliency</span></span>

<span data-ttu-id="b56d3-123">考虑到 Windows Azure 应用程序部署时，要考虑的一个选项部署到的数据库**Windows** **Azure SQL 数据库**，云数据库服务。</span><span class="sxs-lookup"><span data-stu-id="b56d3-123">When you consider deploying an application to Windows Azure, one option to consider is deploying the database to **Windows** **Azure SQL Database**, a cloud database service.</span></span> <span data-ttu-id="b56d3-124">连接到比你的 web 服务器和数据库服务器直接连接时一起位于同一数据中心的云数据库服务时，暂时性连接错误是通常更频繁。</span><span class="sxs-lookup"><span data-stu-id="b56d3-124">Transient connection errors are typically more frequent when you connect to a cloud database service than when your web server and your database server are directly connected together in the same data center.</span></span> <span data-ttu-id="b56d3-125">即使在同一数据中心托管的云 web 服务器和云数据库服务，有更多的网络连接，它们可以出现问题，例如负载均衡器之间。</span><span class="sxs-lookup"><span data-stu-id="b56d3-125">Even if a cloud web server and a cloud database service are hosted in the same data center, there are more network connections between them that can have problems, such as load balancers.</span></span>

<span data-ttu-id="b56d3-126">此外云服务是通常由其他用户共享，这意味着其响应能力可能受到它们。</span><span class="sxs-lookup"><span data-stu-id="b56d3-126">Also a cloud service is typically shared by other users, which means its responsiveness can be affected by them.</span></span> <span data-ttu-id="b56d3-127">并且您对数据库访问权限可能会受到限制。</span><span class="sxs-lookup"><span data-stu-id="b56d3-127">And your access to the database might be subject to throttling.</span></span> <span data-ttu-id="b56d3-128">限制意味着数据库服务会引发异常，当您尝试超出允许的更频繁地访问您*服务级别协议*(SLA)。</span><span class="sxs-lookup"><span data-stu-id="b56d3-128">Throttling means the database service throws exceptions when you try to access it more frequently than is allowed in your *Service Level Agreement* (SLA).</span></span>

<span data-ttu-id="b56d3-129">许多或大部分发生时正在访问云服务的连接问题是暂时的也就是说，他们自身解决在短时间的时间。</span><span class="sxs-lookup"><span data-stu-id="b56d3-129">Many or most connection problems that occur when you're accessing a cloud service are transient, that is, they resolve themselves in a short period of time.</span></span> <span data-ttu-id="b56d3-130">因此在重试数据库操作并获得一种类型的通常是暂时的错误，稍等片刻，该操作可能会成功后无法重试该操作。</span><span class="sxs-lookup"><span data-stu-id="b56d3-130">So when you try a database operation and get a type of error that is typically transient, you could try the operation again after a short wait, and the operation might be successful.</span></span> <span data-ttu-id="b56d3-131">如果通过自动尝试再次，处理暂时性错误，可以为用户提供更好的体验使其中的大多数客户不可见。</span><span class="sxs-lookup"><span data-stu-id="b56d3-131">You can provide a much better experience for your users if you handle transient errors by automatically trying again, making most of them invisible to the customer.</span></span> <span data-ttu-id="b56d3-132">连接复原功能在 Entity Framework 6 中的自动执行的重试过程失败的 SQL 查询。</span><span class="sxs-lookup"><span data-stu-id="b56d3-132">The connection resiliency feature in Entity Framework 6 automates that process of retrying failed SQL queries.</span></span>

<span data-ttu-id="b56d3-133">针对特定数据库服务，必须适当地配置连接复原功能：</span><span class="sxs-lookup"><span data-stu-id="b56d3-133">The connection resiliency feature must be configured appropriately for a particular database service:</span></span>

1. <span data-ttu-id="b56d3-134">它必须知道哪些异常可能是暂时的。</span><span class="sxs-lookup"><span data-stu-id="b56d3-134">It has to know which exceptions are likely to be transient.</span></span> <span data-ttu-id="b56d3-135">你想要重试错误引起暂时失去网络连接中不由程序 bug，例如引起的错误。</span><span class="sxs-lookup"><span data-stu-id="b56d3-135">You want to retry errors caused by a temporary loss in network connectivity, not errors caused by program bugs, for example.</span></span>
2. <span data-ttu-id="b56d3-136">它必须等待适当的重试的失败的操作之间的时间。</span><span class="sxs-lookup"><span data-stu-id="b56d3-136">It has to wait an appropriate amount of time between retries of a failed operation.</span></span> <span data-ttu-id="b56d3-137">你可以等待更长时间进行批处理的重试之间不是可以在线网页用户正在等待响应。</span><span class="sxs-lookup"><span data-stu-id="b56d3-137">You can wait longer between retries for a batch process than you can for an online web page where a user is waiting for a response.</span></span>
3. <span data-ttu-id="b56d3-138">它具有重试的次数之前放弃适当数量。</span><span class="sxs-lookup"><span data-stu-id="b56d3-138">It has to retry an appropriate number of times before it gives up.</span></span> <span data-ttu-id="b56d3-139">您可能想要重试更多次，就像在一个在线应用程序中的批处理中。</span><span class="sxs-lookup"><span data-stu-id="b56d3-139">You might want to retry more times in a batch process that you would in an online application.</span></span>

<span data-ttu-id="b56d3-140">你可以配置这些设置手动为实体框架提供程序支持的任何数据库环境。</span><span class="sxs-lookup"><span data-stu-id="b56d3-140">You can configure these settings manually for any database environment supported by an Entity Framework provider.</span></span>

<span data-ttu-id="b56d3-141">您只需启用连接复原的就是您的程序集派生中创建一个类`DbConfiguration`类，并在该类中设置 SQL 数据库执行策略，它在实体框架为另一种说法重试策略。</span><span class="sxs-lookup"><span data-stu-id="b56d3-141">All you have to do to enable connection resiliency is create a class in your assembly that derives from the `DbConfiguration` class, and in that class set the SQL Database execution strategy, which in Entity Framework is another term for retry policy.</span></span>

### <a name="implementing-connection-resiliency"></a><span data-ttu-id="b56d3-142">实现连接复原</span><span class="sxs-lookup"><span data-stu-id="b56d3-142">Implementing connection resiliency</span></span>

1. <span data-ttu-id="b56d3-143">下载并打开[WingtipToys](https://go.microsoft.com/fwlink/?LinkID=389434&amp;clcid=0x409)示例在 Visual Studio 中的 Web 窗体应用程序。</span><span class="sxs-lookup"><span data-stu-id="b56d3-143">Download and open the [WingtipToys](https://go.microsoft.com/fwlink/?LinkID=389434&amp;clcid=0x409) sample Web Forms application in Visual Studio.</span></span>
2. <span data-ttu-id="b56d3-144">在中*逻辑*的文件夹**WingtipToys**应用程序中，添加名为的类文件*WingtipToysConfiguration.cs*。</span><span class="sxs-lookup"><span data-stu-id="b56d3-144">In the *Logic* folder of the **WingtipToys** application, add a class file named *WingtipToysConfiguration.cs*.</span></span>
3. <span data-ttu-id="b56d3-145">用下面的代码替换现有代码：</span><span class="sxs-lookup"><span data-stu-id="b56d3-145">Replace the existing code with the following code:</span></span>  

    [!code-csharp[Main](aspnet-web-forms-connection-resiliency-and-command-interception/samples/sample1.cs)]

<span data-ttu-id="b56d3-146">实体框架将自动运行的代码在派生类中找到`DbConfiguration`。</span><span class="sxs-lookup"><span data-stu-id="b56d3-146">The Entity Framework automatically runs the code it finds in a class that derives from `DbConfiguration`.</span></span> <span data-ttu-id="b56d3-147">可以使用`DbConfiguration`类，以执行在中否则所执行的操作的代码中的配置任务*Web.config*文件。</span><span class="sxs-lookup"><span data-stu-id="b56d3-147">You can use the `DbConfiguration` class to do configuration tasks in code that you would otherwise do in the *Web.config* file.</span></span> <span data-ttu-id="b56d3-148">有关详细信息，请参阅[EntityFramework 基于代码的配置](https://msdn.microsoft.com/data/jj680699)。</span><span class="sxs-lookup"><span data-stu-id="b56d3-148">For more information, see [EntityFramework Code-Based Configuration](https://msdn.microsoft.com/data/jj680699).</span></span>

1. <span data-ttu-id="b56d3-149">在中*逻辑*文件夹中，打开*AddProducts.cs*文件。</span><span class="sxs-lookup"><span data-stu-id="b56d3-149">In the *Logic* folder, open the *AddProducts.cs* file.</span></span>
2. <span data-ttu-id="b56d3-150">添加`using`语句`System.Data.Entity.Infrastructure`以黄色突出显示所示：</span><span class="sxs-lookup"><span data-stu-id="b56d3-150">Add a `using` statement for `System.Data.Entity.Infrastructure` as shown highlighted in yellow:</span></span>  

    [!code-csharp[Main](aspnet-web-forms-connection-resiliency-and-command-interception/samples/sample2.cs?highlight=6)]
3. <span data-ttu-id="b56d3-151">添加`catch`阻止`AddProduct`方法，以便`RetryLimitExceededException`记录以黄色突出显示为：</span><span class="sxs-lookup"><span data-stu-id="b56d3-151">Add a `catch` block to the `AddProduct` method so that the `RetryLimitExceededException` is logged as highlighted in yellow:</span></span>   

    [!code-csharp[Main](aspnet-web-forms-connection-resiliency-and-command-interception/samples/sample3.cs?highlight=14-15,17-22)]

<span data-ttu-id="b56d3-152">通过添加`RetryLimitExceededException`异常，你可以提供更好地日志记录或到他们可以选择要再次尝试该过程的用户显示一条错误消息。</span><span class="sxs-lookup"><span data-stu-id="b56d3-152">By adding the `RetryLimitExceededException` exception, you can provide better logging or display an error message to the user where they can choose to try the process again.</span></span> <span data-ttu-id="b56d3-153">通过捕获`RetryLimitExceededException`异常，可能是暂时性的唯一错误将已尝试并失败几次。</span><span class="sxs-lookup"><span data-stu-id="b56d3-153">By catching the `RetryLimitExceededException` exception, the only errors likely to be transient will already have been tried and failed several times.</span></span> <span data-ttu-id="b56d3-154">返回的实际异常将包装在`RetryLimitExceededException`异常。</span><span class="sxs-lookup"><span data-stu-id="b56d3-154">The actual exception returned will be wrapped in the `RetryLimitExceededException` exception.</span></span> <span data-ttu-id="b56d3-155">此外，您还添加了常规 catch 块。</span><span class="sxs-lookup"><span data-stu-id="b56d3-155">In addition, you also added a general catch block.</span></span> <span data-ttu-id="b56d3-156">有关详细信息`RetryLimitExceededException`异常，请参阅[实体框架连接复原 / 重试逻辑](https://msdn.microsoft.com/data/dn456835)。</span><span class="sxs-lookup"><span data-stu-id="b56d3-156">For more information about the `RetryLimitExceededException` exception, see [Entity Framework Connection Resiliency / Retry Logic](https://msdn.microsoft.com/data/dn456835).</span></span>

## <a name="command-interception"></a><span data-ttu-id="b56d3-157">命令截获</span><span class="sxs-lookup"><span data-stu-id="b56d3-157">Command interception</span></span>

<span data-ttu-id="b56d3-158">现在，你已启用了重试策略，如何你测试以验证它是否按预期工作？</span><span class="sxs-lookup"><span data-stu-id="b56d3-158">Now that you've turned on a retry policy, how do you test to verify that it is working as expected?</span></span> <span data-ttu-id="b56d3-159">不可以十分轻松地强制暂时性错误发生，尤其是当您在本地，运行和会特别难以将实际的暂时性错误集成到自动化的单元测试。</span><span class="sxs-lookup"><span data-stu-id="b56d3-159">It's not so easy to force a transient error to happen, especially when you're running locally, and it would be especially difficult to integrate actual transient errors into an automated unit test.</span></span> <span data-ttu-id="b56d3-160">若要测试连接复原功能，您需要一种方法截获 Entity Framework 将发送到 SQL Server 的查询和 SQL Server 响应替换通常是暂时异常类型。</span><span class="sxs-lookup"><span data-stu-id="b56d3-160">To test the connection resiliency feature, you need a way to intercept queries that Entity Framework sends to SQL Server and replace the SQL Server response with an exception type that is typically transient.</span></span>

<span data-ttu-id="b56d3-161">此外可以使用查询拦截，为了实现云应用程序的最佳做法： 日志的延迟和成功或失败的所有调用对外部服务 （如数据库服务）。</span><span class="sxs-lookup"><span data-stu-id="b56d3-161">You can also use query interception in order to implement a best practice for cloud applications: log the latency and success or failure of all calls to external services such as database services.</span></span>

<span data-ttu-id="b56d3-162">在本教程的本部分中，您将使用实体框架[*拦截功能*](https://msdn.microsoft.com/data/dn469464)进行日志记录和用于模拟暂时性错误。</span><span class="sxs-lookup"><span data-stu-id="b56d3-162">In this section of the tutorial you'll use the Entity Framework's [*interception feature*](https://msdn.microsoft.com/data/dn469464) both for logging and for simulating transient errors.</span></span>

### <a name="create-a-logging-interface-and-class"></a><span data-ttu-id="b56d3-163">创建日志记录接口和类</span><span class="sxs-lookup"><span data-stu-id="b56d3-163">Create a logging interface and class</span></span>

<span data-ttu-id="b56d3-164">日志记录的最佳做法是使用可完成的[ `interface` ](https://msdn.microsoft.com/library/ms173156.aspx)而不是硬编码调用`System.Diagnostics.Trace`或日志记录类。</span><span class="sxs-lookup"><span data-stu-id="b56d3-164">A best practice for logging is to do it by using an [`interface`](https://msdn.microsoft.com/library/ms173156.aspx) rather than hard-coding calls to `System.Diagnostics.Trace` or a logging class.</span></span> <span data-ttu-id="b56d3-165">这样，更轻松地更改更高版本的日志记录机制，如果您需要执行此操作。</span><span class="sxs-lookup"><span data-stu-id="b56d3-165">That makes it easier to change your logging mechanism later if you ever need to do that.</span></span> <span data-ttu-id="b56d3-166">因此在此部分中，您将创建日志记录接口和类来实现它。</span><span class="sxs-lookup"><span data-stu-id="b56d3-166">So in this section, you'll create the logging interface and a class to implement it.</span></span>

<span data-ttu-id="b56d3-167">根据上述过程，您必须下载并打开**WingtipToys**示例在 Visual Studio 中的应用程序。</span><span class="sxs-lookup"><span data-stu-id="b56d3-167">Based on the above procedure, you have downloaded and opened the **WingtipToys** sample application in Visual Studio.</span></span>

1. <span data-ttu-id="b56d3-168">创建一个文件夹中的**WingtipToys**项目，并命名*日志记录*。</span><span class="sxs-lookup"><span data-stu-id="b56d3-168">Create a folder in the **WingtipToys** project and name it *Logging*.</span></span>
2. <span data-ttu-id="b56d3-169">在中*日志记录*文件夹中，创建名为的类文件*ILogger.cs*和默认代码替换为以下代码：</span><span class="sxs-lookup"><span data-stu-id="b56d3-169">In the *Logging* folder, create a class file named *ILogger.cs* and replace the default code with the following code:</span></span>  

    [!code-csharp[Main](aspnet-web-forms-connection-resiliency-and-command-interception/samples/sample4.cs)]

   <span data-ttu-id="b56d3-170">该接口提供三种跟踪级别，以指示日志的相对重要性，另一个设计为提供对等数据库查询的外部服务调用的延迟信息。</span><span class="sxs-lookup"><span data-stu-id="b56d3-170">The interface provides three tracing levels to indicate the relative importance of logs, and one designed to provide latency information for external service calls such as database queries.</span></span> <span data-ttu-id="b56d3-171">日志记录方法具有重载，可传入异常。</span><span class="sxs-lookup"><span data-stu-id="b56d3-171">The logging methods have overloads that let you pass in an exception.</span></span> <span data-ttu-id="b56d3-172">这是这样实现的接口，而不是依赖于整个应用程序每个日志记录方法调用中完成这些操作后的类可靠地记录异常信息包括堆栈跟踪和内部异常信息。</span><span class="sxs-lookup"><span data-stu-id="b56d3-172">This is so that exception information including stack trace and inner exceptions is reliably logged by the class that implements the interface, instead of relying on that being done in each logging method call throughout the application.</span></span>  
  
   <span data-ttu-id="b56d3-173">`TraceApi`方法使您能够跟踪 SQL 数据库等外部服务每次调用的延迟。</span><span class="sxs-lookup"><span data-stu-id="b56d3-173">The `TraceApi` methods enable you to track the latency of each call to an external service such as SQL Database.</span></span>
3. <span data-ttu-id="b56d3-174">在中*日志记录*文件夹中，创建名为的类文件*Logger.cs*和默认代码替换为以下代码：</span><span class="sxs-lookup"><span data-stu-id="b56d3-174">In the *Logging* folder, create a class file named *Logger.cs* and replace the default code with the following code:</span></span>  

    [!code-csharp[Main](aspnet-web-forms-connection-resiliency-and-command-interception/samples/sample5.cs)]

<span data-ttu-id="b56d3-175">该实现使用`System.Diagnostics`以执行跟踪。</span><span class="sxs-lookup"><span data-stu-id="b56d3-175">The implementation uses `System.Diagnostics` to do the tracing.</span></span> <span data-ttu-id="b56d3-176">这是.NET 可以轻松生成和使用跟踪信息的内置功能。</span><span class="sxs-lookup"><span data-stu-id="b56d3-176">This is a built-in feature of .NET which makes it easy to generate and use tracing information.</span></span> <span data-ttu-id="b56d3-177">有许多&quot;侦听器&quot;可用于`System.Diagnostics`将日志写入文件，例如，或将它们写入 Windows Azure 中的 blob 存储的跟踪。</span><span class="sxs-lookup"><span data-stu-id="b56d3-177">There are many &quot;listeners&quot; you can use with `System.Diagnostics` tracing, to write logs to files, for example, or to write them to blob storage in Windows Azure.</span></span> <span data-ttu-id="b56d3-178">了解的一些选项，以及指向其他资源的详细信息，在[网站进行故障排除 Windows Azure 在 Visual Studio 中](https://docs.microsoft.com/azure/app-service-web/web-sites-dotnet-troubleshoot-visual-studio)。</span><span class="sxs-lookup"><span data-stu-id="b56d3-178">See some of the options, and links to other resources for more information, in [Troubleshooting Windows Azure Web Sites in Visual Studio](https://docs.microsoft.com/azure/app-service-web/web-sites-dotnet-troubleshoot-visual-studio).</span></span> <span data-ttu-id="b56d3-179">对于本教程，您将只能查看 Visual Studio 中的日志**输出**窗口。</span><span class="sxs-lookup"><span data-stu-id="b56d3-179">For this tutorial, you'll only look at logs in the Visual Studio **Output** window.</span></span>

<span data-ttu-id="b56d3-180">在生产应用程序可能需要考虑使用跟踪框架不`System.Diagnostics`，和`ILogger`interface 可以相对轻松，若要切换到不同的跟踪机制，如果你决定要执行此操作。</span><span class="sxs-lookup"><span data-stu-id="b56d3-180">In a production application you might want to consider using tracing frameworks other than `System.Diagnostics`, and the `ILogger` interface makes it relatively easy to switch to a different tracing mechanism if you decide to do that.</span></span>

### <a name="create-interceptor-classes"></a><span data-ttu-id="b56d3-181">创建侦听器类</span><span class="sxs-lookup"><span data-stu-id="b56d3-181">Create interceptor classes</span></span>

<span data-ttu-id="b56d3-182">接下来，将创建每次它会将查询发送到数据库，另一个来模拟暂时性错误进行日志记录时，实体框架会调用到的类。</span><span class="sxs-lookup"><span data-stu-id="b56d3-182">Next, you'll create the classes that the Entity Framework will call into every time it is going to send a query to the database, one to simulate transient errors and one to do logging.</span></span> <span data-ttu-id="b56d3-183">这些侦听器类必须派生自`DbCommandInterceptor`类。</span><span class="sxs-lookup"><span data-stu-id="b56d3-183">These interceptor classes must derive from the `DbCommandInterceptor` class.</span></span> <span data-ttu-id="b56d3-184">在其中，您编写查询时要在执行时自动调用的方法重写。</span><span class="sxs-lookup"><span data-stu-id="b56d3-184">In them, you write method overrides that are automatically called when the query is about to be executed.</span></span> <span data-ttu-id="b56d3-185">在这些方法可以检查或记录查询正被发送到数据库，并可以更改查询发送到数据库之前，也可以返回某些内容到实体框架自己而无需甚至将查询传递到数据库。</span><span class="sxs-lookup"><span data-stu-id="b56d3-185">In these methods you can examine or log the query that is being sent to the database, and you can change the query before it's sent to the database or return something to Entity Framework yourself without even passing the query to the database.</span></span>

1. <span data-ttu-id="b56d3-186">若要创建的侦听器类将记录每个 SQL 查询发送到数据库之前，创建名为的类文件*InterceptorLogging.cs*中*逻辑*文件夹并将替换为默认值的代码使用以下代码：</span><span class="sxs-lookup"><span data-stu-id="b56d3-186">To create the interceptor class that will log every SQL query before it is sent to the database, create a class file named *InterceptorLogging.cs* in the *Logic* folder and replace the default code with the following code:</span></span>  

    [!code-csharp[Main](aspnet-web-forms-connection-resiliency-and-command-interception/samples/sample6.cs)]

   <span data-ttu-id="b56d3-187">对于成功的查询或命令，此代码将写入延迟信息的信息的日志。</span><span class="sxs-lookup"><span data-stu-id="b56d3-187">For successful queries or commands, this code writes an Information log with latency information.</span></span> <span data-ttu-id="b56d3-188">有关例外情况，它创建错误日志。</span><span class="sxs-lookup"><span data-stu-id="b56d3-188">For exceptions, it creates an Error log.</span></span>
2. <span data-ttu-id="b56d3-189">若要创建在输入时，将生成虚拟的暂时性错误的侦听器类&quot;引发&quot;中**名称**名为页面上的文本框*AdminPage.aspx*，创建一个类名为的文件*InterceptorTransientErrors.cs*中*逻辑*文件夹并将替换为默认值的代码使用以下代码：</span><span class="sxs-lookup"><span data-stu-id="b56d3-189">To create the interceptor class that will generate dummy transient errors when you enter &quot;Throw&quot; in the **Name** textbox on the page named *AdminPage.aspx*, create a class file named *InterceptorTransientErrors.cs* in the *Logic* folder and replace the default code with the following code:</span></span>  

    [!code-csharp[Main](aspnet-web-forms-connection-resiliency-and-command-interception/samples/sample7.cs)]

    <span data-ttu-id="b56d3-190">此代码仅重写`ReaderExecuting`的查询，可以返回多行数据调用的方法。</span><span class="sxs-lookup"><span data-stu-id="b56d3-190">This code only overrides the `ReaderExecuting` method, which is called for queries that can return multiple rows of data.</span></span> <span data-ttu-id="b56d3-191">如果你想要检查连接复原对于其他类型的查询，还可以重写`NonQueryExecuting`和`ScalarExecuting`方法，作为日志记录侦听器执行。</span><span class="sxs-lookup"><span data-stu-id="b56d3-191">If you wanted to check connection resiliency for other types of queries, you could also override the `NonQueryExecuting` and `ScalarExecuting` methods, as the logging interceptor does.</span></span>  
  
   <span data-ttu-id="b56d3-192">更高版本，您将以"管理员"身份登录，并选择**管理员**顶部导航栏上的链接。</span><span class="sxs-lookup"><span data-stu-id="b56d3-192">Later, you will log in as the "Admin" and select the **Admin** link on the top navigation bar.</span></span> <span data-ttu-id="b56d3-193">然后，在*AdminPage.aspx*页将添加名为产品&quot;引发&quot;。</span><span class="sxs-lookup"><span data-stu-id="b56d3-193">Then, on the *AdminPage.aspx* page you will add a product named &quot;Throw&quot;.</span></span> <span data-ttu-id="b56d3-194">该代码创建虚拟 SQL 数据库异常的错误号 20，确定是通常暂时性的类型。</span><span class="sxs-lookup"><span data-stu-id="b56d3-194">The code creates a dummy SQL Database exception for error number 20, a type known to be typically transient.</span></span> <span data-ttu-id="b56d3-195">其他当前被识别为暂时性的错误编号均为 64、 233、 10053、 10054、 10060、 10928、 10929、 40197、 40501 和 40613，但它们是将在新版本的 SQL 数据库中进行。</span><span class="sxs-lookup"><span data-stu-id="b56d3-195">Other error numbers currently recognized as transient are 64, 233, 10053, 10054, 10060, 10928, 10929, 40197, 40501, and 40613, but these are subject to change in new versions of SQL Database.</span></span> <span data-ttu-id="b56d3-196">该产品将重命名为"TransientErrorExample"，可以按照中的代码*InterceptorTransientErrors.cs*文件。</span><span class="sxs-lookup"><span data-stu-id="b56d3-196">The product will be renamed to "TransientErrorExample", which you can follow in the code of the *InterceptorTransientErrors.cs* file.</span></span>  
  
   <span data-ttu-id="b56d3-197">该代码对实体框架，而不是运行查询并传递返回的结果返回的异常。</span><span class="sxs-lookup"><span data-stu-id="b56d3-197">The code returns the exception to Entity Framework instead of running the query and passing back results.</span></span> <span data-ttu-id="b56d3-198">返回暂时性异常*四个*次，然后代码将恢复到正常过程将查询传递到数据库。</span><span class="sxs-lookup"><span data-stu-id="b56d3-198">The transient exception is returned *four* times, and then the code reverts to the normal procedure of passing the query to the database.</span></span>

    <span data-ttu-id="b56d3-199">记录所有内容，因为您可以查看实体框架会尝试执行查询四次之后才最后成功，并在应用程序中唯一的区别是，花费更长时间才能呈现的页面包含查询结果。</span><span class="sxs-lookup"><span data-stu-id="b56d3-199">Because everything is logged, you'll be able to see that Entity Framework tries to execute the query four times before finally succeeding, and the only difference in the application is that it takes longer to render a page with query results.</span></span>  
  
   <span data-ttu-id="b56d3-200">实体框架将重试次数是可配置;该代码指定四次，因为这是 SQL 数据库执行策略的默认值。</span><span class="sxs-lookup"><span data-stu-id="b56d3-200">The number of times the Entity Framework will retry is configurable; the code specifies four times because that's the default value for the SQL Database execution policy.</span></span> <span data-ttu-id="b56d3-201">如果更改执行策略，则必须也更改的代码，指定生成暂时性错误的次数。</span><span class="sxs-lookup"><span data-stu-id="b56d3-201">If you change the execution policy, you'd also change the code here that specifies how many times transient errors are generated.</span></span> <span data-ttu-id="b56d3-202">您也可以更改代码以生成更多的异常，因此，实体框架将引发`RetryLimitExceededException`异常。</span><span class="sxs-lookup"><span data-stu-id="b56d3-202">You could also change the code to generate more exceptions so that Entity Framework will throw the `RetryLimitExceededException` exception.</span></span>
3. <span data-ttu-id="b56d3-203">在中*Global.asax*，添加以下 using 语句：</span><span class="sxs-lookup"><span data-stu-id="b56d3-203">In *Global.asax*, add the following using statements:</span></span>  

    [!code-csharp[Main](aspnet-web-forms-connection-resiliency-and-command-interception/samples/sample8.cs)]
4. <span data-ttu-id="b56d3-204">然后，将添加到突出显示的行`Application_Start`方法：</span><span class="sxs-lookup"><span data-stu-id="b56d3-204">Then, add the highlighted lines to the `Application_Start` method:</span></span>  

    [!code-csharp[Main](aspnet-web-forms-connection-resiliency-and-command-interception/samples/sample9.cs?highlight=17-20)]

<span data-ttu-id="b56d3-205">以下几行代码是哪些因素会导致在 Entity Framework 将查询发送到数据库时要运行的侦听器代码。</span><span class="sxs-lookup"><span data-stu-id="b56d3-205">These lines of code are what causes your interceptor code to be run when Entity Framework sends queries to the database.</span></span> <span data-ttu-id="b56d3-206">请注意，因为创建单独的侦听器类进行模拟暂时性错误和日志记录，你可以单独启用和禁用它们。</span><span class="sxs-lookup"><span data-stu-id="b56d3-206">Notice that because you created separate interceptor classes for transient error simulation and logging, you can independently enable and disable them.</span></span>   
  
 <span data-ttu-id="b56d3-207">您可以添加使用侦听器`DbInterception.Add`你的代码; 中的任意位置的方法其实不一定要在`Application_Start`方法。</span><span class="sxs-lookup"><span data-stu-id="b56d3-207">You can add interceptors using the `DbInterception.Add` method anywhere in your code; it doesn't have to be in the `Application_Start` method.</span></span> <span data-ttu-id="b56d3-208">另一个选项，如果您没有添加中的侦听器`Application_Start`方法，就是要更新或添加名为的类*WingtipToysConfiguration.cs*并将以上代码的构造函数的末尾添加`WingtipToysbConfiguration`类。</span><span class="sxs-lookup"><span data-stu-id="b56d3-208">Another option, if you didn't add interceptors in the `Application_Start` method, would be to update or add the class named *WingtipToysConfiguration.cs* and put the above code at the end of the constructor of the `WingtipToysbConfiguration` class.</span></span>

<span data-ttu-id="b56d3-209">只要您将此代码中，请注意不要执行`DbInterception.Add`相同的侦听器的时间超过一次，或者你将获得其他侦听器实例。</span><span class="sxs-lookup"><span data-stu-id="b56d3-209">Wherever you put this code, be careful not to execute `DbInterception.Add` for the same interceptor more than once, or you'll get additional interceptor instances.</span></span> <span data-ttu-id="b56d3-210">例如，如果两次添加日志记录的侦听器，将看到两个日志对于每个 SQL 查询。</span><span class="sxs-lookup"><span data-stu-id="b56d3-210">For example, if you add the logging interceptor twice, you'll see two logs for every SQL query.</span></span>

<span data-ttu-id="b56d3-211">侦听器执行以注册顺序 (依据的顺序`DbInterception.Add`调用方法)。</span><span class="sxs-lookup"><span data-stu-id="b56d3-211">Interceptors are executed in the order of registration (the order in which the `DbInterception.Add` method is called).</span></span> <span data-ttu-id="b56d3-212">顺序可能重要具体取决于你在侦听器中所执行的操作。</span><span class="sxs-lookup"><span data-stu-id="b56d3-212">The order might matter depending on what you're doing in the interceptor.</span></span> <span data-ttu-id="b56d3-213">例如，侦听器可能会更改 SQL 命令可获取中`CommandText`属性。</span><span class="sxs-lookup"><span data-stu-id="b56d3-213">For example, an interceptor might change the SQL command that it gets in the `CommandText` property.</span></span> <span data-ttu-id="b56d3-214">如果它确实发生更改的 SQL 命令下, 一步侦听器将获取已更改的 SQL 命令，而不是原始的 SQL 命令。</span><span class="sxs-lookup"><span data-stu-id="b56d3-214">If it does change the SQL command, the next interceptor will get the changed SQL command, not the original SQL command.</span></span>

<span data-ttu-id="b56d3-215">您已编写的暂时性错误模拟代码可以通过在 UI 中输入一个不同的值导致暂时性错误的方式。</span><span class="sxs-lookup"><span data-stu-id="b56d3-215">You've written the transient error simulation code in a way that lets you cause transient errors by entering a different value in the UI.</span></span> <span data-ttu-id="b56d3-216">或者，可以编写以始终生成暂时性异常的序列，而检查特定的参数值的侦听器代码。</span><span class="sxs-lookup"><span data-stu-id="b56d3-216">As an alternative, you could write the interceptor code to always generate the sequence of transient exceptions without checking for a particular parameter value.</span></span> <span data-ttu-id="b56d3-217">然后，仅当你想要生成暂时性错误时，可以添加侦听器。</span><span class="sxs-lookup"><span data-stu-id="b56d3-217">You could then add the interceptor only when you want to generate transient errors.</span></span> <span data-ttu-id="b56d3-218">如果这样做，但是，数据库初始化完成后不添加到侦听器。</span><span class="sxs-lookup"><span data-stu-id="b56d3-218">If you do this, however, don't add the interceptor until after database initialization has completed.</span></span> <span data-ttu-id="b56d3-219">换而言之，执行如查询一个实体集上的至少一个数据库操作，然后开始生成暂时性错误。</span><span class="sxs-lookup"><span data-stu-id="b56d3-219">In other words, do at least one database operation such as a query on one of your entity sets before you start generating transient errors.</span></span> <span data-ttu-id="b56d3-220">实体框架在数据库初始化期间执行多个查询和它们在事务中，因此在初始化期间的错误可能会导致上下文才能进入不一致的状态不会执行。</span><span class="sxs-lookup"><span data-stu-id="b56d3-220">The Entity Framework executes several queries during database initialization, and they aren't executed in a transaction, so errors during initialization could cause the context to get into an inconsistent state.</span></span>

## <a name="test-logging-and-connection-resiliency"></a><span data-ttu-id="b56d3-221">测试日志记录和连接弹性</span><span class="sxs-lookup"><span data-stu-id="b56d3-221">Test logging and connection resiliency</span></span>

1. <span data-ttu-id="b56d3-222">在 Visual Studio 中，按**F5**在调试模式下，和登录名为"Admin"作为密码使用"Pa$ $word"中运行应用程序。</span><span class="sxs-lookup"><span data-stu-id="b56d3-222">In Visual Studio, press **F5** to run the application in debug mode, and then login as "Admin" using "Pa$$word" as the password.</span></span>
2. <span data-ttu-id="b56d3-223">选择**管理员**顶部导航栏中。</span><span class="sxs-lookup"><span data-stu-id="b56d3-223">Select **Admin** from the navigation bar at the top.</span></span>
3. <span data-ttu-id="b56d3-224">输入一个新的产品名为"引发"与相应的说明、 价格和图像文件。</span><span class="sxs-lookup"><span data-stu-id="b56d3-224">Enter a new product named "Throw" with appropriate description, price and image file.</span></span>
4. <span data-ttu-id="b56d3-225">按**添加产品**按钮。</span><span class="sxs-lookup"><span data-stu-id="b56d3-225">Press the **Add Product** button.</span></span>  
   <span data-ttu-id="b56d3-226">您会注意到浏览器看起来时实体框架重试查询多次挂起数秒钟的时间。</span><span class="sxs-lookup"><span data-stu-id="b56d3-226">You'll notice that the browser seems to hang for several seconds while Entity Framework is retrying the query several times.</span></span> <span data-ttu-id="b56d3-227">首次重试发生速度非常快，然后在每个额外的重试之前等待会增加。</span><span class="sxs-lookup"><span data-stu-id="b56d3-227">The first retry happens very quickly, then the wait increases before each additional retry.</span></span> <span data-ttu-id="b56d3-228">此过程的调用每次重试之前再等待*指数退避算法*。</span><span class="sxs-lookup"><span data-stu-id="b56d3-228">This process of waiting longer before each retry is called *exponential backoff* .</span></span>
5. <span data-ttu-id="b56d3-229">等待，直到页面已不再 atttempting 加载。</span><span class="sxs-lookup"><span data-stu-id="b56d3-229">Wait until the page is no longer atttempting to load.</span></span>
6. <span data-ttu-id="b56d3-230">停止项目，看看 Visual Studio**输出**窗口以查看跟踪输出。</span><span class="sxs-lookup"><span data-stu-id="b56d3-230">Stop the project and look at the Visual Studio **Output** window to see the tracing output.</span></span> <span data-ttu-id="b56d3-231">您可以找到**输出**通过选择窗口**调试** - &gt; **Windows**  - &gt; **输出**。</span><span class="sxs-lookup"><span data-stu-id="b56d3-231">You can find the **Output** window by selecting **Debug** -&gt; **Windows** -&gt; **Output**.</span></span> <span data-ttu-id="b56d3-232">您可能需要滚动浏览多个由记录器写入其他日志。</span><span class="sxs-lookup"><span data-stu-id="b56d3-232">You might have to scroll past several other logs written by your logger.</span></span>  
  
   <span data-ttu-id="b56d3-233">请注意，您可以看到实际的 SQL 查询发送到数据库。</span><span class="sxs-lookup"><span data-stu-id="b56d3-233">Notice that you can see the actual SQL queries sent to the database.</span></span> <span data-ttu-id="b56d3-234">您看到一些初始查询和命令的实体框架执行的操作以开始，请检查数据库版本和迁移历史记录表。</span><span class="sxs-lookup"><span data-stu-id="b56d3-234">You see some initial queries and commands that Entity Framework does to get started, checking the database version and migration history table.</span></span>   
    <span data-ttu-id="b56d3-235">![输出窗口](aspnet-web-forms-connection-resiliency-and-command-interception/_static/image1.png) </span><span class="sxs-lookup"><span data-stu-id="b56d3-235">![Output Window](aspnet-web-forms-connection-resiliency-and-command-interception/_static/image1.png) </span></span>  
   <span data-ttu-id="b56d3-236">请注意，不能重复此测试，除非停止应用程序并重新启动它。</span><span class="sxs-lookup"><span data-stu-id="b56d3-236">Note that you can't repeat this test unless you stop the application and restart it.</span></span> <span data-ttu-id="b56d3-237">如果你想要能够测试应用程序的单次运行中的连接复原多次，您可以编写代码来重置中的错误计数器`InterceptorTransientErrors`。</span><span class="sxs-lookup"><span data-stu-id="b56d3-237">If you wanted to be able to test connection resiliency multiple times in a single run of the application, you could write code to reset the error counter in `InterceptorTransientErrors` .</span></span>
7. <span data-ttu-id="b56d3-238">若要查看不同之处执行策略 （重试策略） 发出，注释`SetExecutionStrategy`行中*WingtipToysConfiguration.cs*中的文件*逻辑*文件夹中，运行**管理员**同样，在调试模式下页上，添加名为产品&quot;引发&quot;试。</span><span class="sxs-lookup"><span data-stu-id="b56d3-238">To see the difference the execution strategy (retry policy) makes, comment out the `SetExecutionStrategy` line in *WingtipToysConfiguration.cs* file in the *Logic* folder, run the **Admin** page in debug mode again, and add the product named &quot;Throw&quot; again.</span></span>  
  
   <span data-ttu-id="b56d3-239">这一次调试器停止上第一个生成的异常后尝试执行第一次的查询，将立即。</span><span class="sxs-lookup"><span data-stu-id="b56d3-239">This time the debugger stops on the first generated exception immediately when it tries to execute the query the first time.</span></span>  
    ![调试-查看详细信息](aspnet-web-forms-connection-resiliency-and-command-interception/_static/image2.png)
8. <span data-ttu-id="b56d3-241">取消注释`SetExecutionStrategy`行中*WingtipToysConfiguration.cs*文件。</span><span class="sxs-lookup"><span data-stu-id="b56d3-241">Uncomment the `SetExecutionStrategy` line in the *WingtipToysConfiguration.cs* file.</span></span>

## <a name="summary"></a><span data-ttu-id="b56d3-242">总结</span><span class="sxs-lookup"><span data-stu-id="b56d3-242">Summary</span></span>

<span data-ttu-id="b56d3-243">在本教程中已了解如何修改 Web 窗体示例应用程序，以支持连接复原和命令截获。</span><span class="sxs-lookup"><span data-stu-id="b56d3-243">In this tutorial you've seen how to modify a Web Forms sample application to support connection resiliency and command interception.</span></span>

## <a name="next-steps"></a><span data-ttu-id="b56d3-244">后续步骤</span><span class="sxs-lookup"><span data-stu-id="b56d3-244">Next Steps</span></span>

<span data-ttu-id="b56d3-245">查看连接复原和命令截获在 ASP.NET Web 窗体后，查看 ASP.NET Web 窗体主题[ASP.NET 4.5 中的异步方法](../performance-and-caching/using-asynchronous-methods-in-aspnet-45.md)。</span><span class="sxs-lookup"><span data-stu-id="b56d3-245">After you have reviewed connection resiliency and command interception in ASP.NET Web Forms, review the ASP.NET Web Forms topic [Asynchronous Methods in ASP.NET 4.5](../performance-and-caching/using-asynchronous-methods-in-aspnet-45.md).</span></span> <span data-ttu-id="b56d3-246">本主题将介绍生成使用 Visual Studio 的异步 ASP.NET Web 窗体应用程序的基础知识。</span><span class="sxs-lookup"><span data-stu-id="b56d3-246">The topic will teach you the basics of building an asynchronous ASP.NET Web Forms application using Visual Studio.</span></span>
