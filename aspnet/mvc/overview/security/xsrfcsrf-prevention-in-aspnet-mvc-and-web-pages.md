---
uid: mvc/overview/security/xsrfcsrf-prevention-in-aspnet-mvc-and-web-pages
title: 在 ASP.NET MVC 和 Web Pages 中的 XSRF/CSRF 防护 |Microsoft Docs
author: Rick-Anderson
description: 跨站点请求伪造 （也称为 XSRF 或 CSRF） 是针对恶意网站凭此可以影响 interacti web 托管应用程序的攻击...
ms.author: aspnetcontent
ms.date: 03/14/2013
ms.assetid: aadc5fa4-8215-4fc7-afd5-bcd2ef879728
msc.legacyurl: /mvc/overview/security/xsrfcsrf-prevention-in-aspnet-mvc-and-web-pages
msc.type: authoredcontent
ms.openlocfilehash: be0e8ebe521e9952d7525b581f9b91af6edca1da
ms.sourcegitcommit: b28cd0313af316c051c2ff8549865bff67f2fbb4
ms.translationtype: MT
ms.contentlocale: zh-CN
ms.lasthandoff: 07/05/2018
ms.locfileid: "37820251"
---
<a name="xsrfcsrf-prevention-in-aspnet-mvc-and-web-pages"></a><span data-ttu-id="8d446-103">在 ASP.NET MVC 和 Web Pages 中的 XSRF/CSRF 防护</span><span class="sxs-lookup"><span data-stu-id="8d446-103">XSRF/CSRF Prevention in ASP.NET MVC and Web Pages</span></span>
====================
<span data-ttu-id="8d446-104">通过[Rick Anderson](https://github.com/Rick-Anderson)</span><span class="sxs-lookup"><span data-stu-id="8d446-104">by [Rick Anderson](https://github.com/Rick-Anderson)</span></span>

> <span data-ttu-id="8d446-105">跨站点请求伪造 （也称为 XSRF 或 CSRF） 是针对恶意网站凭此可以影响客户端浏览器和该浏览器的受信任的网站之间的交互的 web 托管的应用程序的攻击。</span><span class="sxs-lookup"><span data-stu-id="8d446-105">Cross-site request forgery (also known as XSRF or CSRF) is an attack against web-hosted applications whereby a malicious web site can influence the interaction between a client browser and a web site trusted by that browser.</span></span> <span data-ttu-id="8d446-106">这些攻击的原因可能 web 浏览器会将自动随每个请求的身份验证令牌发送到 web 站点。</span><span class="sxs-lookup"><span data-stu-id="8d446-106">These attacks are made possible because web browsers will send authentication tokens automatically with every request to a web site.</span></span> <span data-ttu-id="8d446-107">典型示例是身份验证 cookie，如 ASP。NET 的窗体身份验证票证。</span><span class="sxs-lookup"><span data-stu-id="8d446-107">The canonical example is an authentication cookie, such as ASP.NET's Forms Authentication ticket.</span></span> <span data-ttu-id="8d446-108">然而，使用任何持久身份验证机制 （如 Windows 身份验证、 Basic 等） 的网站可能受攻击目标。</span><span class="sxs-lookup"><span data-stu-id="8d446-108">However, web sites which use any persistent authentication mechanism (such as Windows Authentication, Basic, and so forth) can be targeted by these attacks.</span></span>
> 
> <span data-ttu-id="8d446-109">XSRF 攻击与钓鱼攻击不同。</span><span class="sxs-lookup"><span data-stu-id="8d446-109">An XSRF attack is distinct from a phishing attack.</span></span> <span data-ttu-id="8d446-110">网络钓鱼攻击需要与受害者进行交互。</span><span class="sxs-lookup"><span data-stu-id="8d446-110">Phishing attacks require interaction from the victim.</span></span> <span data-ttu-id="8d446-111">在网络钓鱼攻击中，恶意网站将模拟目标网站，并在受害者受骗向攻击者提供敏感信息。</span><span class="sxs-lookup"><span data-stu-id="8d446-111">In a phishing attack, a malicious web site will mimic the target web site, and the victim is fooled into providing sensitive information to the attacker.</span></span> <span data-ttu-id="8d446-112">在 XSRF 攻击中，没有通常无需交互与受害者。</span><span class="sxs-lookup"><span data-stu-id="8d446-112">In an XSRF attack, there is often no interaction necessary from the victim.</span></span> <span data-ttu-id="8d446-113">相反，攻击者依靠浏览器自动向目标网站发送所有相关 cookie。</span><span class="sxs-lookup"><span data-stu-id="8d446-113">Rather, the attacker is relying on the browser automatically sending all relevant cookies to the destination web site.</span></span>
> 
> <span data-ttu-id="8d446-114">有关详细信息，请参阅[打开 Web 应用程序安全项目](https://www.owasp.org/index.php/Main_Page)(OWASP) [XSRF](https://www.owasp.org/index.php/Cross-Site_Request_Forgery_(CSRF))。</span><span class="sxs-lookup"><span data-stu-id="8d446-114">For more information, see the [Open Web Application Security Project](https://www.owasp.org/index.php/Main_Page)(OWASP) [XSRF](https://www.owasp.org/index.php/Cross-Site_Request_Forgery_(CSRF)).</span></span>


## <a name="anatomy-of-an-attack"></a><span data-ttu-id="8d446-115">一种攻击的剖析</span><span class="sxs-lookup"><span data-stu-id="8d446-115">Anatomy of an attack</span></span>

<span data-ttu-id="8d446-116">若要遍历 XSRF 攻击时，请考虑想要执行一些联机银行事务的用户。</span><span class="sxs-lookup"><span data-stu-id="8d446-116">To walk through an XSRF attack, consider a user who wants to perform some online banking transactions.</span></span> <span data-ttu-id="8d446-117">此用户第一次访问 WoodgroveBank.com 和日志中，此时响应标头将包含其身份验证 cookie:</span><span class="sxs-lookup"><span data-stu-id="8d446-117">This user first visits WoodgroveBank.com and logs in, at which point the response header will contain her authentication cookie:</span></span>

[!code-console[Main](xsrfcsrf-prevention-in-aspnet-mvc-and-web-pages/samples/sample1.cmd)]

<span data-ttu-id="8d446-118">由于身份验证 cookie 的会话 cookie，它将自动清除浏览器时在浏览器进程退出。</span><span class="sxs-lookup"><span data-stu-id="8d446-118">Because the authentication cookie is a session cookie, it will be automatically cleared by the browser when the browser process exits.</span></span> <span data-ttu-id="8d446-119">但是，在此之前，在浏览器将自动包括与 WoodgroveBank.com 的每个请求的 cookie。</span><span class="sxs-lookup"><span data-stu-id="8d446-119">However, until that time, the browser will automatically include the cookie with each request to WoodgroveBank.com.</span></span> <span data-ttu-id="8d446-120">用户现在想要将 1000 美元传输到另一个帐户，因此她表单中填写银行站点上并在浏览器向服务器发出此请求：</span><span class="sxs-lookup"><span data-stu-id="8d446-120">The user now wants to transfer $1000 to another account, so she fills out a form on the banking site, and the browser makes this request to the server:</span></span>

[!code-console[Main](xsrfcsrf-prevention-in-aspnet-mvc-and-web-pages/samples/sample2.cmd)]

<span data-ttu-id="8d446-121">此操作具有副作用 （它开始货币的事务），因为已选择银行站点需要 HTTP POST，才能启动此操作。</span><span class="sxs-lookup"><span data-stu-id="8d446-121">Because this operation has a side effect (it initiates a monetary transaction), the banking site has chosen to require an HTTP POST in order to initiate this operation.</span></span> <span data-ttu-id="8d446-122">服务器从请求中读取身份验证令牌、 查找当前用户的帐户数、 验证充足的资金存在，然后启动到目标帐户的事务。</span><span class="sxs-lookup"><span data-stu-id="8d446-122">The server reads the authentication token from the request, looks up the current user's account number, verifies that sufficient funds exist, and then initiates the transaction into the destination account.</span></span>

<span data-ttu-id="8d446-123">她联机银行完成后，用户离开银行站点，并在 web 上访问的其他位置。</span><span class="sxs-lookup"><span data-stu-id="8d446-123">Her online banking complete, the user navigates away from the banking site and visits other locations on the web.</span></span> <span data-ttu-id="8d446-124">这些站点 – fabrikam.com – 之一包含嵌入在页面上的以下标记&lt;iframe&gt;:</span><span class="sxs-lookup"><span data-stu-id="8d446-124">One of those sites – fabrikam.com – includes the following markup on a page embedded within an &lt;iframe&gt;:</span></span>

[!code-html[Main](xsrfcsrf-prevention-in-aspnet-mvc-and-web-pages/samples/sample3.html)]

<span data-ttu-id="8d446-125">它会导致浏览器发出此请求：</span><span class="sxs-lookup"><span data-stu-id="8d446-125">Which then causes the browser to make this request:</span></span>

[!code-console[Main](xsrfcsrf-prevention-in-aspnet-mvc-and-web-pages/samples/sample4.cmd)]

<span data-ttu-id="8d446-126">攻击者利用这一事实，用户可能仍具有有效的身份验证令牌为目标 web 站点，并且她正在使用 Javascript 一小段代码会导致浏览器自动发出 HTTP POST 到目标站点。</span><span class="sxs-lookup"><span data-stu-id="8d446-126">The attacker is exploiting the fact that the user might still have a valid authentication token for the target web site, and she is using a small snippet of Javascript to cause the browser to make an HTTP POST to the target site automatically.</span></span> <span data-ttu-id="8d446-127">如果仍有效的身份验证令牌，银行站点将启动的 250 美元到攻击者选择的帐户的复制。</span><span class="sxs-lookup"><span data-stu-id="8d446-127">If the authentication token is still valid, the banking site will initiate a transfer of $250 into the account of the attacker's choosing.</span></span>

### <a name="ineffective-mitigations"></a><span data-ttu-id="8d446-128">无效的缓解措施</span><span class="sxs-lookup"><span data-stu-id="8d446-128">Ineffective mitigations</span></span>

<span data-ttu-id="8d446-129">值得注意的是在上面的方案中，则表明 WoodgroveBank.com 正在通过 SSL 访问，并且必须仅 SSL 身份验证 cookie 已不足以防止攻击。</span><span class="sxs-lookup"><span data-stu-id="8d446-129">It is interesting to note that in the above scenario, the fact that WoodgroveBank.com was being accessed via SSL and had an SSL-only authentication cookie was insufficient to thwart the attack.</span></span> <span data-ttu-id="8d446-130">攻击者是能够指定[URI 方案](http://en.wikipedia.org/wiki/URI_scheme)(https) 在她&lt;窗体&gt;元素，并在浏览器将继续将未过期的 cookie 发送到目标站点，只要这些 cookie 是一致的 uri预期目标的方案。</span><span class="sxs-lookup"><span data-stu-id="8d446-130">The attacker is able to specify the [URI scheme](http://en.wikipedia.org/wiki/URI_scheme) (https) in her &lt;form&gt; element, and the browser will continue to send unexpired cookies to the target site as long as those cookies are consistent with the URI scheme of the intended target.</span></span>

<span data-ttu-id="8d446-131">有人可能会认为，用户应只需不访问不受信任的站点，作为访问仅受信任的站点是能够安全在线帮助。</span><span class="sxs-lookup"><span data-stu-id="8d446-131">One could argue that the user should simply not visit untrusted sites, as visiting only trusted sites is helps to remain safe online.</span></span> <span data-ttu-id="8d446-132">为此，一些真实但遗憾的是这一建议并不总是可行。</span><span class="sxs-lookup"><span data-stu-id="8d446-132">There is some truth to this, but unfortunately this advice is not always practical.</span></span> <span data-ttu-id="8d446-133">用户可能是"信任"ConsolidatedMessenger 的当地新闻站点。</span><span class="sxs-lookup"><span data-stu-id="8d446-133">Perhaps the user "trusts" the local news site ConsolidatedMessenger.</span></span> <span data-ttu-id="8d446-134">ConsolidatedMessenger.com 并转到相反，站点的访问，但该站点具有 XSS 漏洞允许攻击者注入 fabrikam.com 运行的代码的同一代码片段。</span><span class="sxs-lookup"><span data-stu-id="8d446-134">ConsolidatedMessenger.com and goes to visit that site instead, but that site has an XSS vulnerability which allows an attacker to inject the same snippet of code that was running on fabrikam.com.</span></span>

<span data-ttu-id="8d446-135">可以验证传入的请求具有[Referer 标头](http://www.w3.org/Protocols/HTTP/HTRQ_Headers.html#z14)引用你的域。</span><span class="sxs-lookup"><span data-stu-id="8d446-135">You can verify that incoming requests have a [Referer header](http://www.w3.org/Protocols/HTTP/HTRQ_Headers.html#z14) referencing your domain.</span></span> <span data-ttu-id="8d446-136">这将停止从第三方域明智地提交请求。</span><span class="sxs-lookup"><span data-stu-id="8d446-136">This will stop requests unwittingly submitted from a third-party domain.</span></span> <span data-ttu-id="8d446-137">但是，有些人禁用其浏览器的引用站点标头，出于隐私原因，并且如果受害者计算机未安装某些不安全软件，攻击者有时可以欺骗该标头。</span><span class="sxs-lookup"><span data-stu-id="8d446-137">However, some people disable their browser's Referer header for privacy reasons, and attackers can sometimes spoof that header if the victim has certain insecure software installed.</span></span> <span data-ttu-id="8d446-138">验证[Referer 标头](http://www.w3.org/Protocols/HTTP/HTRQ_Headers.html#z14)不被视为一种阻止 XSRF 攻击的安全方法。</span><span class="sxs-lookup"><span data-stu-id="8d446-138">Verifying the [Referer header](http://www.w3.org/Protocols/HTTP/HTRQ_Headers.html#z14) is not considered a secure approach to preventing XSRF attacks.</span></span>

## <a name="web-stack-runtime-xsrf-mitigations"></a><span data-ttu-id="8d446-139">Web 堆栈运行时 XSRF 缓解措施</span><span class="sxs-lookup"><span data-stu-id="8d446-139">Web Stack Runtime XSRF mitigations</span></span>

<span data-ttu-id="8d446-140">ASP.NET Web 堆栈运行时使用的一个变体[同步器标记模式](https://www.owasp.org/index.php/Cross-Site_Request_Forgery_(CSRF)_Prevention_Cheat_Sheet#General_Recommendation:_Synchronizer_Token_Pattern)来抵御 XSRF 攻击。</span><span class="sxs-lookup"><span data-stu-id="8d446-140">The ASP.NET Web Stack Runtime uses a variant of the [synchronizer token pattern](https://www.owasp.org/index.php/Cross-Site_Request_Forgery_(CSRF)_Prevention_Cheat_Sheet#General_Recommendation:_Synchronizer_Token_Pattern) to defend against XSRF attacks.</span></span> <span data-ttu-id="8d446-141">同步器令牌模式的一般形式为的两个的 ANTI-XSRF 令牌提交到每个 HTTP POST （除了身份验证令牌） 的服务器： 一个令牌作为 cookie，另一个用作窗体值。</span><span class="sxs-lookup"><span data-stu-id="8d446-141">The general form of the synchronizer token pattern is that two anti-XSRF tokens are submitted to the server with each HTTP POST (In addition to the authentication token): one token as a cookie, and the other as a form value.</span></span> <span data-ttu-id="8d446-142">由 ASP.NET 运行时生成的令牌值不是确定性的也可由攻击者预测。</span><span class="sxs-lookup"><span data-stu-id="8d446-142">The token values generated by the ASP.NET runtime are not deterministic or predictable by an attacker.</span></span> <span data-ttu-id="8d446-143">当提交令牌时，则服务器将允许继续仅当这两个令牌通过比较检查请求。</span><span class="sxs-lookup"><span data-stu-id="8d446-143">When the tokens are submitted, the server will allow the request to proceed only if both tokens pass a comparison check.</span></span>

<span data-ttu-id="8d446-144">XSRF 请求验证*会话令牌*HTTP cookie 作为存储和当前包含其有效负载中的以下信息：</span><span class="sxs-lookup"><span data-stu-id="8d446-144">The XSRF request verification *session token* is stored as an HTTP cookie and currently contains the following information in its payload:</span></span>

- <span data-ttu-id="8d446-145">安全令牌中，包含一个随机的 128 位标识符。</span><span class="sxs-lookup"><span data-stu-id="8d446-145">A security token, consisting of a random 128-bit identifier.</span></span>   
 <span data-ttu-id="8d446-146">下图显示了使用 Internet Explorer F12 开发人员工具显示 XSRF 请求验证会话令牌: (请注意这是当前的实现，并且受，甚至有可能，若要更改。)</span><span class="sxs-lookup"><span data-stu-id="8d446-146">The following image shows the XSRF request verification session token displayed with the Internet Explorer F12 developer tools: (Note this is the current implementation and is subject, even likely, to change.)</span></span>

![](xsrfcsrf-prevention-in-aspnet-mvc-and-web-pages/_static/image1.png)

<span data-ttu-id="8d446-147">*字段令牌*存储为`<input type="hidden" />`和包含其有效负载中的以下信息：</span><span class="sxs-lookup"><span data-stu-id="8d446-147">The *field token* is stored as an `<input type="hidden" />` and contains the following information in its payload:</span></span>

- <span data-ttu-id="8d446-148">登录的用户的用户名 （如果经过身份验证）。</span><span class="sxs-lookup"><span data-stu-id="8d446-148">The logged-in user's username (if authenticated).</span></span>
- <span data-ttu-id="8d446-149">提供的任何其他数据[IAntiForgeryAdditionalDataProvider](https://msdn.microsoft.com/library/system.web.helpers.iantiforgeryadditionaldataprovider(v=vs.111).aspx)。</span><span class="sxs-lookup"><span data-stu-id="8d446-149">Any additional data provided by an [IAntiForgeryAdditionalDataProvider](https://msdn.microsoft.com/library/system.web.helpers.iantiforgeryadditionaldataprovider(v=vs.111).aspx).</span></span>

<span data-ttu-id="8d446-150">ANTI-XSRF 令牌的有效负载进行加密和签名，以便使用工具来检查令牌时，不能查看的用户名。</span><span class="sxs-lookup"><span data-stu-id="8d446-150">The payloads of the anti-XSRF tokens are encrypted and signed, so you can't view the username when using tools to examine the tokens.</span></span> <span data-ttu-id="8d446-151">当 web 应用程序面向 ASP.NET 4.0 时，由提供加密服务[MachineKey.Encode](https://msdn.microsoft.com/library/system.web.security.machinekey.encode.aspx)例程。</span><span class="sxs-lookup"><span data-stu-id="8d446-151">When the web application is targeting ASP.NET 4.0, cryptographic services are provided by the [MachineKey.Encode](https://msdn.microsoft.com/library/system.web.security.machinekey.encode.aspx) routine.</span></span> <span data-ttu-id="8d446-152">当 web 应用程序面向 ASP.NET 4.5 或更高版本、 加密服务提供的[MachineKey.Protect](https://msdn.microsoft.com/library/system.web.security.machinekey.protect(v=vs.110))例程，它提供了更好的性能、 可扩展性和安全性。</span><span class="sxs-lookup"><span data-stu-id="8d446-152">When the web application is targeting ASP.NET 4.5 or higher, cryptographic services are provided by the [MachineKey.Protect](https://msdn.microsoft.com/library/system.web.security.machinekey.protect(v=vs.110)) routine, which offers better performance, extensibility, and security.</span></span> <span data-ttu-id="8d446-153">请参阅以下博客文章的更多详细信息：</span><span class="sxs-lookup"><span data-stu-id="8d446-153">See the following blog posts for more details:</span></span>

- [<span data-ttu-id="8d446-154">在 ASP.NET 4.5 中的加密改进、 pt。1</span><span class="sxs-lookup"><span data-stu-id="8d446-154">Cryptographic Improvements in ASP.NET 4.5, pt. 1</span></span>](https://blogs.msdn.com/b/webdev/archive/2012/10/22/cryptographic-improvements-in-asp-net-4-5-pt-1.aspx)
- [<span data-ttu-id="8d446-155">在 ASP.NET 4.5 中的加密改进、 pt。2</span><span class="sxs-lookup"><span data-stu-id="8d446-155">Cryptographic Improvements in ASP.NET 4.5, pt. 2</span></span>](https://blogs.msdn.com/b/webdev/archive/2012/10/23/cryptographic-improvements-in-asp-net-4-5-pt-2.aspx)
- [<span data-ttu-id="8d446-156">在 ASP.NET 4.5 中的加密改进、 pt。3</span><span class="sxs-lookup"><span data-stu-id="8d446-156">Cryptographic Improvements in ASP.NET 4.5, pt. 3</span></span>](https://blogs.msdn.com/b/webdev/archive/2012/10/24/cryptographic-improvements-in-asp-net-4-5-pt-3.aspx)

## <a name="generating-the-tokens"></a><span data-ttu-id="8d446-157">生成令牌</span><span class="sxs-lookup"><span data-stu-id="8d446-157">Generating the tokens</span></span>

<span data-ttu-id="8d446-158">若要生成的 ANTI-XSRF 令牌，调用[ @Html.AntiForgeryToken ](https://msdn.microsoft.com/library/dd470175.aspx) MVC 视图中的方法或@AntiForgery.GetHtml从 Razor 页面 （)。</span><span class="sxs-lookup"><span data-stu-id="8d446-158">To generate the anti-XSRF tokens, call the [@Html.AntiForgeryToken](https://msdn.microsoft.com/library/dd470175.aspx) method from an MVC view or @AntiForgery.GetHtml() from a Razor page.</span></span> <span data-ttu-id="8d446-159">然后，运行时将执行以下步骤：</span><span class="sxs-lookup"><span data-stu-id="8d446-159">The runtime will then perform the following steps:</span></span>

1. <span data-ttu-id="8d446-160">如果当前的 HTTP 请求中已包含的 ANTI-XSRF 会话令牌 (的 ANTI-XSRF cookie \_ \_RequestVerificationToken)，从其提取的安全令牌。</span><span class="sxs-lookup"><span data-stu-id="8d446-160">If the current HTTP request already contains an anti-XSRF session token (the anti-XSRF cookie \_\_RequestVerificationToken), the security token is extracted from it.</span></span> <span data-ttu-id="8d446-161">如果 HTTP 请求不包含的 ANTI-XSRF 会话令牌或安全令牌提取失败，将生成新的随机的 ANTI-XSRF 令牌。</span><span class="sxs-lookup"><span data-stu-id="8d446-161">If the HTTP request does not contain an anti-XSRF session token or if extraction of the security token fails, a new random anti-XSRF token will be generated.</span></span>
2. <span data-ttu-id="8d446-162">使用从上面的步骤 (1) 和当前登录的用户的标识的安全令牌生成的 ANTI-XSRF 字段令牌。</span><span class="sxs-lookup"><span data-stu-id="8d446-162">An anti-XSRF field token is generated using the security token from step (1) above and the identity of the current logged-in user.</span></span> <span data-ttu-id="8d446-163">(有关确定用户标识的详细信息，请参阅**[提供特殊支持的方案](#_Scenarios_with_special)** 下面一节。)此外，如果[IAntiForgeryAdditionalDataProvider](https://msdn.microsoft.com/library/jj158328(v=vs.111).aspx)是配置，则运行时会调用其[GetAdditionalData](https://msdn.microsoft.com/library/system.web.helpers.iantiforgeryadditionaldataprovider.getadditionaldata(v=vs.111).aspx)方法，包括字段令牌中返回的字符串。</span><span class="sxs-lookup"><span data-stu-id="8d446-163">(For more information on determining user identity, see the **[Scenarios with special support](#_Scenarios_with_special)** section below.) Additionally, if an [IAntiForgeryAdditionalDataProvider](https://msdn.microsoft.com/library/jj158328(v=vs.111).aspx) is configured, the runtime will call its [GetAdditionalData](https://msdn.microsoft.com/library/system.web.helpers.iantiforgeryadditionaldataprovider.getadditionaldata(v=vs.111).aspx) method and include the returned string in the field token.</span></span> <span data-ttu-id="8d446-164">(请参阅**[配置和可扩展性](#_Configuration_and_extensibility)** 部分，了解详细信息。)</span><span class="sxs-lookup"><span data-stu-id="8d446-164">(See the **[Configuration and extensibility](#_Configuration_and_extensibility)** section for more information.)</span></span>
3. <span data-ttu-id="8d446-165">如果在步骤 (1) 中生成新的 ANTI-XSRF 令牌，新的会话令牌将创建以包含它，并且将添加到的出站的 HTTP cookie 集合。</span><span class="sxs-lookup"><span data-stu-id="8d446-165">If a new anti-XSRF token was generated in step (1), a new session token will be created to contain it and will be added to the outbound HTTP cookies collection.</span></span> <span data-ttu-id="8d446-166">步骤 (2) 中的字段标记将包装在`<input type="hidden" />`将返回值的元素，并且此 HTML 标记`Html.AntiForgeryToken()`或`AntiForgery.GetHtml()`。</span><span class="sxs-lookup"><span data-stu-id="8d446-166">The field token from step (2) will be wrapped in an `<input type="hidden" />` element, and this HTML markup will be the return value of `Html.AntiForgeryToken()` or `AntiForgery.GetHtml()`.</span></span>

## <a name="validating-the-tokens"></a><span data-ttu-id="8d446-167">验证的令牌</span><span class="sxs-lookup"><span data-stu-id="8d446-167">Validating the tokens</span></span>

<span data-ttu-id="8d446-168">若要验证传入的 ANTI-XSRF 令牌，开发人员包括[ValidateAntiForgeryToken](https://msdn.microsoft.com/library/system.web.mvc.validateantiforgerytokenattribute(VS.108).aspx)她 MVC 操作或控制器，则她调用属性`@AntiForgery.Validate()`从她 Razor 页面。</span><span class="sxs-lookup"><span data-stu-id="8d446-168">To validate the incoming anti-XSRF tokens, the developer includes a [ValidateAntiForgeryToken](https://msdn.microsoft.com/library/system.web.mvc.validateantiforgerytokenattribute(VS.108).aspx) attribute on her MVC action or controller, or she calls `@AntiForgery.Validate()` from her Razor page.</span></span> <span data-ttu-id="8d446-169">在运行时将执行以下步骤：</span><span class="sxs-lookup"><span data-stu-id="8d446-169">The runtime will perform the following steps:</span></span>

1. <span data-ttu-id="8d446-170">读取传入会话令牌和字段标记，并从每个提取的 ANTI-XSRF 令牌。</span><span class="sxs-lookup"><span data-stu-id="8d446-170">The incoming session token and field token are read and the anti-XSRF token extracted from each.</span></span> <span data-ttu-id="8d446-171">ANTI-XSRF 令牌必须为每个步骤 (2) 生成例程中完全相同。</span><span class="sxs-lookup"><span data-stu-id="8d446-171">The anti-XSRF tokens must be identical per step (2) in the generation routine.</span></span>
2. <span data-ttu-id="8d446-172">如果当前用户进行身份验证，其用户名进行比较的字段标记中存储的用户名。</span><span class="sxs-lookup"><span data-stu-id="8d446-172">If the current user is authenticated, her username is compared with the username stored in the field token.</span></span> <span data-ttu-id="8d446-173">用户名必须与匹配。</span><span class="sxs-lookup"><span data-stu-id="8d446-173">The usernames must match.</span></span>
3. <span data-ttu-id="8d446-174">如果[IAntiForgeryAdditionalDataProvider](https://msdn.microsoft.com/library/system.web.helpers.iantiforgeryadditionaldataprovider(v=vs.111).aspx)配置，则运行时会调用其*ValidateAdditionalData*方法。</span><span class="sxs-lookup"><span data-stu-id="8d446-174">If an [IAntiForgeryAdditionalDataProvider](https://msdn.microsoft.com/library/system.web.helpers.iantiforgeryadditionaldataprovider(v=vs.111).aspx) is configured, the runtime calls its *ValidateAdditionalData* method.</span></span> <span data-ttu-id="8d446-175">该方法必须返回布尔值 *，则返回 true*。</span><span class="sxs-lookup"><span data-stu-id="8d446-175">The method must return the Boolean value *true*.</span></span>

<span data-ttu-id="8d446-176">如果验证成功，则允许该请求以继续。</span><span class="sxs-lookup"><span data-stu-id="8d446-176">If validation succeeds, the request is allowed to proceed.</span></span> <span data-ttu-id="8d446-177">如果验证失败，框架将引发*HttpAntiForgeryException*。</span><span class="sxs-lookup"><span data-stu-id="8d446-177">If validation fails, the framework will throw an *HttpAntiForgeryException*.</span></span>

## <a name="failure-conditions"></a><span data-ttu-id="8d446-178">失败条件</span><span class="sxs-lookup"><span data-stu-id="8d446-178">Failure conditions</span></span>

<span data-ttu-id="8d446-179">从任何 ASP.NET Web 堆栈运行时版本 2 开始*HttpAntiForgeryException*期间引发验证将包含有关发生的问题的详细的信息。</span><span class="sxs-lookup"><span data-stu-id="8d446-179">Starting with The ASP.NET Web Stack Runtime v2, any *HttpAntiForgeryException* that is thrown during validation will contain detailed information about what went wrong.</span></span> <span data-ttu-id="8d446-180">当前定义的失败条件包括：</span><span class="sxs-lookup"><span data-stu-id="8d446-180">The currently defined failure conditions are:</span></span>

- <span data-ttu-id="8d446-181">会话令牌或窗体令牌不存在请求中。</span><span class="sxs-lookup"><span data-stu-id="8d446-181">The session token or form token is not present in the request.</span></span>
- <span data-ttu-id="8d446-182">会话令牌或窗体令牌不可读。</span><span class="sxs-lookup"><span data-stu-id="8d446-182">The session token or form token is unreadable.</span></span> <span data-ttu-id="8d446-183">最可能的原因是运行不匹配的版本的 ASP.NET Web 堆栈运行时或场的场其中&lt;machineKey&gt;机之间不同，在 Web.config 中的元素。</span><span class="sxs-lookup"><span data-stu-id="8d446-183">The most likely cause of this is a farm running mismatched versions of The ASP.NET Web Stack Runtime or a farm where the &lt;machineKey&gt; element in Web.config differs between machines.</span></span> <span data-ttu-id="8d446-184">您可以使用 Fiddler 之类的工具篡改其中任意一个的 ANTI-XSRF 令牌强制此异常。</span><span class="sxs-lookup"><span data-stu-id="8d446-184">You can use a tool such as Fiddler to force this exception by tampering with either anti-XSRF token.</span></span>
- <span data-ttu-id="8d446-185">会话令牌和字段令牌被互换。</span><span class="sxs-lookup"><span data-stu-id="8d446-185">The session token and field token were swapped.</span></span>
- <span data-ttu-id="8d446-186">会话令牌和字段令牌包含不匹配的安全令牌。</span><span class="sxs-lookup"><span data-stu-id="8d446-186">The session token and field token contain mismatched security tokens.</span></span>
- <span data-ttu-id="8d446-187">嵌入的字段标记中的用户名与当前登录的用户的用户名不匹配。</span><span class="sxs-lookup"><span data-stu-id="8d446-187">The username embedded within the field token does not match the current logged-in user's username.</span></span>
- <span data-ttu-id="8d446-188">*[IAntiForgeryAdditionalDataProvider.ValidateAdditionalData](https://msdn.microsoft.com/library/system.web.helpers.iantiforgeryadditionaldataprovider.validateadditionaldata(v=vs.111).aspx)* 方法返回*false*。</span><span class="sxs-lookup"><span data-stu-id="8d446-188">The *[IAntiForgeryAdditionalDataProvider.ValidateAdditionalData](https://msdn.microsoft.com/library/system.web.helpers.iantiforgeryadditionaldataprovider.validateadditionaldata(v=vs.111).aspx)* method returned *false*.</span></span>

<span data-ttu-id="8d446-189">ANTI-XSRF 功能还可以执行附加检查在令牌生成或验证，过程和这些检查期间出现的故障可能会导致引发异常。</span><span class="sxs-lookup"><span data-stu-id="8d446-189">The anti-XSRF facilities may also perform additional checking during token generation or validation, and failures during these checks may result in exceptions being thrown.</span></span> <span data-ttu-id="8d446-190">请参阅[WIF / ACS / 基于声明的身份验证](#_WIF_ACS)并**[配置和可扩展性](#_Configuration_and_extensibility)** 部分，了解详细信息。</span><span class="sxs-lookup"><span data-stu-id="8d446-190">See the [WIF / ACS / claims-based authentication](#_WIF_ACS) and **[Configuration and extensibility](#_Configuration_and_extensibility)** sections for more information.</span></span>

<a id="_Scenarios_with_special"></a>

## <a name="scenarios-with-special-support"></a><span data-ttu-id="8d446-191">提供特殊支持的方案</span><span class="sxs-lookup"><span data-stu-id="8d446-191">Scenarios with special support</span></span>

### <a name="anonymous-authentication"></a><span data-ttu-id="8d446-192">匿名身份验证</span><span class="sxs-lookup"><span data-stu-id="8d446-192">Anonymous authentication</span></span>

<span data-ttu-id="8d446-193">ANTI-XSRF 系统包含为匿名用户，其中"匿名"定义为用户的特殊支持其中*IIdentity.IsAuthenticated*属性将返回*false*。</span><span class="sxs-lookup"><span data-stu-id="8d446-193">The anti-XSRF system contains special support for anonymous users, where "anonymous" is defined as a user where the *IIdentity.IsAuthenticated* property returns *false*.</span></span> <span data-ttu-id="8d446-194">方案包括提供 XSRF 保护到登录页 （在之前的用户进行身份验证） 和应用程序而不使用一种机制，其中的自定义身份验证方案*IIdentity*标识的用户。</span><span class="sxs-lookup"><span data-stu-id="8d446-194">Scenarios include providing XSRF protection to the login page (before the user is authenticated) and custom authentication schemes where the application uses a mechanism other than *IIdentity* to identify users.</span></span>

<span data-ttu-id="8d446-195">若要支持这些方案，请记住的会话和字段的令牌已加入由安全令牌，这是一个 128 位随机生成不透明标识符。</span><span class="sxs-lookup"><span data-stu-id="8d446-195">To support these scenarios, recall that the session and field tokens are joined by a security token, which is a 128-bit randomly-generated opaque identifier.</span></span> <span data-ttu-id="8d446-196">此安全令牌用于跟踪单个用户的会话，当她导航站点，因此它有效地起到作用的匿名标识符。</span><span class="sxs-lookup"><span data-stu-id="8d446-196">This security token is used to track an individual user's session as she navigates the site, so it effectively serves the purpose of an anonymous identifier.</span></span> <span data-ttu-id="8d446-197">空字符串将代替上面所述的生成和验证例程的用户名。</span><span class="sxs-lookup"><span data-stu-id="8d446-197">An empty string is used in place of the username for the generation and validation routines described above.</span></span>

<a id="_WIF_ACS"></a>

### <a name="wif--acs--claims-based-authentication"></a><span data-ttu-id="8d446-198">WIF / ACS / 基于声明的身份验证</span><span class="sxs-lookup"><span data-stu-id="8d446-198">WIF / ACS / claims-based authentication</span></span>

<span data-ttu-id="8d446-199">通常情况下， *IIdentity*到.NET Framework 中内置的类具有属性的*IIdentity.Name*足以唯一地标识特定的应用程序内的特定用户。</span><span class="sxs-lookup"><span data-stu-id="8d446-199">Normally, the *IIdentity* classes built in to the .NET Framework have the property that *IIdentity.Name* is sufficient to uniquely identify a particular user within a particular application.</span></span> <span data-ttu-id="8d446-200">例如， *FormsIdentity.Name*返回在成员资格数据库中 （这是唯一的具体取决于该数据库的所有应用程序），存储的用户名*WindowsIdentity.Name*返回域限定标识的用户，依此类推。</span><span class="sxs-lookup"><span data-stu-id="8d446-200">For example, *FormsIdentity.Name* returns the username stored in the membership database (which is unique for all applications depending on that database), *WindowsIdentity.Name* returns the domain-qualified identity of the user, and so on.</span></span> <span data-ttu-id="8d446-201">这些系统提供不仅身份验证;它们还*标识*向应用程序的用户。</span><span class="sxs-lookup"><span data-stu-id="8d446-201">These systems provide not only authentication; they also *identify* users to an application.</span></span>

<span data-ttu-id="8d446-202">基于声明的身份验证，但是，不一定需要标识特定用户。</span><span class="sxs-lookup"><span data-stu-id="8d446-202">Claims-based authentication, on the other hand, does not necessarily require identifying a particular user.</span></span> <span data-ttu-id="8d446-203">相反， *ClaimsPrincipal*并*ClaimsIdentity*都有一组类型相关*声明*实例，其中的各个声明可能是"为 18 + 年的保留时间"或"是管理员"为其他值。</span><span class="sxs-lookup"><span data-stu-id="8d446-203">Instead, the *ClaimsPrincipal* and *ClaimsIdentity* types are associated with a set of *Claim* instances, where the individual claims might be "is 18+ years of age" or "is an administrator" to anything else.</span></span> <span data-ttu-id="8d446-204">由于尚未一定标识该用户，不能使用运行时*ClaimsIdentity.Name*属性设置为该特定用户的唯一标识符。</span><span class="sxs-lookup"><span data-stu-id="8d446-204">Since the user hasn't necessarily been identified, the runtime cannot use the *ClaimsIdentity.Name* property as a unique identifier for this particular user.</span></span> <span data-ttu-id="8d446-205">团队已发现实际示例其中*ClaimsIdentity.Name*返回*null*、 返回友好 （显示） 的名称，或否则将返回一个字符串，并不适合用作唯一标识符为用户。</span><span class="sxs-lookup"><span data-stu-id="8d446-205">The team has seen real-world examples where *ClaimsIdentity.Name* returns *null*, returns a friendly (display) name, or otherwise returns a string that isn't appropriate for use as a unique identifier for the user.</span></span>

<span data-ttu-id="8d446-206">许多使用基于声明的身份验证的部署使用的[Azure 访问控制服务](https://msdn.microsoft.com/library/windowsazure/gg429786.aspx)(ACS) 特别。</span><span class="sxs-lookup"><span data-stu-id="8d446-206">Many of deployments which use claims-based authentication are using [Azure Access Control Service](https://msdn.microsoft.com/library/windowsazure/gg429786.aspx) (ACS) in particular.</span></span> <span data-ttu-id="8d446-207">ACS 允许开发人员可以配置单个*标识提供者*（例如 ADFS，Microsoft 帐户提供程序，OpenID 提供程序类似于 yahoo ！，等等），并标识提供程序返回*命名标识符*.</span><span class="sxs-lookup"><span data-stu-id="8d446-207">ACS allows the developer to configure individual *identity providers* (such as ADFS, the Microsoft Account provider, OpenID providers like Yahoo!, etc.), and the identity providers return *name identifiers*.</span></span> <span data-ttu-id="8d446-208">这些名称标识符可能包含个人身份信息 (PII)，为电子邮件地址，也可以为匿名等专用个人标识符 (PPID)。</span><span class="sxs-lookup"><span data-stu-id="8d446-208">These name identifiers may contain Personally Identifiable Information (PII) like an email address, or they could be anonymized like a Private Personal Identifier (PPID).</span></span> <span data-ttu-id="8d446-209">无论如何，元组 （标识提供者、 名称标识符） 足够作为特定用户的相应的跟踪令牌，而她正在浏览站点，因此，生成时，ASP.NET Web 堆栈运行时可以使用代替用户名元组和正在验证字段的 ANTI-XSRF 令牌。</span><span class="sxs-lookup"><span data-stu-id="8d446-209">Regardless, the tuple (identity provider, name identifier) sufficiently serves as an appropriate tracking token for a particular user while she is browsing the site, so the ASP.NET Web Stack Runtime can use the tuple in place of the username when generating and validating anti-XSRF field tokens.</span></span> <span data-ttu-id="8d446-210">标识提供者和名称标识符的特定 Uri 是：</span><span class="sxs-lookup"><span data-stu-id="8d446-210">The particular URIs for the identity provider and the name identifier are :</span></span>

- `http://schemas.microsoft.com/accesscontrolservice/2010/07/claims/identityprovider`
- `http://schemas.xmlsoap.org/ws/2005/05/identity/claims/nameidentifier`

<span data-ttu-id="8d446-211">(请参阅此[ACS 文档页](https://msdn.microsoft.com/library/windowsazure/gg185971.aspx)的详细信息。)</span><span class="sxs-lookup"><span data-stu-id="8d446-211">(see this [ACS doc page](https://msdn.microsoft.com/library/windowsazure/gg185971.aspx) for more info.)</span></span>

<span data-ttu-id="8d446-212">当生成或验证令牌时，ASP.NET Web 堆栈运行时将在运行时尝试绑定到类型：</span><span class="sxs-lookup"><span data-stu-id="8d446-212">When generating or validating a token, the ASP.NET Web Stack Runtime will at runtime try binding to the types:</span></span>

- <span data-ttu-id="8d446-213">`Microsoft.IdentityModel.Claims.IClaimsIdentity, Microsoft.IdentityModel, Version=3.5.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35` （适用于 WIF SDK。)</span><span class="sxs-lookup"><span data-stu-id="8d446-213">`Microsoft.IdentityModel.Claims.IClaimsIdentity, Microsoft.IdentityModel, Version=3.5.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35` (For the WIF SDK.)</span></span>
- <span data-ttu-id="8d446-214">`System.Security.Claims.ClaimsIdentity` （适用于.NET 4.5)。</span><span class="sxs-lookup"><span data-stu-id="8d446-214">`System.Security.Claims.ClaimsIdentity` (For .NET 4.5).</span></span>

<span data-ttu-id="8d446-215">如果这些类型存在，并且当前用户的*IIIIdentity*实现或子类其中一种类型，（标识提供者、 名称标识符），将使用的 ANTI-XSRF 设施代替用户名时生成的元组和验证的令牌。</span><span class="sxs-lookup"><span data-stu-id="8d446-215">If these types exist, and if the current user's *IIIIdentity* implements or subclasses one of these types, the anti-XSRF facility will use the (identity provider, name identifier) tuple in place of the username when generating and validating the tokens.</span></span> <span data-ttu-id="8d446-216">如果存在任何此类元组，不则请求将失败并出错向开发人员说明如何配置的 ANTI-XSRF 系统，以了解在使用特定的基于声明的身份验证机制。</span><span class="sxs-lookup"><span data-stu-id="8d446-216">If no such tuple is present, the request will fail with an error describing to the developer how to configure the anti-XSRF system to understand the particular claims-based authentication mechanism in use.</span></span> <span data-ttu-id="8d446-217">请参阅**[配置和可扩展性](#_Configuration_and_extensibility)** 部分，了解详细信息。</span><span class="sxs-lookup"><span data-stu-id="8d446-217">See the **[Configuration and extensibility](#_Configuration_and_extensibility)** section for more information.</span></span>

### <a name="oauth--openid-authentication"></a><span data-ttu-id="8d446-218">OAuth / OpenID 身份验证</span><span class="sxs-lookup"><span data-stu-id="8d446-218">OAuth / OpenID authentication</span></span>

<span data-ttu-id="8d446-219">最后的 ANTI-XSRF 设施提供特殊支持使用 OAuth 或 OpenID 身份验证的应用程序。</span><span class="sxs-lookup"><span data-stu-id="8d446-219">Finally, the anti-XSRF facility has special support for applications which use OAuth or OpenID authentication.</span></span> <span data-ttu-id="8d446-220">这种支持是基于启发式方法的： 如果当前*IIdentity.Name*开始 http:// 或 https:// 开头，然后将完成用户名比较使用序号比较器而不是默认 OrdinalIgnoreCase 比较器。</span><span class="sxs-lookup"><span data-stu-id="8d446-220">This support is heuristic-based: if the current *IIdentity.Name* begins with http:// or https://, then username comparisons will be done using an Ordinal comparer rather than the default OrdinalIgnoreCase comparer.</span></span>

<a id="_Configuration_and_extensibility"></a>

## <a name="configuration-and-extensibility"></a><span data-ttu-id="8d446-221">配置和可扩展性</span><span class="sxs-lookup"><span data-stu-id="8d446-221">Configuration and extensibility</span></span>

<span data-ttu-id="8d446-222">有时，开发人员可能希望严格控制的 ANTI-XSRF 生成和验证行为。</span><span class="sxs-lookup"><span data-stu-id="8d446-222">Occasionally, developers may want tighter control over the anti-XSRF generation and validation behaviors.</span></span> <span data-ttu-id="8d446-223">例如，可能会自动将 HTTP cookie 添加到响应的 MVC 和 Web Pages 帮助程序的默认行为是不可取，和开发人员可能想要持久保存在其他地方的令牌。</span><span class="sxs-lookup"><span data-stu-id="8d446-223">For example, perhaps the MVC and Web Pages helpers' default behavior of automatically adding HTTP cookies to the response is undesirable, and the developer may wish to persist the tokens elsewhere.</span></span> <span data-ttu-id="8d446-224">存在两个 Api，以帮助解决这个问题：</span><span class="sxs-lookup"><span data-stu-id="8d446-224">There exist two APIs to assist with this:</span></span>

`AntiForgery.GetTokens(string oldCookieToken, out string newCookieToken, out string formToken);`  
`AntiForgery.Validate(string cookieToken, string formToken);`

<span data-ttu-id="8d446-225">*GetTokens*方法的输入现有 XSRF 请求验证会话令牌 （这可能为 null），并为生成输出新 XSRF 请求验证会话令牌和字段令牌。</span><span class="sxs-lookup"><span data-stu-id="8d446-225">The *GetTokens* method takes as input an existing XSRF request verification session token (which may be null) and produces as output a new XSRF request verification session token and field token.</span></span> <span data-ttu-id="8d446-226">令牌是不带修饰符; 只是不透明字符串*formToken*值实例不会包装在&lt;输入&gt;标记。</span><span class="sxs-lookup"><span data-stu-id="8d446-226">The tokens are simply opaque strings with no decoration; the *formToken* value will for instance not be wrapped in an &lt;input&gt; tag.</span></span> <span data-ttu-id="8d446-227">*NewCookieToken*值可能为 null; 如果发生这种情况，则*oldCookieToken*值仍然有效，并且需要设置任何新的响应 cookie。</span><span class="sxs-lookup"><span data-stu-id="8d446-227">The *newCookieToken* value may be null; if this occurs, then the *oldCookieToken* value is still valid and no new response cookie need be set.</span></span> <span data-ttu-id="8d446-228">调用方*GetTokens*负责保持任何必要的响应 cookie 或生成任何必要的标记; *GetTokens*方法本身不会更改产生了负面影响的响应。</span><span class="sxs-lookup"><span data-stu-id="8d446-228">The caller of *GetTokens* is responsible for persisting any necessary response cookies or generating any necessary markup; the *GetTokens* method itself will not alter the response as a side effect.</span></span> <span data-ttu-id="8d446-229">*验证*方法将传入会话和字段令牌并对它们运行前面提到的验证逻辑。</span><span class="sxs-lookup"><span data-stu-id="8d446-229">The *Validate* method takes the incoming session and field tokens and runs the aforementioned validation logic over them.</span></span>

### <a name="antiforgeryconfig"></a><span data-ttu-id="8d446-230">AntiForgeryConfig</span><span class="sxs-lookup"><span data-stu-id="8d446-230">AntiForgeryConfig</span></span>

<span data-ttu-id="8d446-231">开发人员可以配置应用程序中的 ANTI-XSRF 系统\_开始。</span><span class="sxs-lookup"><span data-stu-id="8d446-231">The developer may configure the anti-XSRF system from Application\_Start.</span></span> <span data-ttu-id="8d446-232">以编程方式配置。</span><span class="sxs-lookup"><span data-stu-id="8d446-232">Configuration is programmatic.</span></span> <span data-ttu-id="8d446-233">属性的静态*AntiForgeryConfig*类型如下所述。</span><span class="sxs-lookup"><span data-stu-id="8d446-233">The properties of the static *AntiForgeryConfig* type are described below.</span></span> <span data-ttu-id="8d446-234">使用声明的大多数用户将希望将 UniqueClaimTypeIdentifier 属性设置。</span><span class="sxs-lookup"><span data-stu-id="8d446-234">Most users using claims will want to set the UniqueClaimTypeIdentifier property.</span></span>

| <span data-ttu-id="8d446-235">**Property**</span><span class="sxs-lookup"><span data-stu-id="8d446-235">**Property**</span></span> | <span data-ttu-id="8d446-236">**说明**</span><span class="sxs-lookup"><span data-stu-id="8d446-236">**Description**</span></span> |
| --- | --- |
| <span data-ttu-id="8d446-237">**AdditionalDataProvider**</span><span class="sxs-lookup"><span data-stu-id="8d446-237">**AdditionalDataProvider**</span></span> | <span data-ttu-id="8d446-238">[IAntiForgeryAdditionalDataProvider](https://msdn.microsoft.com/library/system.web.helpers.iantiforgeryadditionaldataprovider(v=vs.111).aspx) ，在令牌的生成过程中提供额外的数据和在令牌验证期间会占用更多数据。</span><span class="sxs-lookup"><span data-stu-id="8d446-238">An [IAntiForgeryAdditionalDataProvider](https://msdn.microsoft.com/library/system.web.helpers.iantiforgeryadditionaldataprovider(v=vs.111).aspx) that provides additional data during token generation and consumes additional data during token validation.</span></span> <span data-ttu-id="8d446-239">默认值是*null*。</span><span class="sxs-lookup"><span data-stu-id="8d446-239">The default value is *null*.</span></span> <span data-ttu-id="8d446-240">有关详细信息，请参阅[IAntiForgeryAdditionalDataProvider](https://msdn.microsoft.com/library/system.web.helpers.iantiforgeryadditionaldataprovider(v=vs.111).aspx)部分。</span><span class="sxs-lookup"><span data-stu-id="8d446-240">For more information, see the [IAntiForgeryAdditionalDataProvider](https://msdn.microsoft.com/library/system.web.helpers.iantiforgeryadditionaldataprovider(v=vs.111).aspx) section.</span></span> |
| <span data-ttu-id="8d446-241">**CookieName**</span><span class="sxs-lookup"><span data-stu-id="8d446-241">**CookieName**</span></span> | <span data-ttu-id="8d446-242">提供用于存储的 ANTI-XSRF 会话令牌的 HTTP cookie 的名称的字符串。</span><span class="sxs-lookup"><span data-stu-id="8d446-242">A string that provides the name of the HTTP cookie that is used to store the anti-XSRF session token.</span></span> <span data-ttu-id="8d446-243">如果未设置此值，将自动生成名称基于应用程序的已部署的虚拟路径。</span><span class="sxs-lookup"><span data-stu-id="8d446-243">If this value is not set, a name will be automatically generated based on the application's deployed virtual path.</span></span> <span data-ttu-id="8d446-244">默认值是*null*。</span><span class="sxs-lookup"><span data-stu-id="8d446-244">The default value is *null*.</span></span> |
| <span data-ttu-id="8d446-245">**RequireSsl**</span><span class="sxs-lookup"><span data-stu-id="8d446-245">**RequireSsl**</span></span> | <span data-ttu-id="8d446-246">一个布尔值，指示是否需要通过 SSL 安全通道提交的 ANTI-XSRF 令牌。</span><span class="sxs-lookup"><span data-stu-id="8d446-246">A Boolean that dictates whether the anti-XSRF tokens are required to be submitted over an SSL-secured channel.</span></span> <span data-ttu-id="8d446-247">如果此值为 *，则返回 true*、 自动生成的任何 cookie 将具有"安全"标志设置，并且从通过 SSL 未提交的请求中调用，则会引发的 ANTI-XSRF Api。</span><span class="sxs-lookup"><span data-stu-id="8d446-247">If this value is *true*, any automatically-generated cookies will have the "secure" flag set, and the anti-XSRF APIs will throw if called from within a request that is not submitted via SSL.</span></span> <span data-ttu-id="8d446-248">默认值为“false”。</span><span class="sxs-lookup"><span data-stu-id="8d446-248">The default value is *false*.</span></span> |
| <span data-ttu-id="8d446-249">**SuppressIdentityHeuristicChecks**</span><span class="sxs-lookup"><span data-stu-id="8d446-249">**SuppressIdentityHeuristicChecks**</span></span> | <span data-ttu-id="8d446-250">一个布尔值，指示的 ANTI-XSRF 系统是否应停用它对基于声明的标识的支持。</span><span class="sxs-lookup"><span data-stu-id="8d446-250">A Boolean that dictates whether the anti-XSRF system should deactivate its support for claims-based identities.</span></span> <span data-ttu-id="8d446-251">如果此值为 *，则返回 true*，系统将假定*IIdentity.Name*适合用作唯一的每个用户标识符并且不会尝试使用特殊处理*IClaimsIdentity*或*ClClaimsIdentity*中所述[WIF / ACS / 基于声明的身份验证](#_WIF_ACS)部分。</span><span class="sxs-lookup"><span data-stu-id="8d446-251">If this value is *true*, the system will assume that *IIdentity.Name* is appropriate for use as a unique per-user identifier and will not try to special-case *IClaimsIdentity* or *ClClaimsIdentity* as described in the [WIF / ACS / claims-based authentication](#_WIF_ACS) section.</span></span> <span data-ttu-id="8d446-252">默认值为 `false`。</span><span class="sxs-lookup"><span data-stu-id="8d446-252">The default value is `false`.</span></span> |
| <span data-ttu-id="8d446-253">**UniqueClaimTypeIdentifier**</span><span class="sxs-lookup"><span data-stu-id="8d446-253">**UniqueClaimTypeIdentifier**</span></span> | <span data-ttu-id="8d446-254">一个字符串，指示哪些声明类型适合用作唯一的每个用户标识符。</span><span class="sxs-lookup"><span data-stu-id="8d446-254">A string that indicates which claim type is appropriate for use as a unique per-user identifier.</span></span> <span data-ttu-id="8d446-255">如果此值是组和当前*IIdentity*基于声明的则系统将尝试提取声明的类型由指定*UniqueClaimTypeIdentifier*，并且将使用相应的值代替时生成的字段标记的用户的用户名。</span><span class="sxs-lookup"><span data-stu-id="8d446-255">If this value is set and the current *IIdentity* is claims-based, the system will attempt to extract a claim of the type specified by *UniqueClaimTypeIdentifier*, and the corresponding value will be used in place of the user's username when generating the field token.</span></span> <span data-ttu-id="8d446-256">如果找不到声明类型，系统将无法发送请求。</span><span class="sxs-lookup"><span data-stu-id="8d446-256">If the claim type is not found, the system will fail the request.</span></span> <span data-ttu-id="8d446-257">默认值是*null*，指示系统应使用 （标识提供者、 名称标识符） 代替用户的用户名按前面所述的元组。</span><span class="sxs-lookup"><span data-stu-id="8d446-257">The default value is *null*, which indicates that the system should use the (identity provider, name identifier) tuple as previously described in place of the user's username.</span></span> |

<a id="_IAntiForgeryAdditionalDataProvider"></a>

### <a name="iantiforgeryadditionaldataprovider"></a><span data-ttu-id="8d446-258">IAntiForgeryAdditionalDataProvider</span><span class="sxs-lookup"><span data-stu-id="8d446-258">IAntiForgeryAdditionalDataProvider</span></span>

<span data-ttu-id="8d446-259">*[IAntiForgeryAdditionalDataProvider](https://msdn.microsoft.com/library/system.web.helpers.iantiforgeryadditionaldataprovider(v=vs.111).aspx)* 类型允许开发人员能够通过往返其他数据中的每个标记扩展的 ANTI-XSRF 系统的行为。</span><span class="sxs-lookup"><span data-stu-id="8d446-259">The *[IAntiForgeryAdditionalDataProvider](https://msdn.microsoft.com/library/system.web.helpers.iantiforgeryadditionaldataprovider(v=vs.111).aspx)* type allows developers to extend the behavior of the anti-XSRF system by round-tripping additional data in each token.</span></span> <span data-ttu-id="8d446-260">*GetAdditionalData*每次调用方法生成的字段标记，并返回值嵌入生成的令牌中。</span><span class="sxs-lookup"><span data-stu-id="8d446-260">The *GetAdditionalData* method is called each time a field token is generated, and the return value is embedded within the generated token.</span></span> <span data-ttu-id="8d446-261">实现器可能从此方法返回一个时间戳、 nonce 或希望在她的任何其他值。</span><span class="sxs-lookup"><span data-stu-id="8d446-261">An implementer could return a timestamp, a nonce, or any other value she wishes from this method.</span></span>

<span data-ttu-id="8d446-262">同样， *ValidateAdditionalData*每次调用方法的字段的令牌进行验证，并嵌入令牌中的"其他数据"字符串传递给方法。</span><span class="sxs-lookup"><span data-stu-id="8d446-262">Similarly, the *ValidateAdditionalData* method is called each time a field token is validated, and the "additional data" string that was embedded within the token is passed to the method.</span></span> <span data-ttu-id="8d446-263">验证例程可以 （通过检查当前时间针对令牌在创建时存储的时间） 来实现超时，nonce 检查例程，或任何其他所需的逻辑。</span><span class="sxs-lookup"><span data-stu-id="8d446-263">The validation routine could implement a timeout (by checking the current time against the time that was stored when the token was created), a nonce checking routine, or any other desired logic.</span></span>

## <a name="design-decisions-and-security-considerations"></a><span data-ttu-id="8d446-264">设计决策和安全注意事项</span><span class="sxs-lookup"><span data-stu-id="8d446-264">Design decisions and security considerations</span></span>

<span data-ttu-id="8d446-265">链接的会话和字段的令牌的安全令牌从技术上讲时才是必需尝试匿名 / 未经身份验证用户免受 XSRF 攻击。</span><span class="sxs-lookup"><span data-stu-id="8d446-265">The security token that links the session and field tokens is technically only necessary when trying to protect anonymous / unauthenticated users against XSRF attacks.</span></span> <span data-ttu-id="8d446-266">当用户进行身份验证时，身份验证令牌本身 （可能 cookie 的形式提交） 可用作一个半同步器令牌对。</span><span class="sxs-lookup"><span data-stu-id="8d446-266">When the user is authenticated, the authentication token itself (presumably submitted in the form of a cookie) could be used as one half of a synchronizer token pair.</span></span> <span data-ttu-id="8d446-267">但是，有有效保护受到未经授权的用户的登录页的方案和的 ANTI-XSRF 逻辑始终生成和验证安全令牌，即使对于身份验证的用户通过更加简单。</span><span class="sxs-lookup"><span data-stu-id="8d446-267">However, there are valid scenarios for protecting login pages hit by unauthenticated users, and the anti-XSRF logic was made simpler by always generating and validating the security token, even for authenticated users.</span></span> <span data-ttu-id="8d446-268">它还提供了一些额外的保护的事件中字段令牌曾入侵攻击者，为设置或猜测会话令牌攻击者能够克服的另一个障碍。</span><span class="sxs-lookup"><span data-stu-id="8d446-268">It also does provide some additional protection in the event that a field token is ever compromised by an attacker, as setting or guessing the session token would be another hurdle for the attacker to overcome.</span></span>

<span data-ttu-id="8d446-269">当在单个域承载多个应用程序时，开发人员应小心。</span><span class="sxs-lookup"><span data-stu-id="8d446-269">Developers should use caution when multiple applications are hosted in a single domain.</span></span> <span data-ttu-id="8d446-270">例如，即使*example1.cloudapp.net*并*example2.cloudapp.net*不同主机下的所有主机之间没有隐式信任关系 *\*。 cloudapp.net*域。</span><span class="sxs-lookup"><span data-stu-id="8d446-270">For example, even though *example1.cloudapp.net* and *example2.cloudapp.net* are different hosts, there is an implicit trust relationship between all hosts under the *\*.cloudapp.net* domain.</span></span> <span data-ttu-id="8d446-271">此隐式信任关系[允许可能不受信任的主机以影响彼此的 cookie](http://stackoverflow.com/questions/9636857/how-can-asp-net-or-asp-net-mvc-be-protected-from-related-domain-cookie-attacks) （控制 AJAX 请求的同域策略不一定适用于 HTTP cookie）。</span><span class="sxs-lookup"><span data-stu-id="8d446-271">This implicit trust relationship [allows potentially untrusted hosts to affect each other's cookies](http://stackoverflow.com/questions/9636857/how-can-asp-net-or-asp-net-mvc-be-protected-from-related-domain-cookie-attacks) (the same-origin policies that govern AJAX requests do not necessarily apply to HTTP cookies).</span></span> <span data-ttu-id="8d446-272">ASP.NET Web 堆栈运行时，用户名嵌入到该字段标记，因此即使恶意子域是能够覆盖会话令牌将无法生成有效的字段标记，以该用户提供一些缓解措施。</span><span class="sxs-lookup"><span data-stu-id="8d446-272">The ASP.NET Web Stack Runtime provides some mitigation in that the username is embedded into the field token, so even if a malicious subdomain is able to overwrite a session token it will be unable to generate a valid field token for the user.</span></span> <span data-ttu-id="8d446-273">但是，在这种环境中托管时内置的 ANTI-XSRF 例程仍不能抵御会话劫持或登录名 XSRF。</span><span class="sxs-lookup"><span data-stu-id="8d446-273">However, when hosted in such an environment the built-in anti-XSRF routines still cannot defend against session hijacking or login XSRF.</span></span>

<span data-ttu-id="8d446-274">ANTI-XSRF 例程当前执行不抵御[点击劫持](https://www.owasp.org/index.php/Clickjacking)。</span><span class="sxs-lookup"><span data-stu-id="8d446-274">The anti-XSRF routines currently do not defend against [clickjacking](https://www.owasp.org/index.php/Clickjacking).</span></span> <span data-ttu-id="8d446-275">想要自行防范点击劫持的应用程序可以轻松完成此操作发送 X 帧选项： SAMEORIGIN 标头以及每个响应。</span><span class="sxs-lookup"><span data-stu-id="8d446-275">Applications that wish to defend themselves against clickjacking may easily do so by sending an X-Frame-Options: SAMEORIGIN header with each response.</span></span> <span data-ttu-id="8d446-276">所有最新的浏览器都支持此标头。</span><span class="sxs-lookup"><span data-stu-id="8d446-276">This header is supported by all recent browsers.</span></span> <span data-ttu-id="8d446-277">有关详细信息，请参阅[IE 博客](https://blogs.msdn.com/b/ieinternals/archive/2010/03/30/combating-clickjacking-with-x-frame-options.aspx)，则[SDL 博客](https://blogs.msdn.com/b/sdl/archive/2009/02/05/clickjacking-defense-in-ie8.aspx)，并[OWASP](https://www.owasp.org/index.php/Clickjacking)。</span><span class="sxs-lookup"><span data-stu-id="8d446-277">For more information, see the [IE blog](https://blogs.msdn.com/b/ieinternals/archive/2010/03/30/combating-clickjacking-with-x-frame-options.aspx), the [SDL blog](https://blogs.msdn.com/b/sdl/archive/2009/02/05/clickjacking-defense-in-ie8.aspx), and [OWASP](https://www.owasp.org/index.php/Clickjacking).</span></span> <span data-ttu-id="8d446-278">ASP.NET Web 堆栈运行时可能会在一些将来的版本使 MVC 和网页的 ANTI-XSRF 帮助程序自动设置此标头，以便应用程序遭受此种攻击会自动受到保护。</span><span class="sxs-lookup"><span data-stu-id="8d446-278">The ASP.NET Web Stack Runtime may in some future release make the MVC and Web Pages anti-XSRF helpers automatically set this header so that applications are automatically protected against this attack.</span></span>

<span data-ttu-id="8d446-279">Web 开发人员应继续以确保它们的站点不是很容易受到 XSS 攻击。</span><span class="sxs-lookup"><span data-stu-id="8d446-279">Web developers should continue to ensure that their site is not vulnerable to XSS attacks.</span></span> <span data-ttu-id="8d446-280">XSS 攻击是功能非常强大，并成功利用此漏洞也会破坏 ASP.NET Web 堆栈运行时对防御 XSRF 攻击。</span><span class="sxs-lookup"><span data-stu-id="8d446-280">XSS attacks are very powerful, and a successful exploit would also break the ASP.NET Web Stack Runtime defenses against XSRF attacks.</span></span>

## <a name="acknowledgment"></a><span data-ttu-id="8d446-281">确认</span><span class="sxs-lookup"><span data-stu-id="8d446-281">Acknowledgment</span></span>

<span data-ttu-id="8d446-282">[@LeviBroderick](https://twitter.com/LeviBroderick)谁写入 ASP.NET 安全代码的大部分此信息的大容量。</span><span class="sxs-lookup"><span data-stu-id="8d446-282">[@LeviBroderick](https://twitter.com/LeviBroderick), who wrote much of the ASP.NET security code the bulk of this information.</span></span>
